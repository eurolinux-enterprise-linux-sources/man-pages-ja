.\"
.\" Japanese Version Copyright (c) 2000-2003 Yuichi SATO
.\"         all rights reserved.
.\" Translated Wed Dec 20 19:01:03 JST 2000
.\"         by Yuichi SATO <sato@complex.eng.hokudai.ac.jp>
.\" Updated & Modified Tue Apr 29 20:36:04 JST 2003
.\"         by Yuichi SATO <ysato444@yahoo.co.jp>
.\"
.\"WORD:	compress	圧縮
.\"WORD:	decompress	伸長
.\"
.PU
.TH bzip2 1
.SH 名前
bzip2, bunzip2 \- ブロックソートによってファイルを圧縮・伸長する。バージョン 1.0.2
.br
bzcat \- ファイルを標準出力に伸長する
.br
bzip2recover \- 破損した bzip2 ファイルからデータを復元する

.SH 書式
.ll +8
.B bzip2
.RB [ " \-cdfkqstvzVL123456789 " ]
[
.I "filenames \&..."
]
.ll -8
.br
.B bunzip2
.RB [ " \-fkvsVL " ]
[ 
.I "filenames \&..."
]
.br
.B bzcat
.RB [ " \-s " ]
[ 
.I "filenames \&..."
]
.br
.B bzip2recover
.I "filename"

.SH 説明
.I bzip2
は、Burrows-Wheeler ブロックソートテキスト圧縮アルゴリズムと
Huffman コード化を使ってファイルを圧縮する。
圧縮率は、一般的な LZ77/LZ78 ベースの圧縮率に比べると、大抵の場合でとても良い。
また、圧縮速度は、統計的圧縮法である PPM 圧縮の速度に近づいている。

コマンドラインオプションは
.I GNU gzip
のオプションにわざと似せてあるが、同じではない。

.I bzip2
はコマンドラインのフラグを伴ったファイル名のリストを受け取る。
各ファイルは、"original_name.bz2" という名前の
圧縮されたファイルに置き換えられる。
圧縮ファイルの修正日・アクセス権・(設定可能な場合の) 所有者は、
元のファイルと同じになる。
これにより、伸長時に属性が正しく復元される。
ファイル名の操作は、
元のファイル名・アクセス権・所有者を保存する仕組みが
ファイルシステムになかったり、
MS-DOS のように深刻なファイル名の長さ制限があるために、
とても面倒である。

.I bzip2
と
.I bunzip2
はデフォルトでは既存のファイルを上書きしない。
上書きしたい場合は \-f フラグを指定すること。

ファイル名が指定されない場合、
.I bzip2
標準入力を圧縮して標準出力に書き出す。
この場合、
.I bzip2
は圧縮された出力を端末には書き出さない。
なぜなら、この出力は全く分かりにくくて、無駄なものだからである。

.I bunzip2
(または
.IR "bzip2 \-d" ) 
は、指定された全てのファイルを伸長する。
.I bzip2
で圧縮されていないファイルは検知され、無視される。
さらに警告が出される。
.I bzip2
は、以下のようにして圧縮ファイルの名前から伸長後のファイル名を推測する。

       filename.bz2    は   filename         になる。
       filename.bz     は   filename         になる。
       filename.tbz2   は   filename.tar     になる。
       filename.tbz    は   filename.tar     になる。
       anyothername    は   anyothername.out になる。

ファイル名が
.IR .bz2 , 
.IR .bz , 
.IR .tbz2 ,
.I .tbz
のような認識される拡張子のいずれかで終っていない場合、
.I bzip2
は元のファイル名が推測できないという警告を出し、
.I .out
を付加した名前を元のファイル名として使う。

圧縮の場合と同様に、
ファイル名が指定されない場合は、
標準入力を伸長して標準出力に書き出す。

.I bunzip2 
は 2 つ以上の圧縮ファイルを連結したファイルでも正しく伸長する。
伸長して得られるファイルは、圧縮前のファイルを連結したものになる。
連結した圧縮ファイルの完全性テスト (\-t) もサポートされている。

\-c フラグを指定することにより、
圧縮・伸長されたファイルを標準出力に書き出すこともできる。
このフラグを指定して、複数のファイルを圧縮・伸長することができる。
結果の出力は標準出力に順番に書き出される。
この方式による複数ファイルの圧縮では、
複数圧縮ファイル表現を含むストリームが生成される。
このようなストリームは、
バージョン 0.9.0 以降の
.I bzip2 
でしか正しく伸長できない。
これより前のバージョンの
.I bzip2
ではストリーム中の最初のファイルを伸長した後に停止する。

.I bzcat
(または
.IR "bzip2 -dc" ) 
は指定した全てのファイルを伸長し、標準出力に書き出す。

.I bzip2
は環境変数
.IR BZIP2 ,
.I BZIP
からこの順番で引き数を読み込み、
コマンドラインから読み込まれた引き数よりも先に処理する。
これはデフォルトの引き数を与える便利な方法である。

圧縮後のファイルが元のファイルより少し大きくなる場合であっても、
圧縮は常に行われる。
100 バイトより小さいぐらいのファイルは、圧縮によって大きくなる傾向がある。
なぜなら、この圧縮メカニズムが
定常的に 50 バイトのオーバーヘッドを持つためである。
(大部分のファイル圧縮法による出力を含む) ランダムなデータは、
1 バイト当たり約 8.05 ビットでコード化され、約 0.5% 大きくなる。

データ保護のための自己チェックとして、
.I bzip2
は 32 ビット CRC を破損したファイルを元のファイルと同じにするために使う。
これにより、圧縮データの破損とまだ見つかっていない
.I bzip2
のバグ (とても少ないことを期待する) からデータを保護することができる。
データの破損が検知されない確率は非常に少なく、
各ファイル処理につき 40 億回に 1 回程度である。
しかし、このチェックは伸長のときにしか行われないので、
何か間違いがあることを知らせるだけである点に注意すること。
オリジナルの圧縮されていないデータを復元する助けにはならない。
破損したファイルからデータを復元するためには、
.I bzip2recover
を使うことができる。

返り値:
正常終了の場合、0 が返される。
実行環境の問題 (ファイルがない・不正なフラグ・
I/O エラーなど) がある場合、1 が返される。
破損した圧縮ファイルの場合、2 が返される。
.I bzip2
にパニックを引き起こす内部整合性エラー (例えば、バグ) の場合、3 が返される。

.SH オプション
.TP
.B \-c --stdout
圧縮・伸長した結果を標準出力に書き出す。
.TP
.B \-d --decompress
ファイルの伸長をさせる。
.IR bzip2 , 
.IR bunzip2 ,
.I bzcat 
は実際には同じプログラムである。
どの動作をするのかは、どの名前が使われたかに基づいて決められる。
このフラグは、その動作決定機構より優先され、
.I bzip2
にファイルの伸長をさせる。
.TP
.B \-z --compress
\-d の反対。
起動された名前にかかわらず、ファイルの圧縮をさせる。
.TP
.B \-t --test
指定されたファイルの完全性のチェックをするが、伸長はしない。
伸長テストを行い、結果を破棄する。
.TP
.B \-f --force
出力ファイルの上書きをさせる。
通常、
.I bzip2 
は既存の出力ファイルを上書きしない。
さらに
.I bzip2 
にファイルへのハードリンクを削除させる。
このオプションが指定されていない場合は、ハードリンクの削除もされない。

通常 bzip2 は正しいマジックヘッダバイトを持たないファイルを伸長しない。
ただし (-f) で強制すれば、これらのファイルも修正せずに通過させる。
これは GNU gzip の動作と同じである。
.TP
.B \-k --keep
伸長・展開の後でも入力ファイルを保存する (削除しない)。
.TP
.B \-s --small
圧縮・伸長・テストの際のメモリ使用量を減らす。
1 ブロックバイト当たり 2.5 バイトしか必要としない
修正されたアルゴリズムを使って、
ファイルの伸長・テストが行われる。
全てのファイルが 2300kB のメモリで伸長できるが、
通常の速度の約半分の速度になってしまう。

圧縮の場合、\-s フラグを使うと 200kB のブロックサイズが選択される。
メモリ使用量はこれと同じくらいになるが、圧縮率が犠牲になる。
つまり、計算機にメモリが少ない (8 MB 以下) 場合は、
全てのファイルについて \-s フラグを使うこと。
以下の「メモリ管理」セクションを参照すること。
.TP
.B \-q --quiet
本質的でない警告メッセージを抑制する。
I/O エラーと致命的なイベントに関係するメッセージは抑制されない。
.TP
.B \-v --verbose
詳細表示モード -- 各ファイル処理について圧縮率を表示する。
さらに \-v の数を増やすと、詳細表示のレベルも上がり、
主に診断を目的とする多くの情報を書き出す。
.TP
.B \-L --license -V --version
ソフトウェアのバージョン・ライセンス・配布条件を表示する。
.TP
.B \-1 (または \-\-fast) から \-9 (または \-\-best)
圧縮の場合、ブロックサイズを 100 k, 200 k ..  900 k に設定する。
伸長の場合、何も影響を及ぼさない。
以下の「メモリ管理」セクションを参照すること。
\-\-fast と \-\-best エイリアスは、
主として GNU gzip との互換性のためにある。
特に \-\-fast オプションで目に見えて速くなる訳ではない。
また \-\-best は単にデフォルトの動作を選択するだけである。
.TP
.B \--
これ以降の引き数が、たとえダッシュで始まるものであっても、
ファイル名として扱う。
これにより、ダッシュで始まる名前のファイルを扱うことができる。
例を挙げる: bzip2 \-- \-myfilename
.TP
.B \--repetitive-fast --repetitive-best
これらのフラグは、バージョン 0.9.5 以降では余計なものである。
これらのフラグは、以前のバージョンでソートアルゴリズムの動作を
大雑把に制御するために提供されたもので、時々は役立ったものである。
0.9.5 以降では、これらのフラグが無関係になる
改良されたアルゴリズムが使われている。

.SH メモリ管理
.I bzip2
はブロック毎に大きなファイルを圧縮する。
ブロックサイズは、実行された結果の圧縮率と
圧縮・伸長に必要なメモリ使用量の両方に影響を及ぼす。
フラグ \-1 から \-9 は、それぞれブロックサイズ
100,000 バイトから (デフォルトの) 900,000 バイトを指定する。
伸長時には、圧縮に使われたブロックサイズが圧縮ファイルのヘッダから読み込まれ、
.I bunzip2
はファイルを伸長するのにちょうど十分なメモリを確保する。
ブロックサイズは圧縮ファイルに格納されているので、
伸長時にはフラグ \-1 から \-9 は関係なく無視される。

圧縮・伸縮に必要なメモリ使用量 (バイト単位) は、
以下のように計算できる:

       圧縮:   400k + ( 8 x ブロックサイズ )

       伸長:   100k + ( 4 x ブロックサイズ ), または
               100k + ( 2.5 x ブロックサイズ )

大きいブロックサイズにすると、境界の返り値をすぐに減少させる。
大部分の圧縮は、最初の 200kB から 300kB のブロックサイズでつくられる。
.I bzip2
をメモリの少ない計算機で使う場合は、
このことを覚えておく価値がある。
さらに、伸長に必要なメモリは、圧縮時にブロックサイズを選択することで
設定される点を知っておくことも重要である。

デフォルトの 900kB ブロックサイズで圧縮されたファイルに対して、
.I bunzip2
は伸長時に約 3700kB のメモリを必要とする。
4MB のメモリの計算機でファイル伸長をサポートするには、
.I bunzip2
このメモリ量の約半分、約 2300kB を使って伸長するオプションがある。
伸長速度も半分になるので、このオプションは必要な場合にのみ使うべきである。
関連するフラグとして -s がある。

一般的には、メモリの制限が許す限り一番大きなブロックサイズを使うこと。
こうすることで圧縮率が最も良くなる。
圧縮・伸長の速度は事実上ブロックサイズに影響されない。

他に重要な点が単一のブロックに適用される。
-- つまり、入手する大部分のファイルは、
大きいブロックサイズを使っているということである。
このファイルのサイズはブロックサイズより小さいので、
実際のメモリ使用量はファイルサイズに比例する。
例えば、20,000 バイト (20kB) のファイルを -9 フラグで圧縮する場合、
7600kB のメモリが確保されるが、400k + 20000 * 8 = 560kB しか使用しない。
同様に、伸長時には 3700kB が確保されるが、
100k + 20000 * 4 = 180 kB しか使用しない。

異なるブロックサイズに対しての最大メモリ使用量をまとめたテーブルを以下に示す。
カルガリー大学のテキスト圧縮コーパス
(14 個のファイル、合計 3,141,622 バイト) を
圧縮したサイズも記録されている。
行毎に比べると、ブロックサイズによって圧縮が
どのように変わるかを知ることができる。
この数字は、大きなファイルに対して大きなブロックサイズを使うことの利点を、
控え目にしか述べていない。
なぜなら、このコーパスが小さめのファイルで占められているためである。

            圧縮時の   伸長時の  -s 伸長時の  コーパスの
   フラグ    使用量     使用量      使用量      サイズ

     -1      1200k       500k         350k      914704
     -2      2000k       900k         600k      877703
     -3      2800k      1300k         850k      860338
     -4      3600k      1700k        1100k      846899
     -5      4400k      2100k        1350k      845160
     -6      5200k      2500k        1600k      838626
     -7      6100k      2900k        1850k      834096
     -8      6800k      3300k        2100k      828642
     -9      7600k      3700k        2350k      828642

.SH 破損したファイルからのデータ復元
.I bzip2
は、通常 900kB のブロックでファイルを圧縮する。
各ブロックは独立に操作される。
メディアのエラーや転送エラーにより、
複数ブロックからなる .bz2 ファイルが破損しても、
ファイルの破損していないブロックからデータを復元できる可能性がある。

各ブロックの圧縮された表現は、48 ビットのパターンで区切られる。
このパターンにより、論理的な確実性を持ってブロック境界を見つけることができる。
各ブロックにはそれぞれの 32 ビット CRC があるので、
破損したブロックは破損していないものと区別できる。

.I bzip2recover
は、.bz2 ファイルの各ブロックを検索し、
それ独自の .bz2 ファイルに各ブロックを書き出す。
ユーザーは、
.I bzip2 
\-t
を使って得られたファイルの完全性をテストし、
破損していないファイルとして伸長できる。

.I bzip2recover
は、破損したファイルを唯一の引き数として受け取り、
抽出されたブロックを含んだ "rec00001file.bz2", "rec00002file.bz2", ...,
という多くのファイルを書き出す。
出力ファイルの名前は、
その後の処理でワイルドカードが使えるように設計されている
-- 例えば、
"bzip2 -dc  rec*file.bz2 > recovered_data" 
-- とすれば、ファイルを正しい順番で処理することができる。

大きな .bz2 ファイルには多くのブロックが含まれているので、
.I bzip2recover
は、ほとんどの場合、このようなファイルを扱うために使われる。
1 ブロックが全て破損したブロックは復元できないので、
このようなファイルに対して使うのは明らかに無駄である。
メディアエラーや転送エラーによる潜在的なデータ損失を少なくしたいなら、
小さいブロックサイズで圧縮することを考えた方が良い。

.SH 性能に関する注意
圧縮のソートフェーズでは、ファイル中の同一の文字列を集める。
そのため、"aabaabaabaab ..." のように (数百回)
同じシンボルが長く繰り返されているファイルは、
通常のものより圧縮が遅くなる。
バージョン 0.9.5 以降では以前のバージョンに比べると、この点が良くなっている。
圧縮時間の最も悪い場合と平均の場合の比率は、10:1 の範囲である。
以前のバージョンでは、この比率は 100:1 であった。
もし見てみたいなら、\-vvvv オプションを使って、
詳細な圧縮過程の進行を見ることができる。

伸長は、この現象に影響されない。

.I bzip2
は通常、操作のために数メガバイトのメモリを確保し、
とてもランダムな方法で確保されたメモリを変更する。
これは、「圧縮・伸長の両方の性能は、
キャッシュにない場合に計算機が対応する速度に大きく依存する」
ということを意味する。
そのため、キャッシュにない割合を減らすためのちょっとしたコードの変更が、
非常に大きな性能の向上をもたらしたのを見たことがある。
.I bzip2
は、非常に大きなキャッシュを持った計算機で、
最も良い性能を発揮すると考えられる。

.SH 警告
I/O エラーのメッセージは、それほど役立たない。
.I bzip2
は、できるだけ I/O エラーを検知して正しく終了しようとする。
しかし、何が問題なのかの詳細は、ときどきかなり間違ったものに見える。

この man ページは、バージョン 1.0.2 の
.I bzip2
について述べている。
このバージョンで生成された圧縮データは、
以前のパブリックリリースであるバージョン
0.1pl2, 0.9.0, 0.9.5, 1.0.0, 1.0.1 に対して、
前方互換と後方互換がある。
ただし、次のような例外がある:
0.9.0 以降では複数のファイルを連結して圧縮したファイルを伸長できるが、
0.1pl2 では伸長できず、ストリームの最初にあるファイルを伸長した後に停止する。

このバージョン 1.0.2 以前の
.I bzip2recover
は、圧縮ファイルでのビット位置を表現するために、32 ビットの整数を使う。
そのため 512MB 以上の圧縮ファイルを扱えない。
バージョン 1.0.2 とそれ以前のものでも、
サポート可能なプラットフォーム
(GNU がサポートするターゲットと Windows) では、
64 ビット int を使用していた。
この制限を付けて bzip2recover がビルドされているかを確認するには、
引き数なしで実行すれば良い。
少なくとも MaybeUInt64 を符号なし 64 ビット整数型に設定して
再コンパイルすることにより、
非制限バージョンをビルドすることができる。



.SH 著者
Julian Seward, jseward@acm.org.

http://sources.redhat.com/bzip2

.I bzip2
に含まれているアイディアは、(少なくとも) 以下の方々のおかげである:
Michael Burrows, David Wheeler (ブロックソート変換),
David Wheeler (Huffman コード化についても), 
Peter Fenwick (オリジナルの
.I bzip
における構造化コード化モデル、そして多くの改良), 
Alistair Moffat, Radford Neal, Ian Witten (オリジナルの
.I bzip
における算術コード化)。  
私は、彼らの助け・サポート・助言に対して感謝している。
ドキュメントのソースの場所については、
ソース配布の中のマニュアルを参照すること。
Christian von Roques は、圧縮速度の向上のために、
より速いソートアルゴリズムを探すことを勧めてくれた。
Bela Lubkin は、圧縮速度が最も遅い場合の改良を勧めてくれた。
bz* スクリプトは GNU gzip のものに由来している。
多くの方々がパッチを送り、軽便性の問題について助けてくれた。
また、計算機を貸してくれたり、アドバイスをしてくれた人達もいた。
これらは全て助けになった。
