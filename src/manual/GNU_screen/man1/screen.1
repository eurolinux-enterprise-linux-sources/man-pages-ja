.\" Translated Tue May 11 23:05:28 JST 1999
.\"    by FUJIWARA Teruyoshi <fujiwara@linux.or.jp>
.\" Corrected by
.\"       NOKUBI Takatsugu <knok@isoternet.org>
.\" Revised on Sun 21 Nov 2004 by Takeo Nakano <nakano@apm.seikei.ac.jp>
.\"
.\" vi:set wm=5
.TH SCREEN 1 "Aug 2003"
.if n .ds Q \&"
.if n .ds U \&"
.if t .ds Q ``
.if t .ds U ''
.UC 4
.SH 名前
screen \- VT100/ANSI 端末エミュレーション機能を持つ画面管理ソフトウェア
.SH 書式
.B screen
[
.B \-\fIoptions\fP
] [
.B \fIcmd\fP
[
.B \fIargs\fP
] ]
.br
.B screen \-r
[[\fIpid\fP\fB.\fP]\fItty\fP[\fB.\fP\fIhost\fP]]
.br
.B screen \-r
\fIsessionowner\fP\fB/\fP[[\fIpid\fP\fB.\fP]\fItty\fP[\fB.\fP\fIhost\fP]]
.ta .5i 1.8i
.SH 書式
.I screen
は、ひとつの物理的な端末を複数のプロセス (特に対話シェル)
で共有化できるようにする、フルスクリーンウィンドウ管理ソフトウェアである。
各仮想端末は DEC VT100 端末の機能に加え、ANSI X3.64 (ISO 6429)
や ISO 2022 規格に含まれる制御機能
(例えば行の挿入/削除や複数の文字集合のサポート) のいくつかを備えている。
各仮想端末にはスクロールバック用の履歴バッファがある。
またコピー&ペースト機能もあり、ウィンドウ間でテキスト領域をやりとりできる。
.PP
.I screen
は呼び出されるとウィンドウを 1 つ生成し、その中でシェル
(または指定されたコマンド) を実行する。そしてユーザからは見えなくなり、
ユーザは通常通りにプログラムを実行できるようになる。
その後はいつでも、
新しい (全画面) ウィンドウの生成およびそこでの他のプログラムの実行
(別のシェルも含む)、いまあるウィンドウの削除、
ウィンドウリストの表示、ログ出力の有効化・無効化、
ウィンドウ間でのテキストのコピー&ペースト、
スクロールバック履歴の閲覧、望む通りのウィンドウ切り替え、等ができる。
各々のウィンドウは、
それぞれ自分のプログラムを他からは完全に独立したかたちで動作させる。
ウィンドウが現在見えなくても、あるいは
.I screen
セッション全体がユーザの端末から切り離された場合でも、
各プログラムは動作を続ける。プログラムが終了すると、
.I screen
は (デフォルトでは) そのプログラムが動作していたウィンドウを削除する。
このウィンドウがフォアグラウンドにあった場合は、
ひとつ前のウィンドウに表示が切り替わる。
ウィンドウが残っていなかった場合には、
.I screen
は終了する。
.PP
ユーザのキー入力はすべて、現在のウィンドウで動作しているプログラムに送られる。
この唯一の例外は、ウィンドウマネージャへ送るコマンドの開始を意味する、
ある 1 つのキーストロークである。デフォルトでは、
各コマンドは Ctrl-a (以降は C-a と省略) で始まり、
その後には別のキーストロークが 1 つ続く。
コマンド文字とすべてのキー割り当ては完全に望みの通りにカスタマイズできる。
ただし長さは必ず 2 文字でなければならない。
.PP
.I screen
はプレフィクス \*QC-\*U をコントロールキーの意味だとは理解しない。
コマンドへの引数にはキャレット表記 (\*QC-a\*U の代わりに \*Q^A\*U)
を用いること (例えば
.I escape
コマンドや \fI-e\fP オプションへの引数など)。
.I screen
自身も制御文字の出力にはキャレット表記を用いる。
.PP
新しいウィンドウを生成する標準的な方法は、\*QC-a c\*U とタイプすることである。
これにより新しいウィンドウが生成されてシェルが実行され、
現在のウィンドウで動作中のプロセスの状態にかかわらず、
ただちにそのウィンドウへ切り替わる。
同様に、あらかじめコマンドをキー操作に割り当てておき
(割り当ては .screenrc またはコマンドラインから \*QC-a :\*U で行う)、
その後これを \*QC-a c\*U のように用いれば、
特定のコマンドが実行される新たなウィンドウを生成できる。
さらに、既存ウィンドウのプロンプトから
.IP
screen emacs prog.c
.PP
のようなコマンドを実行しても、新たなウィンドウを生成できる。
これは別の
.I screen
を起動するのではなく、コマンド名と引き数を
(環境変数 $STY で指定される) ウィンドウマネージャに渡し、
新しいウィンドウを生成させる。
上の例では (prog.c を編集する) emacs エディタが起動し、
そのウィンドウに切り替わる。
.PP
.I screen
が \*Q/etc/utmp\*U に書き込み可能な場合は、
各ウィンドウに関する適切な記録がこのファイルに書き込まれ、
そしてウィンドウの終了時に削除される。
これは \*Qtalk\*U, \*Qscript\*U, \*Qshutdown\*U, \*Qrsend\*U,
\*Qsccs\*U  等、utmp ファイルを見てユーザの居場所を調べるプログラムを
使う際に便利である。
.I screen
が端末上でアクティブであるうちは、
その端末自身のレコードは utmp ファイルから削除される。
\*QC-a L\*U も参照すること。
.SH はじめよう
他の termcap/terminfo プログラムの場合と同様、
.I screen
を使い始める前には、端末のタイプを正しく選んでいるかを確認すること
.RI ( tset
プログラム等で確認できる)。
.PP
大量の文書を読まずに使い始めたいせっかちな人も、
\*QC-a ?\*U コマンドだけは覚えておくように。この 2 文字を入力すると
.I screen
で使えるコマンドとキー割り当てのリストが表示される。
それぞれのキー操作については、
『デフォルトのキー割り当て』の節で説明する。
このマニュアルの『カスタマイズ』の節では、.screenrc の内容を扱う。
.PP
使っている端末が「本当の」自動マージン端末
(画面をスクロールさせないと画面の末尾のカラムを更新できない)
の場合、その端末の
termcap には自動マージンが「オフ」であるものを使う方が良い。
これにより、正確かつ最適な画面更新がどんな環境でも保証される。
今日のほとんどの端末は \*Qmagic\*U マージン
(自動マージンで、かつ最後のカラムも利用できる) を備えている。
これは VT100 の形式で、
.I screen
にも完璧に適している。「本当の」自動マージン端末しか使えない場合、
.I screen
はこれを受け入れて使用するが、画面の最後のカラムに置かれた文字は、
画面がスクロールするか、
その文字が何らかの方法で安全な位置に移動するまで更新できない。
文字挿入 (insert-character) の機能を持つ端末を使えば、
この遅れを短くすることができる。

.SH コマンドラインオプション
screen では以下のコマンドラインオプションが使用できる:
.TP 5
.B \-a
temcap の \fIall\fP 機能の実装に、
ディスプレイ各部の再描画が必要とされる場合であっても、
各ウィンドウの termcap に (一部の例外を除いて) \fIall\fP 機能を含める。
.TP 5
.B \-A
すべてのウィンドウの大きさを現在の端末の大きさに合わせる。デフォルトでは
.I screen
はサイズ変更が可能な端末 (記述に \*QWS\*U があるもの。
例としては suncmd や xterm の一部) へアタッチする際には、
古いウィンドウの大きさを復元しようとする。
.TP 5
.BI "\-c " file
設定ファイルをデフォルトの \*Q$HOME/.screenrc\*U ではなく
\fIfile\fP にする。
.TP 5
.BR \-d | \-D " [" \fIpid.tty.host ]
.I screen
を起動せず、他のところで動作している
.I screen
のセッションをデタッチする。これは、
.I screen
の制御端末で \*QC-a d\*U を入力したときの効果と同じである。
\fB\-D\fP は強制デタッチのキーと同じである。
デタッチできるセッションが無いときには、このオプションは無視される。
\fB\-r\fP/\fB\-R\fP オプションと組み合わせれば、
より強力な機能を実現できる。
.TP 8
.B \-d \-r
セッションを再アタッチする。必要ならばまずデタッチする。
.TP 8
.B \-d \-R
セッションを再アタッチする。必要ならばまずデタッチするか、
あるいはセッションを生成する。
.TP 8
.B \-d \-RR
セッションを再アタッチする。必要ならばまずデタッチするか、
あるいはセッションを生成する。
複数のセッションをアタッチ可能な場合は、最初のセッションを使う。
.TP 8
.B \-D \-r
セッションを再アタッチする。
必要ならばリモートのデタッチとログアウトを先に行う。
.TP 8
.B \-D \-R
アタッチを今ここで行う。具体的には、
セッションが走っている場合には再アタッチを行い、
必要ならばまずリモートのデタッチとログアウトを行う。
動作中のセッションがなければ生成してユーザに知らせる。
これは筆者の好みである。
.TP 8
.B \-D \-RR
アタッチを今ここで行う。詳細はともかく、とにかくこれを使えばよろしい。
.IP "" 5
参考: ときどき \*Qscreen \-list\*U を使って、
自分のセッションの状態をチェックすると良いだろう。
.TP 5
.BI "\-e " xy
コマンド文字を \fIx\fP にする。またリテラルなコマンド文字を生成する文字を
\fIy\fP にする (これをコマンド文字の後に入力する)。
デフォルトは \*QC-a\*U と `a' であり、
これらは \*Q-e^Aa\*U のように指定できる。
.I screen
セッションを生成するとき、
このオプションはデフォルトのコマンド文字を設定する。
マルチユーザセッションでは、追加されたすべてのユーザは、
最初はこのコマンド文字を使うことになる。
しかし、既に動作中のセッションにアタッチする時には、
このオプションはアタッチするユーザのコマンド文字しか変更しない。
.\"nakano ここの動作良くわからない…
このオプションはそれぞれ \*Qdefescape\*U および \*Qescape\*Uと
同じである。
.TP 5
.BR \-f\fP ", " \-fn ", " \-fa
フロー制御の有効、無効を切り替える。
また「自動切り替えモード (automatic switching mode)」を設定する。
これは .screenrc の \*Qdefflow\*U コマンドを使っても定義できる。
.TP 5
.BI "\-h " num
履歴のスクロールバッファの大きさを最大 \fInum\fP 行に設定する。
.TP 5
.B \-i
フロー制御が有効である時に、割り込みキー (通常は C-c)
によって即座にディスプレイに割り込みがかかるようにする。
詳しくは .screenrc のコマンドである \*Qdefflow\*U を参照のこと。
このオプションはあまり使わない方が良い。
.TP 5
.BR \-l " および " \-ln
(/etc/utmp の更新に関する) ログインモードを有効/無効にする。
これは .screenrc のコマンドの \*Qdeflogin\*U でも指定できる。
.TP 5
.BR \-ls " および " \-list
.I screen
を起動せず、ユーザの
.I screen
セッションに対応する
.I pid.tty.host
形式の文字列をリスト表示する。
`detached' と記されているセッションは \*Qscreen -r\*U で再開できる。
`attached' と記されているセッションは動作中であり、
これを制御している端末がある。
セッションがマルチユーザモードで動作している場合は、`multi' と記される。
`unreachable' と記されているセッションは、
別のホストで動作しているか `dead' の状態にある。
unreachable なセッションのうち、名前がローカルホストや
指定したパラメータがあればそれにマッチするものは、
dead であると思われる。
マッチの作りかたの説明は \fB-r\fP フラグの項目を見てほしい。
`dead' とされたセッションは、厳しくチェックしてから削除すべきである。
よくわからない場合はシステム管理者に相談すること。
セッションは \fB-wipe\fP オプションで削除する。
.TP 5
.B \-L
ウィンドウの自動出力ログを有効にするよう
.I screen
に伝える。
.TP 5
.B \-m
.I screen
に $STY 環境変数を無視させる。
\*Qscreen -m\*U とすると、この
.I screen
が他の
.I screen
セッションから呼び出されたかどうかに関わらず、
新たなセッションの生成が強制される。
このフラグは、`-d' オプションと組み合わせると特別な意味を持つ。
.TP 8
.B \-d \-m
.I screen
を \*Qdetached\*U モードで起動する。新たなセッションが生成されるが、
そのセッションへアタッチしない。
これはシステムのスタートアップスクリプトで便利である。
.TP 8
.B \-D \-m
これも screen を \*Qdetached\*U モードで起動するが、
新たなプロセスをフォークしない。
このコマンドは、セッションが終わったら終了する。
.TP 5
.B \-O
完全な VT100 エミュレーションではなく、
使っている端末に対してより最適な出力モードを選択する
(`LP' のない自動マージン端末にのみ影響する)。
これは .screenrc  の \*Qtermcap\*U コマンドに `OP'
を指定することによっても設定できる。
.TP 5
.BI "\-p " (番号または名前)
.\"nakano typo: windor, commant
あらかじめウィンドウを選択する。これは特定のウィンドウに
アタッチしなおしたいときや、\*Q-X\*U オプションを用いて
特定のウィンドウにコマンドを送りたいときに便利である。
スクリーン選択コマンドと同じく、\*Q-\*U を用いると
ブランクのウィンドウが選択される。再アタッチの場合においては、
\*Q=\*U によってブランクのウィンドウにウィンドウのリストが表示される。
.TP 5
.B \-q
エラーメッセージを表示しない。\*Q-ls\*U と同時に用いた場合の返り値は次の通り:
9 はセッションのないディレクトリ、
10 は動作中だがアタッチできないセッションのあるディレクトリ、
11 (またはそれ以上) は 1 (以上) の利用できるセッションのあるディレクトリ。
\*Q-r\*U と同時に用いた場合の返り値は次の通り:
10 はレジュームできるセッションがない、12 (またはそれ以上)
は 2 つ (以上) のレジューム可能なセッションがあり、
どちらかを選ばなければならない。
これ以外の場合には、\*Q-q\*U には何の効果もない。
.TP 5
.BR \-r " [" \fIpid.tty.host ]
.PD 0
.TP 5
.BR \-r " \fIsessionowner/[" \fIpid.tty.host ]
.PD
デタッチされている
.I screen
セッションをレジュームする。他のオプション
(\*Q-d\*U/\*Q-D\*U と同時に用いる場合を除く)
を指定することはできないが、複数の
.I screen
セッションがデタッチされている場合は、
それらを区別するために [\fIpid.\fP]\fItty.host\fP という余分な
プレフィックスが必要かもしれない。
二番目の形式は、マルチユーザモードで動作している他のユーザの
screen セッションに接続する場合に用いる。
この場合 screen は、他のユーザのディレクトリで
セッション探索ができなければならない。これには setuid-root が必要とされる。
.TP 5
.B \-R
デタッチされている
.I screen
セッションのうち最初に見つかったものを再開しようと試みる。
成功すれば他のコマンドラインオプションはすべて無視される。
デタッチされているセッションがひとつも無い場合には、
.B \-R
が指定されていなかったかのように、
他のオプションを使って新しいセッションを開始する。このオプションは、
.I screen
がログインシェルとして実行される場合にはデフォルトで設定される
(実際にはこの場合 screen は \*Q-xRR\*U を使う)。
\fB\-d\fP/\fB\-D\fP オプションとの組み合わせについては、
これらのオプションに関する説明の部分を参照すること。
.TP 5
.B \-s
デフォルトのシェルとして、環境変数 $SHELL の値
(これが定義されていなければ \*Q/bin/sh\*U) ではなく、
指定されたプログラムを設定する。
これは .screenrc コマンドの \*Qshell\*U を使っても定義できる。
.TP 5
.BI "\-S " セッション名
新しいセッションを作る際、
このオプションを使えばセッションに意味のある名前を付けることができる。
この名前を使うと、
\*Qscreen -list\*U や \*Qscreen -r\*U の使用時にセッションを識別できる。
これはデフォルトの [\fItty.host\fP] サフィックスに置き換わる。
.TP 5
.BI "\-t " 名前
デフォルトのシェルまたは指定プログラムに対してタイトル (別名)
を設定する。.screenrc コマンド \*Qshelltitle\*U も参照のこと。
.TP 5
.B \-U
UTF-8 モードで screen を動作させる。
このオプションは、ユーザの端末が UTF-8 エンコードされた
文字を理解し、また送信してくることを screen に伝える。
また新規ウィンドウのデフォルトエンコーディングが `utf8' になる。
.TP 5
.B \-v
バージョン番号を表示する。
.TP 5
.BR \-wipe " [" \fIマッチ ]
\*Qscreen -ls\*U とほぼ同じ動作であるが、
破棄されたセッションに `dead' と印を付けるのではなく、これを削除する。
到達できないセッションのうち、
ローカルホストの名前か、パラメータを与えた場合はそれにマッチしたものは、
dead とみなされる。
マッチの作り方については \fB-r\fP フラグの項を参照のこと。
.TP 5
.B \-x
デタッチされていない
.I screen
セッションへのアタッチを行う (マルチディスプレイモード)。
.TP 5
.B \-X
動作中の screen セッションに特定のコマンドを送る。
\fB-d\fP や \fB-r\fP オプションを用いれば、
アタッチされているセッションやデタッチされているセッション
のみを探すよう、screen に伝えることもできる。ただしこのコマンドは、
セッションがパスワードで保護されている場合には動作しないことに注意。

.SH デフォルトのキー割り当て
.ta 12n 26n
既に説明したように、
.I screen
の各コマンドは \*QC-a\*U の後に、もう 1 文字を続けたものである。
ユーザの利便のため、小文字に割り当てられたすべてのコマンドは、
それぞれ対応する制御文字にも割り当てられる
(ただし \*QC-a a\*U は例外である。これについては後述する)。
.\"nakano C-a C-v も例外っぽいが。
したがって、\*QC-a c\*U でも \*QC-a C-c\*U でもウィンドウを生成できる。
コマンドの説明については
『カスタマイズ』のセクションを参照すること。
.PP
.TP 26n
以下の表はデフォルトのキー割り当てである:
.IP "\fBC-a '\fP	(select)"
切り替え先のウィンドウ名またはウィンドウ番号を問い合わせる。
.IP "\fBC-a \(dq\fP	(windowlist -b)"
選択できるウィンドウのリストを表示する。
.IP "\fBC-a 0\fP	(select 0)"
.PD 0
.IP "\fB ... \fP	   ..."
.IP "\fBC-a 9\fP	(select 9)"
.IP "\fBC-a -\fP	(select -)"
.PD
番号 0 \- 9 のウィンドウ、またはブランクウィンドウへ切り替える。
.IP "\fBC-a tab\fP	(focus)"
.PD
入力フォーカスを次のリージョンに切り替える。
.IP "\fBC-a C-a\fP	(other)"
直前に表示していたウィンドウにトグルする。
この割り当ては、変更しない限り、
デフォルトではコマンド文字の 2 回の繰り返しである。
例えば、オプション \*Q\fB\-e]x\fP\*U を使うと、
このコマンドは \*Q]C-a\*U でなく \*Q]]\*Uとなる。
.IP "\fBC-a a\fP	(meta)"
コマンド文字(C-a)をウィンドウに送る。\fIescape\fP コマンドを参照のこと。
.IP "\fBC-a A\fP	(title)"
現在のウィンドウの名前をユーザに入力させる。
.IP "\fBC-a b\fP"
.PD 0
.IP "\fBC-a C-b\fP	(break)"
.PD
ブレーク信号をウィンドウに送る。
.IP "\fBC-a B\fP	(pow_break)"
端末ラインを再オープンし、ブレーク信号を送る。
.IP "\fBC-a c\fP"
.PD 0
.IP "\fBC-a C-c\fP	(screen)"
.PD
新しいウィンドウとシェルを生成し、そのウィンドウに切り替える。
.IP "\fBC-a C\fP	(clear)"
画面をクリアする。
.IP "\fBC-a d\fP"
.PD 0
.IP "\fBC-a C-d\fP	(detach)"
.PD
現在の端末から
.I screen
をデタッチする。
.IP "\fBC-a D\fP	(pow_detach)"
.\"nakano D 一個多い?
デタッチとログアウトを行う。
.IP "\fBC-a f\fP"
.PD 0
.IP "\fBC-a C-f\fP	(flow)"
.PD
フロー制御の \fIon\fP, \fIoff\fP, \fIauto\fP をトグルする。
.IP "\fBC-a F\fP	(fit)"
ウィンドウを現在のリージョの大きさにリサイズする。
.IP "\fBC-a C-g\fP	(vbell)"
.I screen
の可視ベルモードをトグルする。
.IP "\fBC-a h\fP	(hardcopy)"
現在のウィンドウのハードコピーをファイル \*Qhardcopy.\fIn\fP\*U
に書き込む。
.IP "\fBC-a H\fP	(log)"
現在のウィンドウのファイル \*Qscreenlog.\fIn\fP\*U
へのログ出力を開始/終了する。
.IP "\fBC-a i\fP"
.PD 0
.IP "\fBC-a C-i\fP	(info)"
.PD
現在のウィンドウに関する情報を表示する。
.IP "\fBC-a k\fP"
.PD 0
.IP "\fBC-a C-k\fP	(kill)"
.PD
現在のウィンドウを破棄する。
.IP "\fBC-a l\fP"
.PD 0
.IP "\fBC-a C-l\fP	(redisplay)"
.PD
現在のウィンドウ全体をリフレッシュする。
.IP "\fBC-a L\fP	(login)"
このウィンドウのログインスロットをトグルする。
これが可能なのは、
.I screen
が utmp データベースを更新するよう設定されている場合に限られる。
.IP "\fBC-a m\fP"
.PD 0
.IP "\fBC-a C-m\fP	(lastmsg)"
.PD
メッセージ行に表示された直前のメッセージを繰り返す。
.IP "\fBC-a M\fP	(monitor)"
現在のウィンドウの監視をトグルする。
.IP "\fBC-a space\fP"
.PD 0
.IP "\fBC-a n\fP"
.IP "\fBC-a C-n\fP	(next)"
.PD
次のウィンドウに切り替える。
.IP "\fBC-a N\fP	(number)"
現在のウィンドウの番号(とタイトル)を表示する。
.IP "\fBC-a backspace\fP"
.PD 0
.IP "\fBC-a h\fP"
.IP "\fBC-a p\fP"
.IP "\fBC-a C-p\fP	(prev)"
.PD
前のウィンドウに切り替える (\fBC-a n\fP の反対)。
.IP "\fBC-a q\fP"
.PD 0
.IP "\fBC-a C-q\fP	(xon)"
.PD
現在のウィンドウに Control-q を送る。
.IP "\fBC-a Q\fP	(only)"
現在のリージョンを残して他はすべて消す。
.IP "\fBC-a r\fP"
.PD 0
.IP "\fBC-a C-r\fP	(wrap)"
.PD
現在のウィンドウの行折り返しに関する設定をトグルする
(現在のウィンドウの自動マージンのオン/オフを切り替える)。
.IP "\fBC-a s\fP"
.PD 0
.IP "\fBC-a C-s\fP	(xoff)"
.PD
現在のウィンドウに Control-s を送る。
.IP "\fBC-a S\fP	(split)"
現在のリージョンを 2 つに分ける。
.IP "\fBC-a t\fP"
.PD 0
.IP "\fBC-a C-t\fP	(time)"
.PD
システム情報を表示する。
.IP "\fBC-a v\fP	(version)"
.PD
バージョンとコンパイルされた日時を表示する。
.IP "\fBC-a C-v\fP	(digraph)"
.PD
二重字 (digraph) を入力する。
(訳注: 二重字とはアクセント記号等が付いた文字のこと)
.IP "\fBC-a w\fP"
.PD 0
.IP "\fBC-a C-w\fP	(windows)"
.PD
ウィンドウのリストを表示する。
.IP "\fBC-a W\fP	(width)"
80/132 カラムをトグルする。
.IP "\fBC-a x\fP"
.PD 0
.IP "\fBC-a C-x\fP	(lockscreen)"
.PD
この端末をロックする。
.IP "\fBC-a X\fP 	(remove)"
現在のリージョンを破棄する。
.IP "\fBC-a z\fP"
.PD 0
.IP "\fBC-a C-z\fP	(suspend)"
.PD
.I screen
をサスペンドする。
システムが BSD 形式のジョブ制御をサポートしていなければならない。
.IP "\fBC-a Z\fP	(reset)"
仮想端末を \*Qpower-on\*U の値にリセットする。
.IP "\fBC-a .\fP	(dumptermcap)"
\*Q.termcap\*U ファイルを出力する。
.IP "\fBC-a ?\fP	(help)"
キー割り当てを表示する。
.IP "\fBC-a C-\e\fP	(quit)"
すべてのウィンドウを破棄し、
.I screen
を終了する。
.IP "\fBC-a :\fP	(colon)"
コマンドラインモードに入る。
.IP "\fBC-a [\fP"
.PD 0
.IP "\fBC-a C-[\fP"
.IP "\fBC-a esc\fP	(copy)"
.PD
コピー/スクロールバックモードに入る。
.IP "\fBC-a ]\fP	(paste .)"
.PD
ペーストバッファの内容を現在のウィンドウの標準入力のキューに書き込む。
.IP "\fBC-a {\fP"
.PD 0
.IP "\fBC-a }\fP	(history)"
.PD
前の (コマンド) 行をコピー&ペーストする。
.IP "\fBC-a >\fP	(writebuf)"
ペーストバッファをファイルに書き出す。
.IP "\fBC-a <\fP	(readbuf)"
画面交換ファイルをペーストバッファに読み込む。
.IP "\fBC-a =\fP	(removebuf)"
\fBC-a <\fP と \fPC-a >\fP で使ったファイルを削除する。
.IP "\fBC-a ,\fP	(license)"
.I screen
の由来を表示する。これは
.I screen
が来た道であり、あなたが
.I screen
を利用できている理由である。
.IP "\fBC-a _\fP	(silence)"
現在のウィンドウが非アクティブかどうかの監視を開始/停止する。
.IP "\fBC-a *\fP	(displays)"
現在アタッチしているすべての画面のリストを表示する。

.SH カスタマイズ
「ソケットディレクトリ」は、デフォルトでは $HOME/.screen
または単に /tmp/screens だが、
コンパイル時に選択すれば /var/run/screen にもできる。
.I screen
を setuid-root でインストールする場合、
システム管理者は適切な (NFS マウントではない)
ソケットディレクトリを使うよう
.I screen
をコンパイルしなければならない。
.I screen
が setuid-root でない状態で動作する場合なら、
ユーザは環境変数 $SCREENDIR を使って、
モード 700 の任意のディレクトリを指定できる。
.PP
.I screen
は起動されると、2 つのファイル (\*Q/etc/screenrc\*U
とそのユーザのホームディレクトリの \*Q.screenrc\*U)
から初期化コマンドを読み込んで実行する。
これらは「プログラマのデフォルト値」であり、
以下のようにすれば変更できる:
システム全体の screenrc として、
.I screen
は環境変数 $SYSSCREENRC を検索する
(この変更機能はコンパイル時に無効にできる)。
ユーザ固有の screenrc ファイルは
$SCREENRC, $HOME/.screenrc の順で検索される。
コマンドラインオプション \fB-c\fP は、
これらのユーザ用 screenrc ファイルよりも優先される。
.PP
これらのファイルに書かれたコマンドは、オプションの設定や
キーへの機能の割り当て、
.I screen
セッション開始時の自動的なウィンドウ生成 (複数可) に用いられる。
コマンドは 1 行に 1 つ書かれ、空の行は無視される。コマンドの引き数は
タブまたは空白で区切られ、
シングルクォートまたはダブルクォートで括ることができる。
`#' があると、その行の残りの部分はコメントとなる。
ただし `#' がクォートの内部にある場合は除く。
判読できない行には警告が出され、無視される。
コマンドでは環境変数を参照できる。
記法はシェルと同様に "$VAR " または "${VAR}" の形式である。
これは
.I screen
の古いバージョンとの非互換性の原因になっており、
現在は変数代入を行わせない場合 '$' は '\e'
で保護しなければならない。
.PP
screen の配布パッケージには、 2 つの設定ファイル、
\*Qetc/screenrc\*U と \*Qetc/etcscreenrc\*U
とが例として同梱されている。
これらには様々なコマンドの便利な例がたくさん載っている。
.PP
カスタマイズは「オンライン」で行うこともできる。
コマンドモードに入るには `C-a :' を入力する。
\*Qdef\*U で始まるコマンドはデフォルト値を変更し、
他のコマンドは現在の設定を変更する。
.PP
利用できるコマンドを以降に示す:
.sp 
.ne 3
.BI acladd " usernames"
.RI [ crypted-pw ]
.br
.BI addacl " usernames"
.PP
ユーザに現在の screen セッションへの完全なアクセスを与える。
\fIusernames\fP は 1 人のユーザ、またはコンマ区切りのユーザリストである。
このコマンドは
.I screen
セッションにアタッチできるようにし、
`aclchg \fIusernames\fP +rwx \&"#?\&"' と同じ内容を実行する。
アクセス権を制限した状態でユーザを追加するには、後述の `aclchg' を用いること。
2 番目のパラメータは省略可能だが、これを与えると、
これは指定したユーザ (ないし複数のユーザ) の暗号化パスワードになる。
`addacl' は `acladd' と同機能の別名である。
このコマンドはマルチユーザモードでのみ使用できる。
.sp 
.ne 3
.BI aclchg " usernames permbits list"
.br
.BI chacl " usernames permbits list"
.PP
コンマ区切りのリストで指定したユーザの権限 (permission) を変更する。
permbits は `r', `w', `x' で表し、`+' を前に置くと権限が与えられ、
`-' を置くと権限が取り上げられる。
3 番目のパラメータは、コマンドやウィンドウ (番号またはタイトルで指定)
をコンマで区切って並べたリストである。
特別なリストである `#' はウィンドウすべてを意味し、`?' はコマンドすべてを意味する。
\fIusernames\fP が `*' 1 つだけの場合、
認識されているユーザすべてが影響を受ける。
ユーザがあるコマンドに対する `x' ビットを持っていると、
そのコマンドを実行できる。
あるウィンドウに対して `w' ビットが設定されており、
他のユーザがそのウィンドウの書き込みロックを取得していないとき、
ユーザはそのウィンドウへの入力を行える。
他のビットは現在は無視される。
ウィンドウ 2 にいる他のユーザの書き込みロックを取り消すには、
`aclchg \fIusername\fP -w+w 2' コマンドを実行する。
セッションに対する読み込み専用のアクセスを許可するには、
`aclchg \fIusername\fP -w \&"#\&"' コマンドを実行する。
ユーザ名が
.I screen
に識別されると、直ちにそのユーザはセッションにアタッチでき、
(デフォルトでは) すべてのコマンドとウィンドウに対する完全な権限を与えられる。
acl コマンドや `at' 等に対する実行許可は削除しておくべきである。
さもないと、そのユーザは書き込み権限を再取得できてしまう。
特殊なユーザ
.B nobody
に対する権限は変更できない (\*Qsu\*U コマンドを見よ)。
`chacl' は `aclchg' と同義の別名である。
マルチユーザモードでのみ使用できる。
.sp
.ne 3
.BI acldel " username"
.PP
ユーザを
.I screen
のアクセス制御リストから削除する。
現在アタッチされていれば、そのユーザのすべてのディスプレイは
そのセッションからデタッチされる。
そのユーザは再びアタッチすることはできない。
マルチユーザモードでのみ使用できる。
.sp
.ne 3
.BI aclgrp " username"
.RI [ groupname ]
.PP
同じアクセス権限を共有するユーザのグループを作成する。
このグループの名前は、グループのリーダーのユーザ名になる。
グループの各メンバーはグループリーダーに与えられた権限を継承する。
すなわち、あるユーザがあるアクセスのチェックに失敗すると、
続いて別のチェックがグループリーダーに対してなされる。
.I groupname
に特殊な値 \*Qnone\*U が用いられると、ユーザはすべてのグループから削除される。
2 番目のパラメータが省略されると、ユーザのいるすべてのグループがリストされる。
.sp
.ne 3
.B aclumask
.RI [[ users ] +bits 
.RI |[ users ] -bits " .... ]"
.br
.B umask
.RI [[ users ] +bits 
.RI |[ users ] -bits " .... ]"
.PP
このコマンドを呼んだ者が生成するウィンドウに対して、
他のユーザが持つアクセス権限を指定する。
.I users 
は、なし、一人、既知のユーザ名のコンマ区切りリスト、のいずれかである。
.I users
を指定しないと、現在わかっているすべてのユーザのリストを指定したことになる。
.I bits
は \*Qaclchg\*U コマンドで定義された
アクセス制御ビットの任意の組み合わせである。
ユーザ名 \*Q?\*U は特殊な意味を持ち、
まだ登場していないユーザに対して、
事前に任意のウィンドウに対するアクセス権限を付与するために用いる。
ユーザ名 \*Q??\*U は特殊な意味を持ち、
まだ登場していないユーザに対して、
任意のコマンドに対するアクセス権限を付与するために用いる。
特殊なユーザ名である
.B nobody
の権限を変更することはできない (\*Qsu\*U コマンドを見よ)。
`umask' は `aclumask' と同義の別名である。
.sp
.ne 3
.BI activity " message"
.PP
監視状態にあるバックグラウンドウィンドウのどれかで
何らかの動作があった場合、
.I screen
はメッセージ行で通知を行う。
この通知メッセージは \*Qactivity\*U コマンドで再定義できる。
\fImessage\fP に含まれる `%' は、
それぞれ動作が起こったウィンドウの番号に置換され、`~' は、
それぞれ termcap に書かれているベルの定義
(通常は音を鳴らすベル文字) に置換される。
デフォルトのメッセージは
.sp
	'Activity in window %n'
.sp
である。
デフォルトではすべてのウィンドウに対して監視はオフになっているが、
\*Qmonitor\*U コマンド(C-a M) で変更できる。
.sp
.ne 3
.BR "allpartial on" | off
.PP
on にすると、ウィンドウが変化した時に現在のカーソル行だけがリフレッシュされる。
これはすべてのウィンドウに影響し、端末ラインが遅い場合に役に立つ。
各ウィンドウにおける全体/部分リフレッシュの直前の設定は、
\*Qallpartial off\*U で復元される。
これはグローバルなフラグであり、
即座にすべてのウィンドウに影響を及ぼし、\*Qpartial\*U の設定を変更する。
これ以降に新しく生成されるウィンドウのデフォルトの再描画の動作は、
これによっては変わらない。
.sp
.ne 3
.BR "altscreen on" | off
.PP
on にすると仮想端末で「別画面 (alternate screen)」のサポートが有効になる。
これは xterm のと同様のものである。初期設定では off になっている。
.sp
.ne 3
.BR "at " "[\fIidentifier\fP][" "#\fP|\fP*\fP|\fP%\fP] "
.IR "command " [ args " ... ]"
.PP
.\"nakano double.
他の画面やウィンドウで (あたかもそこで入力したかのように) コマンドを実行する。
\*Qat\*U はコマンドのコンテクスト
(「現在のウィンドウ」や「現在の画面」の設定) を変更する。
最初のパラメータでコンテクストがひとつに定まらない場合には、
そのコマンドは複数回実行される。最初のパラメータが
`\fIidentifier\fP*' の形式ならば、
ユーザ名に対して identifier のマッチを試みる。
指定されたコマンドは、選択されたユーザ (複数可) の画面それぞれにおいて
1 度ずつ実行される。最初のパラメータが `\fIidentifier\fP%' の形式ならば、
画面に対して identifier のマッチを試みる。
画面の名前はアタッチしている tty に基づいて付けられる。
プレフィックス `/dev/' や `/dev/tty' は identifier から省略できる。
\fIidentifier\fP に `#' が付いた (あるいは末尾に何も付いていない) 場合は、
ウィンドウ番号とタイトルにマッチする。`*', `%', `#'
文字の前に置く識別子を省略すると、
すべてのユーザ、画面、ウィンドウが選択される。
.\"nakano order が捩れている？
.\"nakano prefix-match ってなんだ？
.\"nakano なぜならばプレフィックスのマッチが行われるからである。
影響を受ける画面 (複数のこともある) では、
起こったことが短いメッセージで表示される。
\*Qat\*U コマンドの実行者に対しては権限のチェックが行なわれ、
影響される画面の所有者に対しては行なわれない。'#' 文字の後に空白文字が
置かれるとコメントの開始になるが、これは '\e' を前置することでエスケープできる。
.br
注意:
ウィンドウに対するマッチでは、コマンドは各ウィンドウで最低 1 回は実行される。
ウィンドウの内部順序を変更するようなコマンド (\*Qother\*U など) は、
複数回呼び出されるかもしれない。
共有ウィンドウでは、コマンドはアタッチしている画面ごとに繰り返される。
\*Qlogin\*U のような、状態をトグルするコマンドを実行するときには注意すること!
コマンドによっては、対象ウィンドウがディスプレイに関連づけられていないと
機能しないものがある (\*Qprocess\*U など)。
これらのコマンドは、\*Qat\*U でウィンドウを巡回させる場合には
機能しないかもしれない。
.sp
.ne 3
.BI "attrcolor " attrib
.RI [ "attribute/color-modifier" ]
.PP
このコマンドを用いると、テキストの色を変えて属性をハイライトできる。
属性
.I attrib
がすでに利用中の場合には、指定した属性/色修正が同時に適用される。
.\"nakano 実際の動作を確認のこと。
修正指定を与えないと、現在のものを削除する。
修正指定の文法については『文字エスケープ』を参照のこと。
screen は 2 つの疑似属性を理解する:
\*Qi\*U は高輝度の前景色を意味し、
\*QI\*U は高輝度の背景色を意味する。
.sp
例:
.IP
attrcolor b "R"
.PP
ボールドのテキストを表示するとき、色を明るい赤に変更する。
.IP
attrcolor u "-u b"
.PP
アンダーラインの代わりに青のテキストを用いる。
.IP
attrcolor b ".I"
.PP
ボールドのテキストに明るい色を使う。ほとんどの端末エミュレータでは、
すでにこの指定はなされているだろう。
.IP
attrcolor i "+b"
.PP
高輝度色のテキストをボールドにもする。
.sp
.ne 3
.BR "autodetach on" | off
.PP
ハングアップの際に、自動的にデタッチを
.I screen
にさせるかどうかを設定する。デタッチを行うと、
実行中のプログラムはすべて保存され、
.B "screen -r"
コマンドで再開できる。このオプションを off にすると、
ハングアップシグナルによって
.I screen
および
.I screen
内で実行されているすべてのプロセスが終了する。
autodetach はデフォルトでは on になっている。
.sp
.ne 3
.BR "autonuke on" | off
.PP
画面クリアのシーケンスが与えられたとき、
まだ端末に書き出されていない出力すべてを破棄するかどうか指定する。
\*Qobuflimit\*U も参照のこと。
.sp
.ne 3
.BI "backtick " id
.I lifespan
.I autorefresh
.I cmd
.I args...
.br
.BI "backtick " id
.PP
(数値の) ID が \fIid\fP となる backtick コマンドをプログラムする。
このようなコマンドの出力は、文字列エスケープ \*Q%`\*U に代入される。
指定された \fIlifespan\fP は、出力が有効とみなされる期間の秒数である。
この秒数が経過した後に、対応する文字列エスケープが現われた場合には、
このコマンドが再び実行される。
\fIautorefresh\fP パラメータで指定する秒数が過ぎると、
キャプション文字列とハードステータス文字列とが自動的にリフレッシュされる。
出力の最後の行だけが代入に用いられる。
.br
\fIlifespan\fP と \fIautorefresh\fP の両方のパラメータが 0 だと、
その backtick プログラムはバックグラウンドに留まり、
ときどき出力を生成するものとみなされる。
この場合、そのコマンドは直ちに実行され、
screen はその出力の最後の行を保存する。新しい行が表示されると、
screen はハードステータスまたはキャプションをリフレッシュする。
.br
2 番目の書式は、数値 ID が \fIid\fP の backtick コマンドを削除する。
.sp
.ne 3
.BR "bce " [ on | off ]
.PP
背景色消去 (background-color-erase) の設定を変更する。
\*Qbce\*U を on にすると、
erase/insert/scroll/clear 操作でクリアされるすべての文字は、
現在の背景色で表示されることになる。
off にするとデフォルトの背景色が用いられる。
.\"nakano 後者の意味が不明…
.sp
.ne 3
.B bell_msg
.RI [ message ]
.PP
ベル文字がバックグラウンドのウィンドウに送られると、
.I screen
はメッセージ行に通知を出す。この通知メッセージは、
このコマンドによって再定義できる。\fImessage\fP に `%' があると、
それらはベルを受け取ったウィンドウの番号に置換される。
また `^G' は termcap で定義されているベル文字
(通常は音声ベル) に置換される。デフォルトのメッセージは次の通り：
.sp
	'Bell in window %n'
.sp
\*Qbell_msg\*U コマンドには空のメッセージを与えることもでき、
その場合メッセージ行の出力はされなくなる (bell_msg "")。
パラメータを与えないと、現在のメッセージが表示される。
.sp
.ne 3
.BI "bind "
.RB [ -c
.IR class ]
.I key 
.RI [ command " [" args ]]
.PP
コマンドをキーに割り当てる。
デフォルトでは、
.I screen
に用意されているほとんどのコマンドは
1 つないし複数のキーに割り当てられており、これらは
『デフォルトのキー割り当て』のセクションに示されている。
例えば新しいウィンドウを生成するコマンドは \*QC-c\*U と
\*Qc\*U とに割り当てられている。
\*Qbind\*U コマンドを用いると、キー割り当てを再定義したり、
新しい割り当てを定義したりできる。
引き数 \fIkey\fP には、文字 1 つ、\*Q^x\*U 形式(\*QC-x\*U の意味)の 2 文字
からなるシーケンス、バックスラッシュの後に 8 進数を続けたもの (文字の 
ASCII コードを示す)、バックスラッシュの後に 2 番目の文字を続けたもの
(\*Q\e^\*U や \*Q\e\e\*U 等) のいずれかを与える。
引き数はクォートしてもよい。
\fIkey\fP 以外の引き数が与えられなかった場合は、
以前にこのキーに対して与えられた割り当てが削除される。
\fIcommand\fP 引き数には、このセクションにリストされている
任意のコマンドを指定できる。
.PP
\*Q-c\*U オプションによってコマンドクラスが指定された場合には、
そのキーは指定されたクラスに割り当てられる。
クラスを有効にするには \*Qcommand\*U コマンドを用いる。
コマンドクラスは、コマンドキーを複数使いたいときや、
二文字以上のシーケンスを割り当てたい場合に利用できる。
.PP
指定例をいくつか示す:
.PP
.nf
	bind ' ' windows
	bind ^k
	bind k
	bind K kill
	bind ^f screen telnet foobar
	bind \e033 screen -ln -t root -h 1000 9 su
.fi
.PP
これは、まずウィンドウのリスト表示のコマンドをスペースキーに割り当てる
(通常は \*QC-a C-w\*U で呼び出されるコマンドが
\*QC-a スペース\*U でも呼び出せるようになる)。
続く 3 行では、デフォルトで kill が割り当てられている
\*QC-a C-k\*U と \*QC-a k\*U の両方を無効にし、
そして \*QC-a K\*U を kill コマンドに割り当てている。
次の行は、「ウィンドウを生成してホスト foobar への TELNET 接続を行う」
コマンドを \*QC-f\*U に割り当てている。
最後の行は、別名 \*Qroot\*U を持ち、
番号が 9 で、スーパーユーザのシェルを持ち、
スクロールバック用のバッファのサイズが 1000 行であるような、
非ログインウィンドウを生成するコマンドを
エスケープキーに割り当てる。
.PP
.nf
	bind -c demo1 0 select 10
	bind -c demo1 1 select 11
	bind -c demo1 2 select 12
	bindkey "^B" command -c demo1
.fi
.PP
\*QC-b 0\*U をウィンドウ 10 の選択、\*QC-b 1\*U をウィンドウ 11 の選択、
のようにする。
.PP
.nf
	bind -c demo2 0 select 10
	bind -c demo2 1 select 11
	bind -c demo2 2 select 12
	bind - command -c demo2
.fi
.PP
\*QC-a - 0\*U をウィンドウ 10 の選択、\*QC-a - 1\*U をウィンドウ 11 の選択、
のようにする。
.sp
.ne 3
.B bindkey
.RB [ -d ]
.RB [ -m ]
.RB [ -a ]
.RB [[ -k | -t ]
.I string
.RI [ "cmd args" ]]
.PP
このコマンドは screen の入力変換テーブルを管理する。
テーブルのどれか 1 つに含まれる各エントリは、
特定の文字シーケンスに出会ったときに行うべき応答を screen に指示する。
このようなテーブルは 3 つ存在する。
ユーザがプログラムした動作を含むテーブル、
端末エミュレーションで使われるデフォルトの動作を含むテーブル、
screen のコピーモードでカーソル移動を行うためのテーブル、
である。デフォルトのキー割り当てのリストは、
『入力の変換』のセクションを参照すること。
.PP
.B -d
オプションを与えると bindkey はデフォルトのテーブルを変更し、
.B -m
オプションはコピーモードのテーブルを変更し、
どちらのオプションも与えないとユーザテーブルが選択される。
引き数
.I string
は動作を割り当てる文字シーケンスである。これは固定の文字列でもよいし、
termcap のキーボード機能名でもよい
.RB ( -k
オプションで選択できる)。
.PP
VT100 端末でアプリケーションモードが有効であるとき、
一部のキーは異なる文字列を送ってくることがある (例えばカーソルキー)。
このようなキーは変換テーブル中にエントリを 2 つ持つ。
アプリケーションモード時のエントリは
.B -a
オプションの指定によって選択できる。
.PP
.B -t
オプションを指定すると、screen は文字間タイミング調整を行わない。
termcap の機能を使う場合には、タイミング調整を無効にはできない。
.PP
.I cmd
には任意の screen のコマンドと、これに対する任意の数の引き数
.I args
を指定できる。
.I cmd
が省略された場合は、そのキー割り当てがテーブルから削除される。
.PP
以下にキーボード割り当ての例をいくつか示す:
.sp
.nf
        bindkey -d
.fi
.sp
デフォルトのキー割当をすべて表示する。
アプリケーションモードのエントリには [A] が付く。
.sp
.nf
        bindkey -k k1 select 1
.fi
.sp
"F1" キーでウィンドウ 1 に切り替わるようにする。
.sp
.nf
        bindkey -t foo stuff barfoo
.fi
.sp
"foo" を単語 "barfoo" の省略形とする。
タイムアウトを無効にしてあるので、ユーザがゆっくり入力できる。
.sp
.nf
        bindkey "\e024" mapdefault
.fi
.sp
このキー割り当ては、\*Q^T\*U をキー割り当て用のエスケープ文字にする。
先程挙げた \*Qstuff barfoo\*U  の設定がされている場合、
\*Q^Tfoo\*U とタイプすれば単語 \*Qfoo\*U が入力できる。
\*Q^T\*U を挿入したい場合には、このキーを 2 回押す必要がある
(つまりエスケープの割り当てをエスケープする)。
.sp
.nf
        bindkey -k F1 command
.fi
.sp
F11 (F1 ではない!) キーにも screen のエスケープ機能
(^A と同じもの) を与える。
.sp
.ne 3
.B break
.RI [ duration ]
.PP
このウィンドウにブレーク信号を \fIduration\fP*0.25 秒間送る。
非 Posix システムでは送信時間は 1 秒単位に丸められる。
シェルプロセスの場合よりは、
キャラクタ型デバイスがウィンドウにアタッチされている場合に非常に役に立つ
(『ウィンドウの種類』の章も参照のこと)。ブレーク信号の最大継続時間は
15 秒に制限されている。
.sp
.ne 3
.B blanker
.PP
画面のブランク機能を有効にする。まず最初に画面はクリアされる。
ブランク用のプログラムが定義されていない場合は、カーソルも消える。
定義されている場合はそのプログラムが起動され、出力が画面に書き出される。
画面ブランク機能は、何かのキーが押された段階で終了し、
そのとき読み込んだキー入力は捨てられる。
.br
このコマンドは通常 \*Qidle\*U コマンドと共に用いられる。
.sp
.ne 3
.B blankerprg
.RI [ "program args" ]
.PP
ブランク機能用のプログラムを定義する。
引き数を与えないと、ブランク用のプログラムを無効にする。
.sp
.ne 3
.B breaktype
.RI [ tcsendbreak | TIOCSBRK
.RI | TCSBRK ]
.PP
端末デバイスに対してブレーク信号を生成する方法を、可能なものの中から選ぶ。
このコマンドは現在のウィンドウにのみ影響するべきだが、
現在は \*Qdefbreaktype\*U と同じように振舞う。
これは将来は変更される予定である。
\*Qbreaktype\*U をパラメータ無しで呼ぶと、現在のウィンドウにおける
ブレーク信号の発生方法を表示する。
.sp
.ne 3
.B bufferfile
.RI [ exchange-file ]
.PP
ペーストバッファを使った読み書きに使うファイル名を変更する。
\*Qbufferfile\*U コマンドへの引き数を省略した場合には、
デフォルトの設定 (\*Q/tmp/screen-exchange\*U) が再び使われるようになる。
以下の例は、システムのパスワードファイルを
.I screen
のウィンドウにペーストするものである
(ペーストバッファを使う。ここにはコピーが残る):
.PP
.nf
	C-a : bufferfile /etc/passwd
	C-a < C-a ]
	C-a : bufferfile
.fi
.sp
.ne 3
.BR "c1 " [ on | off ]
.PP
c1 コードの処理を変更する。\*Qc1 on\*U を指定すると、
screen は 128 から 159 までの入力文字を制御機能として扱う。
このような 8 ビットコードは、通常は ESC の後に対応する
7 ビットコードを続けたものと同じ意味になる。
デフォルトの設定では c1 コードを処理する。これは \*Qdefc1\*U
コマンドで変更できる。
c1 領域に利用可能な文字があるフォントを使っているユーザは、
このオプションを off にするとよい。
.sp
.ne 3
.BR "caption always" | splitonly
.RI [ string ]
.br
.B "caption string"
.RI [ string ]
.PP
このコマンドはウィンドウのキャプションの表示を制御する。
.\"nakano caption にはなにか訳語を当てる？
通常キャプションはディスプレイに複数のウィンドウが現れたときにのみ
用いられるが、ここの属性を
.B always
に設定すると、ひとつしかウィンドウがないときでも
screen はキャプションを表示する。デフォルトの設定は
.B splitonly
である。
.P
二番目の形式はキャプションに用いられるテキストを変更する。
\*Q文字エスケープ\*U の章にあるすべてのエスケープが利用できる。
screen がデフォルトで用いるのは `%3n %t' である。
.P
文字列を追加引数として、両方の形式を混ぜることもできる。
.sp
.ne 3
.BI "charset " set
.PP
文字セットのスロット指定と文字セットのマッピングを変更する。
.\"nakano "slot" には良い訳がないかなあ。
.I set
の先頭 4 文字は、文字セット指定として扱われる。
5-6 番目の文字は 0 から 3 までの値を取り、GL/GR 文字セットの
マッピングを指定する。すべての位置には '.' を置くことができ、
その場合は現在の文字セット/マッピングを変更しない
(\fIset\fP が 6 文字に満たない場合は、内部で '.' を追加する)。
新しいウィンドウのデフォルトの文字セットは、
\*Qencoding\*U コマンドが有効になっていなければ "BBBB02" になる。
.P
現在の設定は \*Qinfo\*U コマンドで閲覧できる。
.sp
.ne 3
.B chdir
.RI [ directory ]
.PP
.I screen
のカレントディレクトリを指定されたディレクトリに変更する。
引き数なしで呼ばれた場合には、カレントディレクトリをホームディレクトリ
(環境変数 $HOME の値) にする。
\*Q.screenrc\*U 内部の \*Qscreen\*U コマンド、
\*QC-a : screen ...\*U、
\*QC-a c\*U のいずれかによって新しく生成されるウィンドウは、
これをデフォルトのディレクトリとして使用する。
chdir コマンドを使わないと、デフォルトのディレクトリは
.I screen
が起動されたディレクトリになる。
ハードコピーとログファイルが書き出されるのは、
常に「そのウィンドウの」デフォルトディレクトリであり、
ウィンドウ内で動作しているプロセスのカレントディレクトリではない。
このコマンドを .screenrc 内で複数回用いれば、
別々のデフォルトディレクトリでウィンドウをいくつも起動することができるが、
ユーザが対話的に生成したすべてのウィンドウは、最後の chdir の値の影響を受ける。
.sp
.ne 3
.B clear
.PP
現在のウィンドウをクリアし、そのイメージをスクロールバックバッファに格納する。
.sp
.ne 3
.B colon
.RI [ prefix ]
.PP
\*Q.screenrc\*U のコマンドラインを入力できるようにする。
screen の動作中にキー割り当てを変えたり、
特定のウィンドウの生成・設定の変更などに便利である。
なお \*Qset\*U キーワードは無くなってしまった。
コマンドは通常現在のウィンドウに影響し、将来生成されるウィンドウの
デフォルト設定にはならない。
デフォルトを変更するには 'def...' で始まるコマンド群を用いること。
.PP
これを
.I screen 
の「Ex コマンドモード」とするなら、
\*QC-a esc\*U (コピーモード) は
「Vi コマンドモード」と言えるだろう。
.sp 
.ne 3
.B command
.RB [ -c
.IR class ]
.PP
このコマンドは screen のエスケープ文字
(^A) を打ち込んだ場合と同じ動作を行う。
これが役に立つのはキー割り当ての場合だけだろう。
\*Q-c\*U オプションが与えられると、指定したコマンドクラスを選択する。
\*Qbind\*U と \*Qbindkey\*U も参照すること。
.sp 
.ne 3
.BR "compacthist " [ on | off ]
.PP
テキストをヒストリバッファの領域へスクロールアップするときに、
末尾の空行の出力を抑制するかどうか指定する。
.sp 
.ne 3
.BR "console " [ on | off ]
.PP
マシンコンソールのウィンドウへの出力をグラブまたはアングラブする。
.IR 注意 :
コンソール出力をグラブできるのは /dev/console の所有者だけである。
このコマンドは、ioctl TIOCCONS をサポートしているマシンでしか使えない。
.sp
.ne 3
.B copy
.PP
コピー/スクロールバックモードに入る。
ここでは、現在のウィンドウおよびその履歴から、
テキストをペーストバッファへとコピーできる。
このモードでは、vi に似た「フルスクリーンエディタ」がアクティブになる:
.sp
.IR 移動キー :
.br
.in +4n
.ti -2n
\fBh\fP, \fBj\fP, \fBk\fP, \fBl\fP は、
カーソルを上下左右に移動する。
.br
.ti -2n
\fB0\fP, \fB^\fP, \fB$\fP は、行の内部で、
先頭・空白でない最初の文字・空白でない最後の文字、
へとカーソルを移動する。
.br
.ti -2n
\fBH\fP, \fBM\fP, \fBL\fP は、カーソルをウィンドウの最上行・中央・
最下行の、それぞれ先頭に移動する。
.br
.ti -2n
\fB+\fP および \fB\-\fP は、位置を 1 行上・1 行下へ移動する。
.br
.ti -2n
\fBG\fP は指定された絶対行へ移動する (デフォルト値はバッファの末尾)。
.br 
.ti -2n
\fB|\fP は指定された絶対桁へ移動する。
.br
.ti -2n
\fBw\fP, \fBb\fP, \fBe\fP は、カーソルを単語単位で移動させる。
.br 
.ti -2n
\fBB\fP と \fBE\fP は、カーソルを「単語」単位で移動させる (vi と同様)。
.br 
.ti -2n
\fBC-u\fP と \fBC-d\fP は、指定された行数だけ画面を上下にスクロールさせる。
この際にカーソル位置は変わらない (デフォルト値は全画面の半分)。
.br
.ti -2n
\fBC-b\fP と \fBC-f\fP は、画面を 1 画面分スクロールアップ・ダウンさせる。
.br
.ti -2n
\fBg\fP はバッファの先頭へ移動する。
.br
.ti -2n
\fB%\fP は、バッファ中の指定したパーセンテージの位置へジャンプする。
.br
.ti -4n

.IR 注意 :
.br
\&.screenrc のコマンドを使って
Emacs 形式の移動をさせるようなカスタマイズも できる
(例: markkeys "h=^B:l=^F:$=^E")。ただし、
完全な Emacs 形式のキーマップには複数個の文字からなるコードが含まれているが、
これを簡単に実現することはできない。
.sp
.ti -4n
.IR マーキング :
.br
コピー領域は、2 つのマークを設定することによって指定する。
これらのマークの間のテキストはハイライト表示される。
.br
.ti -2n
\fBスペースキー\fPを押すと、1 番目・2 番目のマークが設定される。
.br
.ti -2n
\fBY\fP を押すと 1 行全体が、
\fBy\fP を押すと行頭から現在の位置までがマークされる。
.br
.ti -2n
\fBW\fP は 1 単語をマークする。
.sp
.ti -4n
.IR 繰り返し回数 :
.br
以上のコマンドはすべて、数字キーによって繰り返し回数を指定できる。
.br
.ti -2n
\fB0\fP..\fB9\fP は繰り返し回数として扱われる。
.br
例: \*QC-a C-[ H 10 j 5 Y\*U は、
11 行目から 15 行目までをペーストバッファにコピーする。
.sp
.ti -4n
.IR 検索 :
.ti -2n
\fB/\fP は \fIVi\fP と同様の検索コマンドである。
.ti -2n
\fB?\fP は \fIVi\fP と同様の検索コマンドである。
.ti -2n 
\fBC-a s\fP は \fIEmacs\fP 形式の前方へのインクリメンタル検索である。
\fBC-r\fP は \fIEmacs\fP 形式の後方へのインクリメンタル検索である。
.ti -4n
.sp
.IR 特殊コマンド :
一部のキーは
.I vi
とは異なる動作をする。
.I vi
ではテキストの矩形ブロックのヤンクを行えないが、
.I screen
ではできる。
.sp
.ti -2n
\fBc\fP や \fBC\fP キーを押して、左端と右端をそれぞれ設定する。
繰り返し回数を与えないと、どちらもデフォルトでは現在のカーソル位置となる。
.sp
例: 以下のコマンドをテキスト画面全体で試してみよ:
\*QC-a [ M 20 l SPACE c 10 l 5 j C SPACE\*U
.sp
これにより、カーソルはスクリーンの中央の行に移動し、
そこから 20 桁左に移動し、ペーストバッファの最初のマークを行い、
左端の設定を行い、5 桁右に移動し、右端を設定し、
最後にペーストバッファの終わりのマークを行う。
以下のコマンドを試し、コピーされるテキスト量の違いを見ること:
.sp
\*QC-a [ M 20 l SPACE 10 l 5 j SPACE\*U
.sp
.ti -2n
\fBJ\fP は行を連結する。これは 4 つのモードのトグルとなる。
それぞれのモードは、改行文字 (012) が行区切り、行区切りなし、
行区切りが空白、行区切りがカンマ、である。
なお \*Qcrlf on\*U を実行すると、改行文字の前に復帰文字を置ける。
.sp
.ti -2n
\fBv\fP は \*Q:set numbers\*U を使っている
.I vi
ユーザ向けのものである。すなわち、左マージンを
9 桁目と 1 桁目との間でトグルする。
.sp
.ti -2n
\fBa\fP を二番目のスペースの前に押すと、追加モードに切り替わる。
こうするとペーストバッファの内容を上書きせず、追加する。
.sp
.ti -2n
\fBA\fP は追加モードへの切り替えを行い、(2 番目の) マークを設定する。
.sp
.ti -2n
\fB>\fP は (2 番目の) マークをセットし、
コピーモードが終了した時にペーストバッファの内容を画面交換ファイル
(デフォルトでは /tmp/screen-exchange) に書き出す。
.br
次の例は、スクロールバックバッファ全体を
このファイルにダンプする方法を示したものである:
\*QC-A [ g SPACE G $ >\*U
.sp
.ti -2n
\fBC-g\fP は現在の行と桁に関する情報を与える。
.sp
.ti -2n
\fBx\fP は最初のマークと現在のカーソル位置を交換する。
これを用いると、既に配置したマークを調整できる。
.sp
.ti -2n
\fB@\fP は何もしない。コピーモードの終了も行わない。
.sp
.ti -2n
ここで説明していないすべてのキーは、コピーモードを終了させる。
.in -4n
.sp
.ne 3
.B copy_reg
.RI [ key ]
.PP
もう無い。代わりに \*Qreadreg\*U を使うこと。
.sp
.ne 3
.BR "crlf " [ on | off ]
.PP
`C-a [' コマンドを用いたテキスト領域のコピーに影響を与える。
これを `on' に設定すると、各行は 2 文字からなるシーケンス `CR' - `LF'
によって分割される。`off' だと `LF' だけが使われる。
.sp
.ne 3
.BR "debug on" | off
.PP
実行時デバッグのオン/オフを行う。
.I screen
にオプション -DDEBUG を付けてコンパイルするとデバッグが使えるようになり、
デフォルトでオンになる。このコマンドが影響を与えるのは、
メインの \*QSCREEN\*U のプロセスからのデバッグ出力だけである。
アタッチしたプロセスのデバッグ出力は、
一度無効にすると再度有効にすることはできない。
.\"nakano attacher process はこれで良いか？
.sp
.ne 3
.BR "defc1 on" | off
.PP
\fBc1\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルト設定を変える点が異なる。
初期設定は `on' である。
.sp
.ne 3
.BR "defautonuke on" | off
.PP
\fBautonuke\fP コマンドとほぼ同じであるが、
新しいディスプレイに対するデフォルト設定を変える点が異なる。
初期設定は `off' である。
端末のタイプに対する依存性を持たせたい場合は、
特殊な端末機能である `AN' を用いると良い。
.sp
.ne 3
.BR "defbce on" | off
.PP
\fBbce\fP コマンドとほぼ同じであるが、
新しいディスプレイに対するデフォルト設定を変える点が異なる。
初期設定は `off' である。
.sp
.ne 3
.B defbreaktype
..RI [ tcsendbreak | TIOCSBRK | TCSBRK ]
.PP
端末デバイスに対してブレーク信号を生成する方法を、可能なものの中から選ぶ。
.IR tcsendbreak " および " TIOCSBRK
にすることを勧める。三番目の
.I TCSBRK
は、ブレークの間
.I screen
セッションを完全にブロックしてしまうが、
長いブレークを発生させるにはこれしかないこともある。
.IR tcsendbreak " や " TIOCSBRK
では、長いブレークの際にスパイクが出てしまう (例えば毎秒 4 回など)
ことがある (そうでないこともある)。これはシステムに依存するだけでなく、
シリアルボードドライバによっても異なる。
\*Qdefbreaktype\*U をパラメータ無しで呼ぶと、
現在の設定を表示する。
.sp
.ne 3
.BR "defcharset " [ \fIset ]
.PP
\fBcharset\fP コマンドと似ているが、
新しいウィンドウに対するデフォルト設定を変える点が異なる。
引き数なしで呼び出された場合には、現在のデフォルト値を表示する。
.sp
.ne 3
.BI "defescape " xy
.PP
デフォルトのコマンド文字を設定する。
これは \*Qescape\*U とほぼ同じであるが、
マルチユーザのセッションでしか役に立たない点が異なる。
マルチユーザセッションでは、\*Qescape\*U
は呼び出したユーザのコマンド文字を変更する。
一方 \*Qdefescape\*U は、
これ以後に追加されるユーザのコマンド文字列のデフォルト値を変更する。
.sp
.ne 3
.BR "defflow on" | off | auto 
.RB [ interrupt ]
.PP
\fBflow\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルト設定を変える点が異なる。
初期設定は `auto' である。
\*Qdefflow auto interrupt\*U と指定すると、
コマンドラインオプションに
.BR \-fa " と " \-i
とを与えた場合と同じになる。
.sp
.ne 3
.BR "defgr on" | off
.PP
\fBgr\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルト設定を変える点が異なる。
初期設定は `off' である。
.sp
.ne 3
.BR "defhstatus " [ \fIstatus ]
.PP
以降作られる新しいウィンドウのハードステータス行を
.I status
にする。このコマンドは、すべてのウィンドウのハードステータス行に、
ウィンドウ番号やタイトル等を表示させるのに便利である。
.I status
にはウィンドウメッセージの場合と同様の指定機能が利用できるが、
このエスケープ文字は '%' ではなく '^E' (8 進値で 005) である。
こうなっているのは、プログラムの生成したハードステータス行を、
間違って解釈しないようにするためである。パラメータ
.I status
を省略すると、現在のデフォルト文字列が表示される。
デフォルトでは、新しいウィンドウのハードステータス行は空である。
.sp
.ne 3
.BI "defencoding " enc
.PP
\fBencoding\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルト設定を変える点が異なる。
初期設定では、エンコーディングは端末から取得する。
.sp
.ne 3
.BR "deflog on" | off
.PP
\fBlog\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルト設定を変える点が異なる。
初期設定は `off' である。
.sp
.ne 3
.BR "deflogin on" | off
.PP
\fBlogin\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルト設定を変える点が異なる。
配布状態での初期設定は `on' である (config.h.in を見よ)。
.sp
.ne 3
.BI "defmode " mode
.PP
新しく割り当てられる仮想 tty のモードを \fImode\fP に設定する。
\fImode\fP は 8 進数の値である。
\*Qdefmode\*U コマンドが与えられていない場合は、モード 0622 が使われる。
.sp
.ne 3
.BR "defmonitor on" | off
.PP
\fBmonitor\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルトの設定を変える点が異なる。
初期設定は `off' である。
.sp
.ne 3
.B defnonblock 
.BR on | off | \fInumsecs
.PP
\fBnonblock\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルトの設定を変える点が異なる。
初期設定は `off' である。
.sp
.ne 3
.BI "defobuflimit " limit
.PP
\fBobuflimit\fP コマンドとほぼ同じであるが、
新しいディスプレイに対するデフォルト設定を変える点が異なる。
初期設定は 256 バイトである。
端末の種類への依存性を持たせたい場合には、
特殊な端末機能である 'OL' が利用できる。
.sp
.ne 3
.BI "defscrollback " num
.PP
\fBscrollback\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルトの設定を変える点が異なる。
初期設定値は 100 である。
.sp
.ne 3
.BI "defshell " command
.PP
.B shell
コマンドの同義語である。そちらを参照のこと。
.sp
.ne 3
.BR "defsilence on" | off
.PP
\fBsilence\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルトの設定を変える点が異なる。
初期設定値は `off' である。
.sp
.ne 3
.BI "defslowpaste " msec"
.PP
\fBslowpaste\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルトの設定を変える点が異なる。
初期設定値は 0 ミリ秒であり、これは `off' の意味になる。
.sp
.ne 3
.BR "defutf8 on" | off
.PP
\fButf8\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルトの設定を変える点が異なる。
screen の起動時に \*Q-U\*U を指定した場合の初期設定値は `on' になり、
それ以外の場合の初期設定値は `off' になる。
.sp
.ne 3
.BR "defwrap on" | off
.PP
\fBwrap\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルト設定を変える点が異なる。
初期設定では行の折り返しは有効であり、\*Qwrap\*U コマンド
(\*QC-a r\*U) や "C-a : wrap on|off" を使うとトグルできる。
.sp
.ne 3
.BR "defwritelock on" | off | auto
.PP
\fBwritelock\fP コマンドとほぼ同じであるが、
新しいウィンドウに対するデフォルト設定を変える点が異なる。
初期状態では、書き込みロックは無効になる。
.\"nakano will be off かな？
.sp
.ne 3
.BR "defzombie " [\fIkeys\fP]
.PP
\fBzombie\fP コマンドと同じである。
現在はどちらもデフォルト値を変更する。
\fBzombie\fP コマンドの説明を参照すること。
.sp
.ne 3
.B detach
.RB [ -h ]
.PP
.I screen
のセッションをデタッチする
(セッションを端末から切り離し、バックグラウンドに回す)。
これにより、ユーザは
.I screen
を起動したシェルに戻る。デタッチされた
.I screen
は、
.B \-r
オプションを付けて
.I screen
を実行すれば復元できる (『コマンドラインオプション』を参照)。
.B \-h
オプションを指定すると、screen は直ちに端末との接続を閉じる (\*Qhangup\*U)。
.sp
.ne 3
.B dinfo
.PP
screen があなたの端末について想定している内容を表示する。
色付けや文字セット指定が効かない原因を調査したい場合に便利。
.sp
.ne 3
.B displays
.PP
現在接続されているユーザのフロントエンド (ディスプレイ) を表にして示す。
これはマルチユーザセッションにおいて特に便利。
.sp
.ne 3
.BR "digraph " [ \fIpreset ]
.PP
このコマンドはユーザに二重字 (digraph sequence) を入力させる。
この次に入力された 2 文字は、組み込みのテーブルで検索され、
得られた文字が入力ストリームに挿入される。
例えばユーザが 'a"' を入力すると、ウムラウト付きの a が挿入される。
最初に入力された文字が 0 (ゼロ)ならば、
.I screen
はこれに続く文字 (3 文字まで) を文字としてではなく 8 進数の値として扱う。
(省略可能な) 引き数
.I preset
はユーザの入力として扱われるので、
これを利用すると「ウムラウト」キーが作れる。
例えば "bindkey ^K digraph '"'" というコマンドを使うと、
CTRL-K a という入力によってウムラウト付きの a を生成できる。
.sp
.ne 3
.B dumptermcap
.PP
現在アクティブなウィンドウに対して最適化された
仮想端末用の termcap エントリを、
ユーザの \*Q$HOME/.screen\*U  ディレクトリ (あるいは
.I screen
がソケットを格納している場所のどこか。詳しくは後述の『ファイル』
セクションを参照) に書き出す。
この termcap エントリは、
.I screen
が各ウィンドウに対して設定する環境変数 $TERMCAP の値と同じである。
terminfo ベースのシステムでは、
.I captoinfo
のような変換プログラムを実行し、
.I tic
を使ってそのエントリをコンパイルする必要があるだろう。
.sp
.ne 3
.BR "echo " [ -n ]
.I message
.PP
echo コマンドを使うと、「今日のメッセージ」で
.I screen
ユーザに嫌がらせができる。通常はシステムグローバルの
/etc/screenrc に設定する。
\*Q-n\*U を使うと行送りを抑制できる。\*Qsleep\*U も参照すること。
echo は環境変数をオンラインで調べる時にも便利である。
.sp
.ne 3
.BI "encoding " enc
.RI [ enc ]
.PP
入出力の解釈方法を
.I screen
に伝える。最初の引き数はカレントウィンドウのエンコーディングを設定する。
各ウィンドウは別々のエンコーディングをエミュレートできる。
二番目のパラメータは省略可能であるが、
これを指定すると接続している端末のエンコーディングを上書き設定する。
screen はエンコーディングの検知にロケール設定を利用するので、
これが必要になることは無いはずである。端末のエンコーディングを
端末のタイプによって変更する方法としては、termcap の \*QKJ\*U
エントリを用いる方法もある。
.PP 
サポートされているエンコーディングは次の通り:
eucJP, SJIS, eucKR, eucCN, Big5, GBK, KOI8-R,
CP1251, UTF-8, ISO8859-2, ISO8859-3, ISO8859-4, ISO8859-5, ISO8859-6,
ISO8859-7, ISO8859-8, ISO8859-9, ISO8859-10, ISO8859-15, jis
.PP
\*Qdefencoding\*U も参照のこと。
これは新規ウィンドウに対するデフォルト値を変更する。
.sp
.ne 3
.BI "escape " xy
.PP
コマンド文字を \fIx\fP に設定し、
(\*Qmeta\*U コマンドを呼んで) リテラルコマンド文字を生成する文字を
\fIy\fP に設定する (\-e オプションと同様)。
各引き数には、文字 1 つ、
\*Q^x\*U 形式 (\*QC-x\*U の意味) の 2 文字からなるシーケンス、
バックスラッシュの後に 8 進数を続けたもの
(その文字の ASCII コードを指定する)、
バックスラッシュの後に 2 番目の文字を続けたもの
(\*Q\e^\*U や \*Q\e\e\*U など)、のいずれかを指定できる。
デフォルト値は \*Q^Aa\*U である。
.sp
.ne 3
.B eval
.I command1
.RI [ command2
.IR ... ]
.PP
各引き数をパースして、別々のコマンドとして実行する。
.sp
.ne 3
.B exec
.RI [[ fdpat ]
.IR "newcommand " [ "args ..." ]]
.PP
実行パス \fInewcommand\fP およびその引き数 (省略可) で指定された
unix サブプロセスを現在のウィンドウで実行する。
newcommand と標準入力/標準出力/標準エラー出力の間のデータフロー、
もともとこのウィンドウで開始されたプロセス
(これを「アプリケーションプロセス」と呼ぼう)、
screen そのもの (ウィンドウ)、の三つは、
ファイルディスクリプタパターン fdpat で制御する。
このパターンは基本的に 3 つの文字からなるシーケンスで、
newcommand の標準入力、標準出力、標準エラー出力を表す。
ドット (.) はファイルディスクリプタを
.I screen
に接続する。
感嘆符 (!) はファイルディスクリプタを既に実行中のプロセスに接続する。
コロン (:) は両方を結合させる。
.\"nakano 「両方」とは？
ユーザ入力は newcommand に送られる。
ただし newcommand が「アプリケーションプロセス」
の出力を受けていたり
(fdpats の最初の文字が `!' または `:')、
パイプ (|) が fdpat の最後に (4 番目の文字として)
追加されている場合は別である。
.P
引き数を付けずに `exec' を実行すると、
現在実行中のサブプロセスの名前と引き数とがそのウィンドウに表示される。
各ウィンドウで一度に動作できるサブプロセスはひとつだけである。
.P
サブプロセスの実行中には、`kill' コマンドはウィンドウのプロセスではなく
サブプロセスに影響する。
.P
この 21 通りもある組み合わせを描いた難解な図については、
PostScript 形式のファイル `doc/fdpat.ps' を参照のこと。
それぞれの図には、newcommand の三つのファイルデスクリプタを表す数字
2,1,0 が書かれている。`W' の印が付いた四角は普通の pty で、
このスレーブ側にアプリケーションプロセスがある。
`P' の印が付いた四角はセカンダリの pty で、
このマスター側に
.I screen
が属することになる。
.\"nakano 実際に見てみないとワカラン。
.P
省略形:
.br
`exec' と fdpat とコマンドの間の空白は省略できる。
末尾のドットと、ドットだけからなる fdpat は省略できる。
単に `|' と書くとパターン `!..|' と同義になる。
この場合には exec を省略でき、常に `!' で置き換え可能である。
.\"nakano ??
.sp
実行例:
.IP
exec ... /bin/sh
.br
exec /bin/sh
.br
!/bin/sh
.PP
同じウィンドウで、元のシェルを実行させたまま別のシェルを生成する。
両方のシェルの出力が表示され、ユーザの入力は新しい /bin/sh に送られる。
.IP
exec !.. stty 19200
.br
exec ! stty 19200
.br
!!stty 19200
.PP
ウィンドウの tty の速度を設定する。
stty コマンドが標準出力を操作する場合には、もうひとつ `!' を追加すること。
.IP
exec !..| less
.br
|less
.PP
これはウィンドウ出力にページャを追加する。
ユーザ制御をページャ越しに行い、
しかしページャにウィンドウのプロセスから入力を取得させるには、
この特殊文字 `|' が必要である。
.\"nakano で OK か？
これが動作するのは、
標準入力が tty でないとき、
.I less
が標準エラー出力を監視する (`|' が無ければ
.I screen
が想定しない動作) からである。
バージョンが 177 より新しい
.I less 
はここではまともに動作しない。この場合でも古き良き
.I pg
なら動作する。
.IP
!:sed -n s/.*Error.*/\e007/p
.PP
ウィンドウの出力をユーザと sed コマンドの両方に送る。sed は、
.I screen
の表示するウィンドウ出力にベル文字 (8 進値で 007) を追加挿入する。
これを実行すると、このウィンドウに "Error" という文字列が現われると必ず
"Bell in window x" というメッセージが出力される。
.sp
.ne 3
.B fit
.PP
ウィンドウのサイズを現在のリージョンのサイズにする。
このコマンドが必要なのは、screen はウィンドウが複数表示されている場合には
自動的なウィンドウサイズ調整を行わないためである。
.sp
.ne 3
.B flow
.RB [ on | off | "auto\fR]\fP"
.PP
このウィンドウのフロー制御モードを設定する。
パラメータを与えないと、現在のウィンドウのフロー制御設定を
"automatic", "on", "off" の順に切り替える。
詳細および注意点については、
本ドキュメントで後述する『フロー制御』での議論を参照すること。
これは将来のリリースでは変更されることになっている。
デフォルトでは `defflow' に設定されている。
.sp
.ne 3
.BR "focus " [ up | down | top | bottom ]
.PP
入力フォーカスを次のリージョンに移す。これは循環的に行われるので、
一番下のリージョンの次には一番上のリージョンが選択される。
サブコマンドを省略したときのデフォルトの動作は `down' である。`up'
とすると逆順に回り、`top' では一番上の、`bottom'
では一番下のリージョンに移動する。
便利なキーバインディングを以下に示す (j や k は vi 流):
.nf
    bind j focus down
    bind k focus up
    bind t focus top
    bind b focus bottom
.fi
.sp
.ne 3
.BR "gr " [ on | off ]
.PP
GR 文字集合のオン/オフを切り替える。
screen は、8 ビット目が立っている入力文字を見つけると、
必ず GR スロットに格納されている文字集合を使用し、
8 番目のビットを取り除いて文字を出力する。
デフォルトでは (\*Qdefgr\*U も参照) GR 切り替えは処理しない
(処理してしまうと ISO8859-1 文字集合が使えないためである)。
.sp
.ne 3
.B hardcopy
.RB [ -h ]
.RI [ file ]
.PP
現在表示されている画面イメージを \Ifile\fP に書き込む。
ファイル名を指定しないと、デフォルトディレクトリの \fIhardcopy.n\fP
というファイルに書き込む (\fIn\fP はカレントウィンドウの番号)。
ファイルが存在する場合には、追加か上書きのどちらかが行われる。
詳しくは次項を参照。\fB-h\fP オプションを与えると、
スクロールバックバッファの内容も書き込まれる。
.sp
.ne 3
.BR "hardcopy_append on" | off
.PP
"on" に設定されていると、
.I screen
はコマンド \*QC-a h\*U で生成される "hardcopy.n"
ファイルに対して追加書き込みを行う。
"off" の場合には、このファイルは毎回上書きされる。
デフォルト値は `off' である。
.sp
.ne 3
.BI "hardcopydir "directory
.PP
ハードコピーファイルが置かれるディレクトリを定義する。
設定されていない場合には、ハードコピーは
.I screen
のカレントワーキングディレクトリにダンプされる。
.sp
.ne 3
.BR "hardstatus " [ on | off ]
.br
.BR "hardstatus \fR[\fBalways\fR]\fBlastline" | message | ignore
.RI [ string ]
.br
.B "hardstatus string"
.RI [ string ]
.PP
端末のハードステータス行の利用とエミュレーション
に関する設定をする。
最初の形式では、
.I screen
がハードステータス行をメッセージ表示に用いるかどうかをトグルする。
このフラグが "off" ならば、
メッセージは表示行に反転ビデオモードでオーバーレイ表示される。
デフォルトの設定は `on' である。
.P
二番目の形式は、ハードステータス行が端末に無い
(つまり termcap/terminfo の "hs", "ts", "fs", "ds"
といった機能が設定されていない) 場合にどうするかについて
.I screen
に指示する。\*Qlastline\*U を指定すると、
.I screen
は画面の一番下の行を反転させてハードステータスとして用いる。
\*Qmessage\*U を指定すると
.I screen
のメッセージ機構が用いられ、\*Qignore\*U とすると
ハードステータスは一切表示されなくなる。
これらの指定の前に \*Qalways\*U をつける
(例えば \*Qalwayslastline\*U) と、
.I screen
は端末がハードステータス行をサポートしている場合でも
その指定を用いる。
.P
三番目の形式はハードステータス行の内容を指定する。
'%h' がデフォルトの文字列で、カレントウィンドウのハードステータスを表示する
(\*QESC]0;<string>^G\*U や \*QESC_<string>ESC\e\*U によって設定できる)。
この文字列は好きなように設定でき、
『文字エスケープ』の章にあるエスケープも利用できる。引き数
.I string
を省略すると、現在の文字列が表示される。
.P
二番目の形式に
.I string
引き数を付加することにより、三番目の形式の動作を同時に指定することもできる。
.sp
.ne 3
.B height
.RB [ -w | -d ]
.RI [ lines " [" cols ]]
.PP
ディスプレイの高さを指定された行数に設定する。
引き数を与えないと、24 行表示と 42 行表示の間をトグルさせる。
同時に指定すれば幅も変更できる。
.B -w
オプションは、ディスプレイのサイズはそのままで、
ウィンドウのサイズだけを設定したい場合に指定する。
.B -d
はその逆である。
.sp
.ne 3
.B help
.RB [ -c
.IR class ]
.PP
本当の意味でのオンラインヘルプとは言えないが、
キー割り当てをすべて示したヘルプ画面を表示する。
最初のページでは、内部コマンドとその現在のキー割り当てがリスト表示される。
次のページにはカスタムコマンドが、
キーごとに 1 つのコマンドの形式で表示される。
各ページを読み終えたらスペースキーを押せば次のページが見られ、
リターンキーを押せば即座にヘルプが終了する。
他の文字はすべて無視される。\*Q-c\*U オプションを与えると、
指定したコマンドクラスに結びつけられているすべてのコマンドを表示する。
『デフォルトのキー割り当て』の節も参照すること。
.sp
.ne 3
.B history
.PP
通常ユーザはシェルを使って作業していると、
以前のコマンドに簡単にアクセスできる。
例えば csh には直前に実行したコマンドを繰り返す \*Q!!\*U というコマンドがある。
.I screen
にも、「〜で始まるコマンド」を再呼び出しするための
原始的な方法が用意されている。
そのコマンドの最初の文字を打ち込み、その後に `C-a {' を打つと、
.I screen
はカーソルの左にある「プロンプト文字」にマッチする以前の行を見つけようとする。
この行はウィンドウの入力キューにペーストされる。これにより、
(可視ウィンドウとそのスクロールバッファからなる)
単純なコマンド履歴が使えることになる。
.sp
.ne 3
.BI "hstatus " status
.PP
ウィンドウのハードステータス行を文字列 \fIstatus\fP に変更する。
.sp
.ne 3
.B idle
.RI [ timeout
.RI [ "cmd args" ]]
.PP
指定した秒数の間作業がない時に実行されるコマンドを設定する。
普通ここにはスクリーンセーバを生成する \*Qblanker\*U
コマンドを指定することになるだろうが、screen コマンドならなんでも指定できる。
コマンドを何も指定しないと、タイムアウトだけが設定される。
timeout に 0 を指定する (あるいは \fBoff\fPを指定する) とタイマを無効にする。
一切引き数を与えないと、現在の設定を表示する。
.sp
.ne 3
.BR "ignorecase " [ on | off ]
.PP
検索時に大文字小文字を区別しないようにする。デフォルトは `off'。
.sp
.ne 3
.B info
.PP
メッセージ行を使って現在のウィンドウに関するいくつかの情報を表示する：
\*Q(カラム,行)\*U 形式のカーソル位置 (\*Q(1,1)\*U から始まる)、
端末の幅と高さ、およびスクロールバッファの大きさ (行数)。
例えば \*U(80,24)+50\*U のようになる。
ウィンドウの XON/XOFF フローコントロールの現在の状態は、
次のように表示される (『フロー制御』の章も参照)：
.sp
.nf
  +flow     自動フローコントロール、現在は on。
  \-flow     自動フローコントロール、現在は off。
  +(+)flow  フローコントロール有効。自動コントロールと一致。
  \-(+)flow  フローコントロール無効。自動コントロールとは不一致。
  +(\-)flow  フローコントロール有効。自動コントロールとは不一致。
  \-(\-)flow  フローコントロール無効。自動コントロールと一致。
.fi
.PP
現在の折り返しモードも表示される (`+wrap は有効、`\-wrap' は無効)。
 `ins', `org', `app', `log', `mon', `nored' の各フラグは、
それぞれウィンドウがインサートモード、オリジンモード、
アプリケーションキーパッドモード、出力ログあり、
アクティビティ監視中、部分再描画有効、の状態のときに表示される。
.PP
現在有効な文字集合 (\fIG0\fP, \fIG1\fP, \fIG2\fP, \fIG3\fP のいずれか) と、
現在 \fIG0\fP から \fIG3\fP に指定されている端末の文字集合
(角括弧で括られている) が表示される。
ウィンドウが UTF-8 モードのときは、これらの代わりに \*QUTF-8\*U が表示される。
.PP
ウィンドウのタイプに応じて、追加モードがステータス行の最下行に表示される
(『ウィンドウの種類』の章も見よ)。
.br
端末エミュレータのステートマシンがデフォルトの状態にないときは、
info 行の先頭には、まず現在の状態を示す文字列が表示される。
.br
システムの情報を見るには \*Qtime\*U コマンドを用いること。
.sp
.ne 3
.BR ins_reg " [" \fIkey ]
.PP
もう存在しない。代わりに \*Qpaste\*U を用いること。
.sp
.ne 3
.B kill
.PP
現在のウィンドウを kill する。
.br 
実行中の `exec' コマンドがあると、これが kill される。
それ以外の場合には、そのウィンドウで動作中のプロセス (シェル) が
HANGUP 信号を受け取り、そのウィンドウの関連データは削除され、
.I screen
(あなたの画面) は別のウィンドウへ切り替わる。
最後のウィンドウが破棄された時には、
.I screen
は終了する。kill の後には、
.I screen
は直前に表示していたウィンドウに切り替わる。
.br
注意:
.I Emacs
ユーザは、行を消すときに、このコマンドのことを念頭に置いておくように。
\*QC-a\*U を
.I screen
のエスケープキーとして用いない、あるいは
kill を \*QC-a K\*U に割り当てないことをお勧めする。
.sp
.ne 3
.B lastmsg
.PP
メッセージ/ステータス行の最後の内容を再表示する。
これが便利なのは、メッセージが表示されたときに
ちょうど文字を入力していたような場合である。
(端末にハードウェアステータス行が無ければ)
キーを押すとメッセージは消えてしまうからである。
この微調整には \*Qmsgwait\*U コマンドや \*Qmsgminwait\*U コマンドを参照のこと。
.sp
.ne 3
.B license
.PP
免責事項のページを表示する。これはオプション無しで
.I screen
を起動すると必ず実行される (たいていこれで十分だろう)。
\*Qstartup_message\*U コマンドも参照のこと。
.sp
.ne 3
.B lockscreen
.PP
このディスプレイをロックする。
スクリーンロックのプログラム (/local/bin/lck か /usr/bin/lock、あるいは
使えるものがなければ組み込みのもの) を呼び出す。
screen はこのプログラムが終了するまで一切のコマンドキーを受け付けない。
ウィンドウは「デタッチされた」状態となるので、
各ウィンドウで実行中のプログラムは継続して動作する。
スクリーンロックプログラムは、環境変数 $LOCKPRG で変更でき
(これは
.I screen
を実行するシェルで設定されていなければならない)、
ユーザの UID と GID で実行される。
.br
注意:
他のシェルをロックせず、
.I screen
にパスワードを与えていないと、このロックには意味がなく、
ロックされていないシェルから簡単に再アタッチできてしまう。
この機能は `lockterminal' と呼ぶ方が良いかもしれない。
.sp
.ne 3
.BR "log " [ on | off ]
.PP
現在のウィンドウからの出力を、
ファイル \*Qscreenlog.\fIn\fP\*U へ書き込む動作を開始/終了させる。
このファイルはウィンドウのデフォルトディレクトリにあり、
\fIn\fP は現在のウィンドウの番号である。このファイル名は
`logfile' コマンドで変更できる。
パラメータを与えなかった場合には、ログ出力の状態がトグルされる。
前のセッションログのファイルがあれば、
セッションログはこのファイルに追加される。現在の内容と
スクロールバック履歴の内容はセッションログには含まれない。
デフォルト値は `off' である。
.sp
.ne 3
.BI "logfile " filename
.br
.BI "logfile flush " secs
.PP
ログファイルにつく名前を定義する。デフォルト値は
\*Qscreenlog.%n\*U である。
二番目の書式は、
.I screen
がログファイルバッファをファイルシステムにフラッシュするまでの
待ち時間 (秒) を変更する。デフォルトの値は 10 秒である。
.sp
.ne 3
.BR "login " [ on | off ]
.PP
utmp データベースファイル中の、現在のウィンドウのエントリを追加・削除する。
これは、ウィンドウが「ログインされている」かどうかを制御する。
パラメータが与えられないと、そのウィンドウのログイン状態がトグルされる。
このようなトグルに加え、「ログイン」や「ログアウト」のキーがあると便利である。
例えば `bind I login on' と `bind O login off' とすれば、
これらの機能を C-a I と C-a O に割り当てできる。
.I screen
が root に suid されて動作する場合は、デフォルトの設定
(config.h.in にある) は \*Qon\*U のはずである。
新しいウィンドウのデフォルトのログイン状態を変えるには
\*Qdeflogin\*U コマンドを用いること。これら二つのコマンドは、
.I screen
のコンパイル時に utmp のサポートを組み込んである場合にしか存在しない。
.sp
.ne 3
.BR "logtstamp " [ on | off ]
.br
.B "logtstamp after"
.RI [ secs ]
.br
.B "logtstamp string"
.RI [ string ]
.PP
このコマンドは
.I screen
のログファイルタイムスタンプ機能を制御する。タイムスタンプを \*Qon\*U
にすると、アクティビティがないまま 2 分間が過ぎたときに、
.I screen
は現在時刻を含む文字列をログファイルに追加する。
さらに 2 分が経過した後に出力がなされると、
この出力の再開を記録する二番目のタイムスタンプが追加される。
.\"nakano でいいのかな？ have passwd だからこうだと思うけど。
このタイムアウト時間は、二番目の形式でこのコマンドを実行すると変更できる。
三番目の形式は、タイムスタンプ文字列をカスタマイズする
(デフォルトは `-- %n:%t -- time-stamp -- %M/%d/%y %c:%s --\\n')。
.sp
.ne 3
.B mapdefault
.PP
次の入力文字を、デフォルトのキー割り当てテーブルでのみ検索するよう
.I screen
に指示する。\*Qbindkey\*U も参照すること。
.sp
.ne 3
.B mapnotnext
.PP
mapdefault と似ているが、デフォルトのキー割り当てテーブルも検索しない。
.sp
.ne 3
.B maptimeout
.RI [ timo ]
.PP
入力シーケンス検出の文字間タイマのタイムアウト値を
.I timo
ミリ秒に設定する。引き数を与えずに maptimeout を実行すると、
現在の設定を表示する。\*Qbindkey\*U も参照すること。
.sp
.ne 3
.BI "markkeys " string
.PP
これはコピー/履歴モードで使われるキーマップを変更する方法である。
ここで string は \fIoldchar\fP=\fInewchar\fP のペアからなり、
ペア間の区切りは `:' である。例: \*QB=^B:F=^F\*U を string に指定すると、
`C-b' と `C-f' の各キーは vi 形式の割り当て
(ページ全体のスクロールアップ/ダウン) に変更される。
これらは、実は `B' と `F' に対するデフォルトの割り当てであるが。
コマンド \*Qmarkkeys h=^B:l=^F:$=^E\*U は、
このモードを emacs 形式の割り当てに設定する。
端末が文字を送るタイプのもので、
これによってコピーモードが終了してしまうような場合、
このコマンドを使って、
それらの文字に何もさせないようにすると良い。
no-op 文字は `@' で、\*Qmarkkeys @=L=H\*U のようにすれば、
`H' や `L' コマンドは以後使えなくなる。
この例で示したように、ひとつの機能に複数のキーを (一行で) 割り当てできる。
.sp
.ne 3
.BI "maxwin " num
.PP
screen の生成できる最大ウィンドウ数を設定する。
既に存在しているウィンドウには影響しない。この数は減らすことしかできない。
.sp
.ne 3
.B meta
.PP
コマンド文字 (C-a) を現在のウィンドウの入力ストリームに挿入する。
.sp
.ne 3
.BR "monitor " [ on | off ]
.PP
ウィンドウのアクティビティ監視をトグルする。
監視が有効で、
かつその影響を受けるウィンドウがバックグラウンドに切り替えられている場合、
最初の出力の際にアクティビティがあった旨ステータス行にメッセージが表示され、
ウィンドウ状態の表示において、そのウィンドウに `@' 印が付けられる。
初期状態では、すべてのウィンドウで監視はオフになっている。
.sp
.ne 3
.BI "msgminwait " sec
.PP
あるメッセージが表示されている時に、新しい (次の) メッセージを表示するまでに
.I screen
が待つ時間を定義する。デフォルト値は 1 秒である。
.sp
.ne 3
.BI "msgwait " sec
.PP
.I screen
が他の動作の影響を受けない場合に、メッセージが表示される時間を定義する。
デフォルト値は 5 秒である。
.sp
.ne 3
.BR "multiuser on" | off
.PP
シングルユーザモードとマルチユーザモードの切り替えを行う。
.I screen
の標準動作はシングルユーザモードである。マルチユーザモードでは、
コマンド `acladd', `aclchg', `acldel' を使って、
現在の
.I screen
セッションに対する他のユーザのアクセスを許可・禁止できる。
.sp
.ne 3
.BR "nethack on" | off
.PP
.I screen
が使うエラーメッセージの路線を変える。
\*Qnethack\*U というゲームに親しんでいるユーザなら、
このゲームスタイルのメッセージを楽しめるかもしれない。
これらのメッセージは事実を少々曲げているけれども、読むにはずっと面白い。
どうせ標準のメッセージだってそんなに分かりやすいわけではないし。
.br
このオプションが利用できるのは、
.I screen
のコンパイル時に NETHACK フラグが定義されている場合だけである。
そして、デフォルトの設定は環境変数 $NETHACKOPTIONS があるかどうかで決まる。
.sp
.ne 3
.B next
.PP
次のウィンドウに切り替える。このコマンドを繰り返し用いると、
ウィンドウを循環的に切り替えできる。
.sp
.ne 3
.B nonblock 
.RB [ on | off | \fInumsecs ]
.PP
出力の受け付けを停止したユーザインターフェース (ディスプレイ)
をどのように扱うかを screen に指示する。
このようなことが起こるのは、ユーザが ^S を押したときや、
TCP またはモデムの接続が切れたが hangup を受信していないような場合である。
nonblock を \fBoff\fP にしておくと (こちらがデフォルト)、
screen はディスプレイが出力を受理できるようになるまで待つ。
nonblock が \fBon\fP だと、screen はタイムアウトになるまで待つ
(\fBon\fP では 1s として扱われる)。待ってもディスプレイが文字を受け付けないと、
screen はディスプレイがブロックされていると判断し、
そのディスプレイへの文字送信を止める。
その後ディスプレイが文字の受信を再開すると、
screen はディスプレイのブロックを止め、更新されたウィンドウの内容を再描画する。
.sp
.ne 3
.BR "number " [ \fIn ]
.PP
現在のウィンドウ番号を変更する。
指定した番号 \fIn\fP が既に他のウィンドウに使われている場合には、
2 つのウィンドウは番号を交換する。引き数が指定されていない場合は、
現在のウィンドウ番号 (とタイトル) が表示される。
.sp
.ne 3
.BR "obuflimit " [ \fIlimit ]
.PP
指定した上限値より多いバイト数が出力バッファに含まれている場合、
このウィンドウからはそれ以上のデータは読み出せない。
このデフォルト値は 256 である。
(xterm のように) 高速なディスプレイを使っている場合には、
もう少し大きな値を設定しても良いだろう。引き数を指定しないと、
現在の設定が表示される。
.sp
.ne 3
.B only
.PP
現在のものを除き、すべてのリージョンを kill する。
.\"nakano region は「領域」だと見逃すかなあ。
.sp
.ne 3
.B other
.PP
前に表示されていたウィンドウに切り替える。
そのウィンドウがもう存在していなければ、
\fIother\fP は \fInext\fP と同じ動作をする。
.sp
.ne 3
.BR "partial on" | off
.PP
現在のウィンドウに切り替えた後、(\fIredisplay\fP を使ったように)
画面をリフレッシュするかどうかを定義する。
このコマンドが効果を及ぼすのは現在のウィンドウだけである。
すぐにウィンドウすべてに効果を及ぼすには、
\fIallpartial\fP コマンドを用いること。デフォルト値は当然 `off' である。
現在 \fIdefpartial\fP コマンドはないので、このデフォルト値は固定である。
.sp
.ne 3
.BR "password " [ \fIcrypted_pw ]
.PP
\*Q.screenrc\*U ファイル中に暗号化されたパスワードを置くことで、
デタッチされたセッションを誰かが再開しようとした際に、
.I screen
にこれを用いた認証を行わせる。これは特権を持つプログラムを
.I screen
下で動作させているときに、自分の UID を偽装した他のユーザ
(つまりスーパーユーザの誰か)
によるそのセッションの再アタッチを防ぎたい場合に便利である。
暗号化されたパスワードが指定されていないと、
.I screen
は 2 度パスワードの入力を求め、これを暗号化したものを
ペーストバッファに置く。デフォルト値は `none' であり、
パスワードの確認は無効になっている。
.sp
.ne 3
.BR paste
.RI [ registers " [" dest_reg ]]
.PP
指定されたレジスタの (連結された) 内容を、
現在のウィンドウの標準入力のキューに書き込む。
レジスタ '.' はペーストバッファとして扱われる。パラメータをひとつも与えないと、
ペーストを行うレジスタ (1 つ) をユーザに問い合わせる。
ペーストバッファには \fIcopy\fP, \fIhistory\fP, \fIreadbuf\fP
コマンドで書き込める。
他のレジスタには \fIregister\fP, \fIreadreg\fP, \fIpaste\fP
コマンドで書き込める。
2 番目の引き数付きで \fIpaste\fP が呼び出されると、
指定されたレジスタの内容はそのウィンドウではなく、
指定された出力先のレジスタにペーストされる。
2 番目の引き数として '.' を用いると、
そのディスプレイのペーストバッファが出力先となる。
.\"nakano display's か？
\*Qpaste\*U は様々な種類のリソースを使うことに注意:
2 番目の引き数が指定されていれば、カレントウィンドウは必要ない。
入力元指定に (ペーストバッファではなく) レジスタしか含まれなければ、
カレントディスプレイ (アタッチされている端末) は必要ない。
レジスタはグローバルなリソースだからである。
ペーストバッファはユーザ 1 人に 1 つずつしか存在しない。
.sp
.ne 3
.BR "pastefont " [ on | off ]
.PP
フォント情報をペーストバッファに含めるよう screen に指示する。
デフォルトではこれは行われない。
このコマンドが特に役立つのは、
漢字のように文字フォントが複数個ある場合である。
.\"nakano そうか？
.sp
.ne 3
.B pow_break
.PP
ウィンドウの端末ラインを再オープンし、ブレーク信号を送る。
`break' を参照すること。
.sp
.ne 3
.B pow_detach
.PP
強制デタッチ。基本的には \fIdetach\fP と同じだが、
.I screen
の親プロセスにも HANGUP シグナルを送る。
注意: 
.I screen
がログインシェルから実行されているときには、
これを行うとログアウトする。
.sp
.ne 3
.B pow_detach_msg
.RI [ message ]
.PP
「強制デタッチ」を行うときに、ここで指定した \fImessage\fP が出力される。
これはログアウトメッセージの代わりや、
ボーレートのリセットなどに使える。
.sp
.ne 3
.B prev
.PP
現在のウィンドウの次に小さい番号を持つウィンドウに切り替える。
このコマンドを繰り返し用いると、ウィンドウを循環できる。
.sp
.ne 3
.B printcmd
.RI [ cmd ]
.PP
.I cmd
が空文字列でない場合、ANSI 印刷シーケンス
.BR "ESC [ 5 i"
が検出されても screen は端末機能 \*Qpo/pf\*U を使わず、その出力を
.I cmd
にパイプする。\fIcmd\fP には通常、
\*Qlpr\*U や \*Q'cat > /tmp/scrprint'\*U のようなコマンドを与える。
コマンド指定なしで
.B printcmd
を実行すると、現在の設定が表示される。ANSI シーケンス
.B "ESC \e"
は印刷を終わらせ、パイプを閉じる。
.br
警告: このコマンドは注意して使うこと!
他のユーザが端末への書き込み権限を持っていると、
印刷コマンドを勝手に起動できてしまう。
.sp
.ne 3
.BR process " [" \fIkey ]
.PP
指定されたレジスタの内容を \fIscreen\fP の入力キューに入れる。
引き数を与えないと、ユーザにレジスタ名を尋ねるプロンプトを出す。
テキストはユーザがキーボードから入力したかのように解析される。
このコマンドを用いると、複数の動作を 1 つのキーに割り当てできる。
.sp
.ne 3
.B quit
.PP
すべてのウィンドウを kill し、
.I screen
を終了する。VT100 形式の端末では、C-4 キーと C-\e キーは同一であることに注意。
このため、デフォルトの割り当ては危険である:
ウィンドウ番号 4 を選択するときに、C-a C-4 と入力しないように注意すること。
キー割り当てを削除するには、空の bind コマンドを使えばよい
(\*Qbind '^\e'\*U など)。
.sp
.ne 3
.B readbuf
.RB [ -e
.IR encoding ]
.RI [ filename ]
.PP
指定したファイルの内容をペーストバッファに読み込む。
ファイルのエンコーディングを \fB-e\fP オプションで
screen に知らせることもできる。
ファイルを指定しないと、画面交換ファイルのファイル名が用いられる。
\*Qbufferfile\*U コマンドも参照のこと。
.sp
.ne 3
.B readreg 
.RB [ -e
.IR encoding ]
.RI [ register " [" filename ]]
.PP
.\"nakano it it
引き数の数に従って、以下の 2 動作のうちのどちらかを行う:
引き数が 0 個または 1 個の場合には、
ペーストバッファの内容を、指定されたレジスタか、
ユーザに問い合わせて得たレジスタに複製する。
引き数が 2 つの場合には、指定されたファイルの内容をレジスタに読み込む
(\fIreadbuf\fP が画面交換ファイルをペーストバッファに読み込むのと同様)。
ファイルのエンコーディングを \fB-e\fP オプションで
screen に知らせることもできる。
以下の例はシステムのパスワードファイルを
.I screen
の画面にペーストしている
(レジスタ p を用いている。これはコピーが残るレジスタである):
.PP
.nf
	C-a : readreg p /etc/passwd
	C-a : paste p
.fi
.sp
.ne 3
.B redisplay
.PP
現在のウィンドウを再描画する。
部分再描画モード時に画面全体を書き直す場合に必要となる。
.sp
.ne 3
.B register
.RB [ -e
.IR encoding ]
.I "key string"
.PP
指定された \fIstring\fP をレジスタ \fIkey\fP に保存する。
ファイルのエンコーディングを \fB-e\fP オプションで
screen に知らせることもできる。
\*Qpaste\*U コマンドも参照すること。
.sp
.ne 3
.B "remove"
.PP
現在のリージョンを kill する。リージョンがひとつしかない場合は no-op となる。
.\"nakano "region"
.sp
.ne 3
.B "removebuf"
.PP
\*Qwritebuf\*U コマンドと
\*Qreadbuf\*U コマンドが使う画面交換ファイルを削除 (unlink) する。
.sp
.ne 3
.B "reset"
.PP 
仮想端末を \*Q電源投入状態\*U の値にリセットする。
アプリケーションが設定
(スクロール領域やグラフィック文字集合など)
をおかしくした場合に役に立つ。
.sp
.ne 3
.B "resize"
.PP 
現在のリージョンのサイズを変更する。
スペースは下方のリージョンから取ったり (に渡したり) するが、
もし余裕がなければ上方のリージョンとやり取りする。
.\"nakano "region"
.IP
resize +N	現在のリージョンの高さを N 増やす
.IP
resize -N	現在のリージョンの高さを N 減らす
.IP
resize N	現在のリージョンの高さを N にする
.IP
resize  =	すべてのウィンドウを同じ高さにする
.IP
resize  max	現在のリージョンの高さを最大にする
.IP
resize  min	現在のリージョンの高さを最小にする
.PP
.sp
.ne 3
.B "screen \fP[\fI-opts\fP] [\fIn\fP] [\fIcmd\fP [\fIargs\fP]]"
.PP
新しいウィンドウを作る。
フロー制御オプション (\fB\-f\fP, \fB\-fn\fP,\fB\-fa\fP)、
タイトル (別名) オプション (\fB\-t\fP)、
ログインオプション (\fB-l\fP, \fB-ln\fP)、
端末タイプオプション (\fB-T <term>\fP)、
全機能フラグ (\fB-a\fP)、
スクロールバックオプション(\fB-h\fP <num>)
を各コマンドと共に指定できる。
.\"nakano ここの "each command" はなんだろう？
\fB-M\fP オプションを与えると、このウィンドウの監視が on になる。
\fB-L\fP オプションを与えると、このウィンドウの出力ロギングが on になる。
0 から 9 の範囲で数値 \fIn\fP を与えると(これは省略可能)、
新しく生成されるウィンドウにウィンドウ番号 \fIn\fP が割り当てられる
(この番号が既に使用中ならば、その次に利用可能な番号が使われる)。
\*Qscreen\*U の後にコマンドを指定すると、
そのコマンドは (指定された引き数付きで) ウィンドウ内で実行される。
コマンドが指定されていなければ、シェルが生成される。
したがって、\*Q.screenrc\*U に以下のような行がある場合、
.I screen
はシェルウィンドウを (番号 1 のウィンドウに) 生成し、
またマシン foobar に telnet 接続を行うウィンドウ
(フロー制御なし、タイトルは \*Qfoobar\*U, ウィンドウ番号は 2)
を生成し、この telnet セッションをログファイル (\*Qscreenlog.2\*U)
に出力する。
.sp
.nf
	# example for .screenrc:
	screen 1
	screen -fn -t foobar -L 2 telnet foobar
.fi
.sp
以前のバージョンの
.I screen
とは異なり、\*Qscreen\*U コマンドが \*Q.screenrc\*U
ファイルに含まれている時には、余分のデフォルトウィンドウは
生成されない点に注意すること。初期化が終了すると、
.I screen
は .screenrc ファイルで指定した最後のウィンドウに切り替わる。
ウィンドウが指定されていないと、
デフォルトの番号 0 のウィンドウを開く。
.br
screen には \*Qcu\*U と \*Qtelnet\*U の機能がいくつか組み込まれている。
『ウィンドウの種類』の章も参照のこと。
.sp
.ne 3
.B "scrollback \fP\fInum\fP"
.PP
現在のウィンドウのスクロールバックバッファの大きさを
\fInum\fP 行に設定する。デフォルトのスクロールバックは 100 行である。
\*Qdefscrollback\*U コマンドも参照すること。
また、現在の設定を確認するには \*QC-a i (info)\*U を用いること。
.sp
.ne 3
.BR "select " [ \fIWindowID ]
.PP
\fIWindowID\fP で指定したウィンドウに切り替える。
これはウィンドウタイトル (英字・数字のウィンドウ名) の先頭からの文字列か、
ウィンドウの番号である。
このパラメータは省略でき、その場合はユーザに識別子の問い合わせを行う。
新しいウィンドウが生成されると、
利用可能な最初の数がこのウィンドウに割り当てられる。
したがって、先頭のウィンドウは \*Qselect 0\*U で呼び出せる。
ウィンドウの総数は、コンパイル時の設定パラメータ MAXWIN によって制限される。
特殊な意味を持つ WindowID が二つ存在する。\*Q-\*U
は内部のブランクウィンドウを選択し、\*Q.\*U は現在のウィンドウを選択する。
後者は screen の \*Q-X\*U と一緒に用いると便利だろう。
.sp
.ne
.BR "sessionname " [ \fIname ]
.PP
現在のセッションの名前を変更する。この名前は、
\*Qscreen -list\*U ではプロセス ID と共に表示される点に注意すること。
引き数 \*Qname\*U を省略すると、このセッションの名前が表示される。
注意: この変更後も、環境変数 $STY は古い名前を反映したままである。
これにより混乱が起こるかもしれない。
デフォルト値は tty とホスト名から作られる。
.sp
.ne 3
.B "setenv " 
.RI [ var " [" string ]]
.PP
環境変数 \fIvar\fP の値を \fIstring\fP に設定する。
\fIvar\fP だけが指定されるとプロンプトが表示され、
値の入力がユーザに求められる。パラメータが全く指定されていなければ、
変数名と値の両方がユーザに問い合わせられる。
この環境変数は、設定以降に fork されるすべてのシェルに継承される。
.sp
.ne 3
.BR "setsid " [ on | off ]
.PP
通常 screen は各ウィンドウごとに別々のセッションとプロセスグループとを用いる。
setsid を \fIoff\fP にすると、以降これは行われないようになり、
すべてのウィンドウはバックエンドの screen プロセスと同じプロセスグループに
属するようになる。これはジョブ制御を不可能にすることに注意。
デフォルトは当然 \fIon\fP である。このコマンドが有用なのは、
おそらくかなりまれな状況に限られるだろう。
.sp
.ne 3
.B "shell \fIcommand\fP"
.PP
新しいシェルを生成するために使うコマンドを設定する。
これは環境変数 $SHELL の値より優先される。
これは、$SHELL を起動プログラムの指定に用いるような
tty 強化プログラムを使いたい時に便利である。
コマンドの最初の文字が '-' ならば、シェルはログインシェルとして起動される。
.sp
.ne 3
.B "shelltitle \fItitle\fP"
.PP
起動時や C-A C-c コマンドによって生成された、
すべてのシェルのタイトルを設定する。
タイトルに関する詳細は、
『タイトル (ウィンドウの命名)』の章での議論を参照のこと。
.sp
.ne 3
.BR "silence " [ on | off "|\fIsec\fP]"
.PP
ウィンドウの沈黙監視 (silence monitoring) をトグルする。
silence が on で、かつその影響を受けるウィンドウが
バックグラウンドに回されたとき、
指定された期間の間アクティビティがなければ (沈黙していれば)、
沈黙通知のメッセージがステータス行に表示される。
デフォルトのタイムアウトは `silencewait' コマンドで変更できる。
あるいは `on' や `off' の代わりに秒数を指定することもできる。
初期状態では、すべてのウィンドウで silence は off である。
.sp
.ne 3
.BI "silencewait " sec
.PP
沈黙を監視するウィンドウにおける、
メッセージ表示までの待ち時間を指定する。
デフォルト値は 30 秒である。
.sp
.ne
.B "sleep \fP\fInum\fP"
.PP
このコマンドは、.screenrc ファイルの実行を \fInum\fP 秒間一時停止させる。
キーボード入力があると sleep は終了する。これを用いると、
\*Qecho\*U による出力を読むチャンスをユーザに与えられる。
.sp
.ne 3
.B "slowpaste \fImsec\fP"
.PP
paste コマンド ("C-a ]") によってテキストを挿入する時の速度を定義する。
slowpaste の値が 0 でなければ、テキストは 1 文字ずつ書き込まれる。
.I screen
は 1 文字書き込むたびに \fImsec\fP ミリ秒停止し、
アプリケーションがこの入力を処理する時間を与える。
slowpaste コマンドは、大量のテキストをペーストしたときに、
下層のシステムでフロー制御の問題が起こる場合にのみ用いること。
.sp
.ne 3
.BI "source " file
.PP
\fIfile\fP からコマンドを読んで実行する。source コマンドはネストでき、
最大の再帰レベルは 10 である。ファイルが絶対パスでなく、
すでに screen が source コマンドを処理中の場合は、
screen のカレントディレクトリよりも先に、
実行中の source コマンドファイルの親ディレクトリが、
新たなコマンドファイルの検索に用いられる。
.PP
temcap/terminfo/termcapinfo コマンドは起動時か
再アタッチの時にしか動作しないことに注意。
したがってこれらを機能させるには、
デフォルトの screenrc ファイルから呼ばれるところに置いておかねばならない。
.sp
.ne 3
.B sorendition
.RB [ "\fIattr\fR " [ \fIcolor ]]
.PP
テキストのマーキングや印刷メッセージで、
.I screen
が行うハイライト表示のさせかたを変更する。
.I attr
修正指定の文法は『文字エスケープ』の章を見ること。
現在のデフォルトは \*Q=s dd\*U である (スタンドアウト、デフォルト色)。
.sp
.ne 3
.B split
.PP
現在のリージョンを 2 つに分割する。
新たなリージョンの場所を確保するため、画面上のすべてのリージョンはリサイズされる。
新しいリージョンにはブランクウィンドウが表示される。
リージョンの削除には、\*Qremove\*U コマンドまたは \*Qonly\*U コマンドを用いること。
.\"nakano region
.sp
.ne 3
.B "startup_message on\fP|\fBoff"
.PP
起動時に著作権表示を表示するかどうかを選ぶ。
デフォルト値は、おそらく既にお気付きの通り、`on' である。
.sp
.ne 3
.B stuff
.I string
.PP
文字列
.I string
をカレントウィンドウの入力バッファに置く。
これは \*Qpaste\*U コマンドと似ているが、
こちらの方がオーバーヘッドが小さい。
\*Qstuff\*U コマンドでは大きなバッファのペーストはできない。
このコマンドは、キー割り当てで用いると非常に便利である。
\*Qbindkey\*U も参照すること。
.sp
.ne 3
.B su
.RB [ username " [" password
.RB [ password2 ]]
.PP
ディスプレイのユーザを変更する。省略されたパラメータについては、
すべて問い合わせのプロンプトを出す。パスワードをパラメータに指定する場合は、
暗号化されていないかたちでなければならない。
一番目のパスワードはシステムのパスワードデータベースに対してマッチが行われ、
二番目のパスワードは \*Qacladd\*U コマンドや
\*Qpassword\*U コマンドで設定された
.I screen
のパスワードに対してマッチが行われる。
\*Qsu\*U は、
.I screen
の管理者がマルチユーザ設定をテストする際に便利であろう。
.\"						XXX removed in 3.8.0 XXX
.\" but it is mainly used implicitly
.\" by the \*Qconnect\*U command to identify users that access a remote session.
認証に失敗すると、そのユーザがアクセスできるコマンドはユーザ
.B nobody
が使えるもの
(すなわち
\*Qdetach\*U, \*Qlicense\*U, \*Qversion\*U, \*Qhelp\*U, \*Qdisplays\*U)
に限られる。
.sp
.ne 3
.B "suspend"
.PP
.I screen
をサスペンドする。
.I screen
がサスペンドされている間は、ウィンドウは「デタッチされた」状態となる。
この機能は、シェルのジョブ制御機能に依存している。
.sp
.ne 3
.B "term \fIterm\fP"
.PP
.I screen
がオープンした各ウィンドウの環境変数 $TERM には、デフォルトでは
\*Qscreen\*U が設定される。
しかし、ローカルの termcap または terminfo データベースに
\*Qscreen\*U 用の記述がインストールされていないときには、
$TERM には (例えば) \*Qvt100\*U を設定すると良い。
.I screen
は VT100/ANSI 互換なので、これならあまり問題は起きないだろう。
デフォルト値を設定する目的以外に
\*Qterm\*U コマンドを使うのは避けたほうがよい。
例えば、\*Qscreen rlogin othermachine\*U の実行前に
特殊な $TERM (vt100 等) を設定したいような場合である。
このような時には、デフォルト値を変更・復帰するのではなく、
\*Qscreen -T vt100 rlogin othermachine\*U というコマンドを用いると良い。
.sp
.ne 3
.BI termcap " term terminal-tweaks"
.RI [ window-tweaks ]
.br
.BI terminfo " term terminal-tweaks"
.RI [ window-tweaks ]
.br
.BI termcapinfo " term terminal-tweaks"
.RI [ window-tweaks ]
.PP
このコマンドを使うと、
独自の termcap エントリを作るという面倒な作業を行わずに、
端末の termcap エントリを修正できる。
さらに、そのウィンドウ用に生成された termcap のカスタマイズもできる。
端末エミュレータが起動したらこれらの設定は意味を持たないので、
これらのコマンドは
screenrc スタートアップファイルのどこかに置かなければならない。
.PP
termcap でなく terminfo データベースで動作するシステムでは、
.I screen
は `terminfo' コマンドを認識する
(このコマンドの効果は `termcap' コマンドと同じ)。
2 つの異なるコマンドが提供されているのは、
例えば (`%' を用いた) パラメータ挿入が必要な場合などに、
文法が微妙に異なるからである。
なお、 `terminfo' コマンドでも、
各機能の名前には termcap でのものを使わなければならない。
.PP
多くの場合、つまり引き数が terminfo と termcap どちらの文法でも有効な場合は、
`termcapinfo' コマンドが使える。このコマンドは、`termcap'
コマンドと `terminfo' コマンドとの両方を、同じ引き数で実行するものである。
.PP
最初の引き数は、この定義がどの端末に影響するかを指定する。
端末名を `|' で区切ることにより、複数の端末を指定できる。
すべての端末にマッチさせるには `*' を用い、\*Qvt\*U で始まるすべての端末に
マッチさせるには `vt*' を用いれば良い。
.PP
各 \fItweak\fP 引き数には、適切な termcap エントリの先頭に挿入される、
1 つ以上の termcap 定義 (`:' で区切る) が含まれる。
これによりエントリを拡張したり、既定の値を変更したりできる。
最初の tweak は使っている端末の termcap を修正するもので、
使っている端末が何らかの機能を実現するために用いる定義を含む。
これを変更しないのならば空文字列 (つまり '') を指定すること。
2 番目の (省略可能な) tweak は、
全ウィンドウの termcap を変更するもので、
.I screen
が理解する定義を含まなければならない
(『仮想端末』の章を参照すること)。
.PP
いくつか例を示す:
.IP
termcap xterm*  LP:hs@
.PP
これは、
`xterm' で始まるすべての端末はちゃんとした自動マージン機能を持っており、
画面の最後の位置を更新できる (LP) が、ステータス行を本当に持っていないこと
('hs' がない \- エントリを無効にするには `@' を追加する) を
.I screen
に知らせる。
なお\*Qvt\*U で始まるすべての端末名には `LP' があるものと想定しているが、
これはその端末に対して termcap コマンドを指定していない場合に限られる。
.IP
termcap vt*  LP
.br
termcap vt102|vt220  Z0=\eE[?3h:Z1=\eE[?3l
.PP
最初の行は、`vt' で始まるすべての端末に、
確実にマージン機能が動作する `LP' 機能があることを指定する。
次の行は、端末が VT102 または VT220 の時に、
132 文字/行モードにしたり (Z0)、これを解除する (Z1)
エスケープシーケンスを追加する
(画面幅変更コマンドを用いるには、
termcap ファイルに Z0 と Z1 を指定しなければならない)。
.IP
termcap vt100  ""  l0=PF1:l1=PF2:l2=PF3:l3=PF4
.PP
これは VT100 の termcap はそのままにしておき、
各ウィンドウの termcap エントリにファンクションキーのラベルを追加する。
.IP
termcap h19|z19  am@:im=\eE@:ei=\eEO  dc=\eE[P
.PP
h19 または z19 termcap での自動マージンを無効にし(am@)、挿入モード
(im) と挿入終了 (ei) 機能を有効にする
(`im' の文字列中の `@' は `=' の後にあるので、この文字列の一部である)。
`im' と `ei' の定義を使っている端末の termcap に入れると、
.I screen
は各ウィンドウの termcap の文字挿入機能を自動的に告知する。
各ウィンドウの termcap には、文字削除機能 (dc) も追加され、
.I screen
はその端末での行更新機能に変換する
(つまり文字削除をサポートしていないものとみなす)。
.PP
各ウィンドウの termcap エントリをすべて定義したければ、
このコマンドを用いるのではなく、
.I screen
を実行する前に $SCREENCAP 変数を設定すること。
termcap の定義に関する詳しい情報については、
このマニュアルの『仮想端末』での議論と、
オンラインマニュアルの
.BR termcap (5)
とを参照すること。
.sp
.ne 3
.B time
.RI [ string ]
.PP
メッセージ行を用いて、時刻、ホスト名、1, 5, 15 分間のロードアベレージ
(使っているシステムで可能なら) を表示する。
ウィンドウ固有の情報については \*Qinfo\*U を用いること。
.PP
string を指定すると、時刻の報告形式を
\*Q文字エスケープ\*U の章で記述する方法に従って変更する。
screen はデフォルトでは "%c:%s %M %d %H%? %l%?" を用いる。
.sp
.ne 3
.BR "title " [ \fIwindowtitle ]
.PP
現在のウィンドウの名前を \fIwindowtitle\fP に設定する。
名前が指定されないと、
.I screen
はユーザに入力を求める。
このコマンドは過去のリリースでは `aka' コマンドという名前だった。
.sp
.ne 3
.BI "unsetenv " var
.PP
環境変数の設定を取り消す。
.sp
.ne 3
.B utf8
.RB [ on | off
.RB [ on | off ]]
.PP
現在のウィンドウが用いるエンコーディングを変更する。
utf8 を on にすると、ウィンドウに送られる文字列は UTF-8 エンコードされる
(逆も同じ)。パラメータを省略すると状態をトグルする。
二つ目のパラメータを与えると、
ディスプレイのエンコーディングも同時に変更される
(これは screen の \*Q-U\*U オプションで指定するほうが良いが)。
\*Qdefutf8\*U も参照のこと。
これは新規に生成されるウィンドウのデフォルトを変更する。
.sp
.ne 3
.B vbell 
.RB [ on | off ]
.PP
このウィンドウの可視ベル (visual bell) を設定する。
可視ベルが on で、
使っている端末が可視ベルをサポートしていない場合には、
ベル文字 (^G) を受信した際に `vbell-message' がステータス行に表示される。
端末が可視ベルをサポートしているかどうかは termcap 変数 `vb'
(terminfo では 'flash') で定義される。
.PP
デフォルトでは vbell は off になっており、
音声ベル (audible bell) が用いられる。
`bell_msg' も参照のこと。
.sp
.ne 3
.B vbell_msg
.RI [ message ]
.PP
可視ベルのメッセージを設定する。ウィンドウがベル文字 (^G) を受け取り、
かつ vbell が \*Qon\*U に設定されているが、
しかし端末が可視ベルをサポートしていない場合、
\fImessage\fP がステータス行に表示される。
デフォルトのメッセージは `\*QWuff, Wuff!!\*U' である。
パラメータを省略すると、現在のメッセージが表示される。
.sp
.ne 3
.BI "vbellwait " sec
.PP
.IR screen
の可視ベルメッセージが表示された後の待ち時間を定義する。
デフォルト値は 1 秒である。
.sp
.ne 3
.B verbose
.RB [ on | off ]
.PP
verbose を on にすると、ウィンドウが生成される
(あるいはゾンビ状態から復活する) ときに、コマンド名がエコーされる。
パラメータを省略すると、現在の設定が表示される。
.sp
.ne 3
.B version
.PP
現在のバージョンとコンパイルされた日時をステータス行に表示する。
.sp
.ne 3
.BI "wall " "message"
.PP
すべてのディスプレイにメッセージを書き込む。
このメッセージは端末のステータス行に現れる。
.sp
.ne 3
.B width
.RB [ -w | -d ]
.RI [ cols " [" lines ]]
.PP
ウィンドウの幅を 80 と 132 カラムの間でトグルする。
または引き数を指定すると \fInum\fP カラムに設定する。
この機能を持った端末と、termcap のエントリ \*QZ0\*U, \*QZ1\*U を必要とする。
詳細は \*Qtermcap\*U コマンドを参照すること。
同時に高さを指定して変更することもできる。
.B -w
オプションを指定すると、
ディスプレイのサイズはそのままにウィンドウのサイズだけを変更する。
.B -d
はその逆である。
.sp
.ne 3
.B windowlist
.RB [ -b ]
.RB [ -m ]
.br
.B windowlist
.B string
.RI [ string ]
.br
.B windowlist
.B title
.RI [ title ]
.PP
全ウィンドウを表形式で示し、ビジュアルにウィンドウを選択できるようにする。
通常の移動キー (\*Qcopy\*U コマンドを見よ) でウィンドウを選択でき、
リターンキーで切り替えできる。
.B -b
オプションを与えると、screen はリストを表示する前に
ブランクウィンドウに切り替わるので、カレントウィンドウも選択できるようになる。
.B -m
オプションはウィンドウの並び順を変更する。
ウィンドウ番号の代わりに、screen が内部で持っている
「最終利用時刻」順のリストが用いられる。
.PP
表のフォーマットは \fBstring\fP オプションと
\fBtitle\fP オプションとで変更できる。title は表の先頭に表示され、
各レコードには string の設定が用いられる。デフォルトの設定は
title が \*QNum Name%=Flags\*U で、
各レコードが \*Q%3n %t%=%f\*U である。
もっと複雑なこと (色設定など) をしたければ、
『文字エスケープ』を参照のこと。
.sp
.ne 3
.B windows
.PP
メッセージ行を使ってすべてのウィンドウの一覧を表示する。
ウィンドウは番号順に並べられ、ウィンドウで起動されたプロセスの名前
(またはウィンドウのタイトル) もそれぞれ表示される。
現在のウィンドウには `*' が付く。
ひとつ前のウィンドウには `-' が付く。
「ログイン」されているすべてのウィンドウには `$' が付く。
ベル文字を受け取ったバックグラウンドウィンドウには `!' が付く。
監視中で、アクティビティが検出されたバックグラウンドウィンドウには
`@' が付く。
ログ出力が有効になっているウィンドウには `(L)' が付く。
他のユーザが保有しているウィンドウには `&' が付く。
ゾンビ状態のウィンドウには `Z' が付く。
この一覧が長すぎて、端末のステータス行ではすべてを表示できない場合には、
現在のウィンドウの近辺だけが表示される。
.sp
.ne 3
.BR "wrap " [ on | off ]
.PP
現在のウィンドウの行折り返しを設定する。
行折り返しが有効ならば、ある行の最後のカラムの次にある
表示可能文字の出力は、次の行の先頭へ折り返される。
追加機能として、バックスペース (^H) も画面の左端から前の行に折り返しで戻る。
デフォルト値は `on' である。
.sp
.ne 3
.B writebuf
.RB [ -e
.IR encoding ]
.RI [ filename ]
.PP
ペーストバッファの内容を指定したファイルに書き出す。
ファイルを指定しないと誰でもアクセスできる画面交換ファイルに書き出す。
これは、同じホスト上の
.I screen
のユーザ間がコミュニケーションするための原始的な方法ともみなせる。
encoding を指定すると、ペーストバッファへの記録は、
そのエンコードに合うように自動的に変換される。
ファイル名は \*Qbufferfile\*U コマンドで設定でき、
そのデフォルト値は \fI/tmp/screen-exchange\fP である。
.sp
.ne 3
.BR "writelock " [ on | "off\fR|\fBauto\fR]"
.PP
アクセス制御リストによる制限とは別に、
必ずしもすべてのユーザが同じウィンドウに同時に書き込みできるわけではない。
デフォルトでは、書き込みロックは `auto' モードになっており、
ある特定のウィンドウに最初に切り替えたユーザが、
排他的な入力パーミッションを得るようになっている。
このユーザがそのウィンドウを離れると、
他のユーザが (自動的に) 書き込みロックを取得できるようになる。
現在のウィンドウの書き込みロックは \*Qwritelock off\*U コマンドで無効となる。
ユーザが \*Qwritelock on\*U コマンドを発行すると、
そのユーザは他のウィンドウに切り替えている間も
排他的な書き込みパーミッションを保持し続ける。
.sp
.ne 3
.B xoff
.br
.B xon
.PP
CTRL-s / CTRL-q 文字を現在のウィンドウの標準入力キューに挿入する。
.sp
.ne 3
.B zmodem
.RB [ off\fR|\fPauto\fR|\fPcatch\fR|\fPpass ]
.br
.B "zmodem sendcmd"
.RI [ string ]
.br
.B "zmodem recvcmd"
.RI [ string ]
.PP
.br
screen の zmodem サポートを定義する。
screen が zmodem 要求を検知した際の動作には、
2 つのモード \*Qpass\*U と \*Qcatch\*U がある。
\*Qpass\*U モードでは、screen は通信の末尾に至るまでのすべてのデータを
アタッチしているプロセスに転送する。
\*Qcatch\*U モードでは、screen は zmodem の通信端末となり、
それぞれ rz/sz コマンドを起動する。\*Qauto\*U モードでは、
screen はウィンドウが tty (例えばシリアルライン) なら
\*Qcatch\*U を用い、それ以外なら \*Qpass\*U を用いる。
この機能はまだ実験段階のものである。
.sp
.ne 3
.BR "zombie " [\fIkeys\fP]
.br
.BR "defzombie " [\fIkeys\fP]
.PP
デフォルトでは
.I screen
のウィンドウはユーザのプロセス (シェル等) が終了すると即座に削除される。
2 つのキーからなる文字列を zombie コマンドに指定すると、
「死んだ」ウィンドウもリスト中に残る。
このようなウィンドウは \fBkill\fP コマンドで削除できる。
「死んだ」ウィンドウで 1 番目のキーを押すと同じ効果が得られる。
2 番目のキーを押すと、
.I screen
はこのウィンドウを復活させようとする。
つまり、このウィンドウで実行されていたプロセスを再び起動する。
パラメータを指定せずに \fBzombie\fP コマンドを呼び出すと、
zombie の設定がクリアされ、
したがってウィンドウは内部のプロセスが終了したときに消えるようになる。
.PP
zombie の設定はすべてのウィンドウに対してグローバルに操作されるので、
このコマンドは \fBdefzombie\fP とのみ呼ぶべきである。
ウィンドウごとの設定が必要となるまでは、
\fBzombie\fP コマンドは \fBdefzombie\fP コマンドと同じにしておく。

.SH メッセージ行
.I screen
は情報メッセージや診断メッセージを\fIメッセージ行\fPに表示する。
この行は通常画面の一番下に配置されるが、
コンパイル時の設定で画面の一番上に現れるようにも定義できる。
使っている端末の termcap にステータス行の定義がある場合、
.I screen
はこれをメッセージ表示に用いる。それ以外の場合には、
現在の画面のうち 1 行が一時的に上書きされ、
出力がしばらく中断される。数秒後にこのメッセージ行は自動的に消されるが、
(ステータス行の無い端末では)
キー入力を行えばすぐに消すこともできる。
.PP
メッセージ行の機能は、
カレントウィンドウで動作中のアプリケーションからも利用できる。
これには ANSI の\fIプライバシーメッセージ (Privacy message)\fP
制御シーケンスを使う。
例えば、シェルから以下のようなコマンドを試してみよ:
.IP
echo '<esc>^Hello world from window '$WINDOW'<esc>\e\e'
.PP
ここでの '<esc>' は \fIescape\fP、'^' は上矢印キーである。
また '\e\e' はバックスラッシュ 1 つに置き換えられる。

.SH ウィンドウの種類
.I screen
は 3 種類のウィンドウを提供している。新しいウィンドウは
.I screen
の
.B screen
コマンドで生成される (『カスタマイズ』の章のエントリも参照)。
どのタイプのウィンドウが生成されるかは、
.B screen
コマンドに与える最初のパラメータによって決まる。
各タイプは、それぞれ基本タイプの特殊ケースである。
これらは
.I screen
を 100 以上のウィンドウを扱うコンソールマルチプレクサとして
効率良く利用できるように追加されてきた。

.IP \(bu 3
基本ウィンドウは、シェル (パラメータが与えられない場合のデフォルト)
またはシェルから起動される何らかのシステムコマンド (例:
.B slogin
など) を内部で実行する。

.IP \(bu
tty (キャラクタスペシャルデバイス) の名前 (例えば \*Q/dev/ttya\*U)
を最初のパラメータに指定すると、そのウィンドウはこのデバイスに直接接続する。
このウィンドウタイプは \*Qscreen cu -l /dev/ttya\*U と似ている。
指定するデバイスノードには読み書きのアクセス権が必要で、
ノードには排他オープンが試みられ、接続ラインを busy 状態にしようとする。
追加パラメータを与えることもできる。
これはコンマ区切りのフラグの並びで、各フラグの意味は
.BR stty (1)
のものと同様である:
.RS
.IP <baud_rate>		
通常は 300, 1200, 9600, 19200 のいずれか。
この指定は送信・受信両方の速度に影響する。
.IP "cs8 または cs7"
1 バイトあたり 8 ビット (または 7 ビット) を送るよう指定する。
.IP "ixon または -ixon"
データ送信におけるソフトウェアフローコントロール (CTRL-S/CTRL-Q)
を有効に (無効に) する。
.\"nakano 原文間違い?
.IP "ixoff または -ixoff"
データ受信におけるソフトウェアフローコントロールを有効に (無効に) する。
.IP "istrip または -istrip"
各受信バイトの 8 ビット目を消去 (保持) する。
.PP
これらのパラメータは、できるだけ指定したほうが良いだろう。
指定しないオプションの接続時の値は、端末ドライバが決めることになる。
これらの値はシステムに依存し、
デフォルトが定義されているかもしれないし、
前回の接続時の値を保存して使うかもしれない。
.PP
tty ウィンドウでは、
.B info
コマンドによってモデムの制御線がいくつかステータス行に表示される。
これらには `RTS', `CTS', `DTR', `DSR', `CD' などが含まれうる。
何が表示されるかは、利用できる ioctl() とシステムのヘッダファイル、
シリアルボードの物理的な特性などに依存する。
論理 low (inactive) の信号は、名前の前にエクスクラメーション (!) が付く。
付いていない信号は論理 high (active) である。
ハードウェアがサポートしていないが、ioctl() インターフェースは存在する信号は、
通常 low として表示される。
.sp
CLOCAL ステータスビットが真の場合、モデム信号全体が中括弧 ({ と })
の内部に置かれる。CRTSCTS ビットが立っている場合は `CTS' 信号が括弧で括られ、
TIOCSOFTCAR ビットが立っている場合は `CD' 信号が括弧で括られる。
.sp
tty ウィンドウでは、
.B break
コマンドによってデータ送信線 (TxD) が指定した期間だけ low になる。
これは、通信の他端にてブレーク信号と解釈されることが期待できる。
.B break
が発行されると、データ送信は行われず、モデム制御線は変更されない。
.RE
.IP \(bu
最初のパラメータが \*Q/telnet\*U だと、
二番目のパラメータはホスト名とされ、
三番目のパラメータ (省略可) は TCP のポート番号を指定することになる
(デフォルトは 10 進数の 23)。
.I screen
はリモートホストでリッスンしているサーバに接続し、
そのサーバとの通信に telnet プロトコルを用いる。
.sp
telnet ウィンドウでは、
.B info
コマンドによって、ステータス行の末尾に
接続の詳細が角括弧 ([ と ]) に括られて表示される。
.RS
.IP b
BINARY。この接続はバイナリモードである。
.IP e
ECHO。ローカルエコーは無効になっている。
.IP c
SGA。この接続は「キャラクタモード」である (デフォルトは「ラインモード」)。
.IP t
TTYPE。この端末タイプはリモートホストからリクエストされた。
.I screen
は、特に指定がなければ端末名 \*Qscreen\*U を送る
(`term' コマンドも参照)。
.IP w
NAWS。リモートサイトはウィンドウサイズの変更を通知される。
.IP f
LFLOW。リモートホストはフロー制御情報を送る
(現時点では無視される)。
.PP
他にもデバッグ用のフラグとして、x (XDISPLOC),
t (TSPEED), n (NEWENV) が存在する。
.PP
telnet ウィンドウでは、
.B break
コマンドを実行すると telnet コード IAC BREAK (10 進 243)
がリモートホストに送信される。
.sp
このウィンドウタイプは
.I screen
のコンパイル時に BUILTIN_TELNET オプションを定義していないと使えない。
.RE

.SH 文字エスケープ
screen には、
現在時刻のメッセージやファイル名などの情報を表示するための、
エスケープの仕組みがある。エスケープ文字は '%' であるが、
ひとつだけ例外があり、ウィンドウのハードステータスの内部では
これの代わりに '^%' ('^E') を用いる。
.PP
以下にサポートされているエスケープの完全なリストを示す:
.IP %
エスケープ文字自身
.IP a
\(aqam' または 'pm' のどちらか
.IP A
\(aqAM' または 'PM' のどちらか
.IP c
現在の時刻 HH:MM (24h 表記)
.IP C
現在の時刻 HH:MM (12h 表記)
.IP d
月内日
.IP D
曜日
.IP f
ウィンドウのフラグ
.IP F
ウィンドウにフォーカスがあると %? を真にする
.IP h
ウィンドウのハードステータス
.IP H
システムのホスト名
.IP l
システムの現在の負荷 (load)
.IP m
月 (数値)
.IP M
月 (名前)
.IP n
ウィンドウ番号
.IP s
秒
.IP t
ウィンドウのタイトル
.IP u
このウィンドウを使っている他のユーザすべて
.IP w
.\"nakano quailifier は qualifier か？
全ウィンドウの番号と名前。限定詞 '-' をつけると現在のウィンドウまで、
限定詞 '+' をつけると現在のウィンドウ以降、となる。
.IP W
現在のウィンドウを除く、全ウィンドウの番号と名前
.IP y
年 (下二桁)
.IP Y
年 (全表示)
.IP ?
次の '%?' までの部分が表示される。
ただしその内部の '%' エスケープが空でない文字列に展開される場合に限られる。
.IP :
'%?' の else 部
.IP =
(TeX の hfill のように) ディスプレイの幅に合わせて文字埋めをする。
数値を指定すると、ウィンドウ幅のそのパーセント分を埋める。
限定詞 '0' をつけると、screen はその数値を絶対位置として扱う。
直前に指定された絶対位置から相対的な文字埋めをするには、
限定詞 '+' を付ける。また相対的な右マージンを文字埋めするには
限定詞 '-' を付ける。文字埋め動作では、
指定位置が現在位置よりも前にあると、文字列を切り捨てて短縮する。
これを変更するには限定詞 'L' を加える。
.IP <
'%=' と同様だが、切り捨てのみを行い、スペースによる埋めを行わない。
.IP >
現在のテキスト位置を、次回の文字列短縮用にマークする。
短縮が必要になると、screen はこのマークした位置を
出力領域の指定パーセントの位置に移動することによって、
文字列を短縮しようとする
(この領域は、直前の絶対文字埋め位置から文字列短縮演算子で指定した位置まで)。
限定詞 'L' をつけると、screen は切り捨て部を '...' で示すようになる。
.IP {
次の \*Q}\*U の間にある文字列の属性/色を変更する。
.IP `
'backtick' コマンドの結果を代入する。
ここでは長さ限定詞がコマンドの特定に用いられる (本来は誤用だが)。
.P
\(aqc' と 'C' の各エスケープには限定詞 '0' をつけることができ、
この場合
.I screen
は埋め文字としてスペースではなくゼロを用いる。
限定詞 '0' は '=' エスケープにも付き、
その場合は絶対位置指定を用いさせる。'n' と '=' の各エスケープは長さ限定詞
(例えば '%3n') を理解し、'D' と 'M' は前に 'L'
を付けると長い名前になる。'w' と 'W' は 'L'
を付けるとウィンドウのフラグも同時に表示する。
.PP
.\"nakano is is
属性/色指定は、これらの設定を変更するために用いる。
書式は \*Q[属性指定] [色定義]\+U である。
属性指定と色定義とが混乱しそうな場合には、
属性指定の前に変更タイプの指定をつけなければならない。
変更タイプとしては次のものが利用できる:
.IP +
現在の属性に指定セットを追加する
.IP -
現在の属性から指定セットを削除する
.IP !
現在の属性において、指定セットを反転させる
.IP =
現在の属性を、指定セットに変更する
.PP
属性のセットは 16 進の数値か、次に示す文字の組で指定できる:
.IP d
暗くする (dim)
.PD 0
.IP u
アンダーライン
.IP b
ボールド
.IP r
リバース
.IP s
強調 (standout)
.IP B
ブリンク
.PD
.PP
色は 16 進数か、あるいは背景色と前景色を示す 2 つの文字 (背景、前景の順)
で指定する。次の色がある:
.IP k
ブラック
.PD 0
.IP r
レッド
.IP g
グリーン
.IP y
イエロー
.IP b
ブルー
.IP m
マゼンダ
.IP c
シアン
.IP w
ホワイト
.IP d
デフォルト色
.IP .
色を変更しない
.PD
.PP
これらの大文字版は明るい色になる。
疑似色として 'i' を指定でき、この場合は色はそのままで明るさだけを変更できる。
.PP
数値にせよ文字にせよ、一色だけを指定した場合に、
それが前景色として扱われるか背景色になるかは、
現在の属性に依存する。リバースが設定されていると、
前景色ではなく背景色が変更される。
これが嫌なら、色の前に \*Q.\*U を付ければ良い。
2 文字の色記述においても同様の動作をさせたければ、
同じくそれらの前に \*Q.\*U を付ければ良い。
.PP
特殊ケースとして、\*Q%{-}\*U は直前に変更された属性と色とを復元する
(すなわち色変更のスタックを 1 レベル pop する)。
.PP
例：
.IP "\*QG\*U"
明るいグリーン
.IP "\*Q+b r\*U"
ボールドのレッド
.IP "\*Q= yd\*U"
全属性をクリア、イエローの背景にデフォルト色で書く。
.IP "%-Lw%{= BW}%50>%n%f* %t%{-}%+Lw%<"
現在のウィンドウを中心として、利用できるウィンドウを、
現在の幅に表示できるだけ表示する。
現在のウィンドウはブルーの背景にホワイトで書かれる。
これは \*Qhardstatus alwayslastline\*U と一緒に使える。
.IP "%?%F%{.R.}%?%3n %t%? [%h]%?"
ウィンドウの番号・タイトル・ハードステータス (設定されている場合)。
また、これがフォーカスされている場合は背景を赤にする。
\*Qcaption string\*U に便利。

.SH フロー制御
各ウィンドウにはフロー制御の設定があり、
.I screen
はこれを基に、XON 文字と XOFF 文字 (およびおそらく割り込み文字)
の扱い方を決める。フロー制御が無効になっていると、
.I screen
は XON 文字と XOFF 文字を無視する。この場合、ユーザは単に入力するだけで
これらの文字を実行中のプログラムに送れる
(例えば、\fIemacs\fP エディタ等ではこの設定が便利である)。
その代わり、\*Q普通\*Uのプログラムからの出力が、
XOFF に応答して一時停止するまでに、より長い時間がかかる。
フロー制御が有効になっていると、XON 文字と XOFF 文字を使って、
現在のウィンドウの出力を即座に停止できる。
この場合でも、XON 文字や XOFF 文字を実行中プログラムへ送信することはできるが、
これにはそれぞれに対応する
.I screen
の 2 文字コマンドを使わなければならない
(普通は \*QC-a q\*U (xon) と \*QC-a s\*U (xoff))。
xon/xoff コマンドは、C-s と C-q を横取りしてしまうような端末越しに、
これらの文字を入力する場合にも役立つ。
.PP
各ウィンドウはフロー制御に関する初期値を持ち、これは
.B \-f
オプションまたは .screenrc コマンドの \*Qdefflow\*U で設定できる。
デフォルトでは、各ウィンドウには自動フロー切り替えが設定される。
この値は、\*Qflow\*U コマンド ("C-a f" に割り当てられている)
を用いると、'fixed on', 'fixed off', 'automatic' の 3 つの状態に、
順々にトグルできる。
.PP
自動フロー切り替えモードは (\*Qrlogin\*U のように) TIOCPKT
モードを用いてフロー制御を扱う。
tty ドライバが TIOCPKT をサポートしていない場合、
.I screen
はアプリケーションテンキーの現在の状態に基づいて
正しいモードを見つけようとする。
つまり、テンキーがアプリケーションモードならフロー制御無効、およびその逆、
である。もちろん、必要ならば手動でフロー制御を操作することもできる。
.PP
フロー制御を有効にしているにもかかわらず、
割り込みキー (通常は C-c) を押してから表示に割り込みがかかるまでに
6-8 行スクロールしてしまうような場合には、\*Qinterrupt\*U オプションを与えて
.I screen
を起動してみること
(.screenrc で \*Qflow\*U コマンドに \*Qinterrupt\*U 
フラグを追加するか、コマンドラインオプションの
.B \-i
を用いる)。
こうすると、割り込みを受けたプログラムから
.I screen
が受け取って蓄積していた出力はフラッシュされるようになる。
これによる不都合は、仮想端末のメモリが非フラッシュ出力を含むことであり、
これによって、まれに出力に多少不正確な部分が現れるかもしれない。
例えば画面の切り替えと復帰を行ったり、
\*QC-a l\*U を使って画面の更新を行うと、
\*Qinterrupt\*U をオンにしていなかった場合に得られたはずの出力が得られる。
また、割り込み文字を入力として期待するプログラムを実行する際には、
フロー制御を無効にする
(あるいは自動フロー制御を用いてこれを自動的に無効にする)
必要があるかもしれない。なぜなら、フロー制御が有効だと、
仮想端末から物理端末への出力に割り込みがかかることがあり得るからである。
このようになった場合も、\*QC-a l\*U を行って画面をリフレッシュしさえすれば、
元に戻るはずである。各モードを試してみて、
一番都合が良いと思ったものを使うとよいだろう。

.SH "タイトル (ウィンドウの命名)"
ウィンドウ表示に現れる各ウィンドウの名前
(\*Qwindows\*U コマンド (C-a w) で表示される) は、
title コマンドのどれかを用いればカスタマイズできる。
通常この名前は、そのウィンドウで生成されるプログラムの実際のコマンド名になる。
しかし、同じ名前の複数のプログラムを区別したり、
ウィンドウの現在の状態をその場で名前に反映させたりできれば、
便利な場合もあるだろう。
.PP
すべてのシェルウィンドウに対するデフォルト名は .screenrc ファイルの
\*Qshelltitle\*U コマンドで設定できる。
一方、他のウィンドウはすべて \*Qscreen\*U コマンドで生成されるので、
.B \-t
オプションを使えば名前を設定できる。
対話的に行うには、タイトル文字列用エスケープシーケンス
(<esc>k\fIname\fP<esc>\e)と \*Qtitle\*U コマンド(C-a A)がある。
前者をアプリケーションから出力させれば、
ソフトウェア制御でウィンドウの名前を変更できる。
後者は名前の入力をユーザに求める。
定義済みの名前を \*Qtitle\*U コマンドのキーに割り当てておいて、
入力なしに即座に設定を行わせることもできる。
.PP
最後に、
.I screen
にはシェルの場合にのみ使われるヒューリスティックなタイトル指定方法がある。
これを実現するには、ウィンドウの名前を \*Q\fIsearch|name\fP\*U に設定し、
プロンプトの一部で空の title エスケープシーケンスが出力されるようにする。
\fIsearch\fP の部分には「プロンプト末尾」の検索文字列を指定し、
\fIname\fP の部分にはそのウィンドウのデフォルトのシェル名を指定する。
\fIname\fP が `:' で終わる場合、
.I screen
は、そのウィンドウで現在実行中のコマンドと認識しているものを
ウィンドウのシェル名の最後に追加する (例えば \*Q\fIname:cmd\fP\*U)。
それ以外の場合には、コマンドの実行中にはそのコマンド名がシェル名を上書きする。
.PP
以下にその動作を示す: ユーザはシェルのプロンプトを変更して、
空の title エスケープシーケンス (<esc>k<esc>\e) がプロンプトの一部に
出力されるようにしなければならない。プロンプトの末尾は、
タイトルの \fIsearch\fP 部分に指定した文字列と同じでなければならない。
このようにすると、
.I screen
はタイトルエスケープシーケンスを使って以前のコマンド名をクリアし、
次のコマンドのための準備を行う。
次に、シェルから改行文字を受け取ると、プロンプトの末尾を検索する。
検索にマッチする部分が見つかると、
マッチした文字列の後ろの最初の単語が取り出され、
これがコマンド名として使われる。
コマンド名が '!', '%', '^' のいずれかで始まる場合、
.I screen
は次の行に出てくる最初の単語を (もし見つかれば)
いま見つかった名前よりも優先する。
これにより、csh ユーザがジョブ制御や履歴の再呼び出しコマンドを使ったときでも、
まともなコマンド名を取得できる。
.PP
以下に .screenrc での指定例をいくつか示す:
.IP
screen -t top 2 nice top
.PP
この行を .screenrc に追加すると、
nice コマンドでプライオリティを設定した \*Qtop\*U コマンドが、
ウィンドウ 2 において (\*Qnice\*U ではなく) \*Qtop\*U という名前で起動する。
.sp
.nf
	shelltitle '> |csh'
	screen 1
.fi
.sp
このコマンドでは、与えられた shelltitle を持つシェルが起動される。
指定されたタイトルは自動設定タイトルであり、
次のような形のプロンプト+コマンド入力を監視する:
.IP
/usr/joe/src/dir> trn
.PP
('> ' の後の部分がコマンド名として扱われる)。
このコマンドの実行中には、
ウィンドウのステータスには \*Qtrn\*U という名前が表示され、
実行が終了するとこれは \*Qcsh\*U に戻る。
.IP
bind R screen -t '% |root:' su
.PP
このコマンドが .screenrc に書かれていると、キーシーケンス
\*QC-a R\*U に対して \*Qsu\*U コマンドが割り当てられ、
自動設定タイトル名として \*Qroot:\*U が与えられる。
この自動タイトル設定が動作するのは、
screen には以下のような表示が渡った場合である:
.sp
.nf
	% !em
	emacs file.c
.fi
.sp
ここでは、ユーザは csh の履歴コマンド \*Q!em\*U を入力している。
これは以前に入力した \*Qemacs\*U コマンドを実行するものである。
このコマンドの実行中には、ウィンドウのステータスには \*Qroot:emacs\*U 
が表示され、実行の終了時には \*Qroot:\*U だけの表示に戻る。
.PP
.nf
	bind o title
	bind E title ""
	bind u title (unknown)
.fi
.sp
最初の割り当てには全く引き数がないので、
ユーザに対してタイトルの問い合わせが行われる(\*QC-a o\*U を入力した時と同様)。
2 番目の割り当ては現在の自動タイトル設定をクリアする(C-a E)。
3 番目の割り当ては現在のウィンドウのタイトルに \*Q(unknown)\*U を設定する
(C-a u)。
.PP
空の title エスケープシーケンスをプロンプトに追加する際に注意すべきなのは、
一部のシェル (csh など) では、
.\"nakano 原文 non- だと logic がおかしい？
制御文字などもすべてプロンプトの長さに数え入れる点である。
このような表示されない文字の数が 8 の倍数でないと、
バックスペースでタブを消した時の表示がおかしくなる。
これを回避する方法の 1 つは、以下のようなプロンプトを使うことである:
.IP
set prompt='^[[0000m^[k^[\e% '
.PP
エスケープシーケンス \*Q<esc>[0000m\*U は文字の属性を統一するだけでなく、
表示されない文字の長さを 0 を使って 8 個に合わせる。
bash ユーザは多分、PROMPT_COMMAND 中で
エスケープシーケンスを出力するのがよいだろう:
.IP
PROMPT_COMMAND='echo -n -e "\e033k\e033\e134"'
.PP
(bash バージョン 1.04 のバグを回避するため、
筆者は \*Q\134\*U を使って `\e' を出力している)

.SH 仮想端末
.I screen
セッションの各ウィンドウは VT100 端末をエミュートしており、
いくつかの機能も追加されている。
VT100 エミュレータはハードコーディングされており、
他の種類の端末をエミュレートすることはできない。
.PP
通常
.I screen
はできる限り VT100/ANSI 標準をエミュレートしようとする。
しかし端末が特定の機能を持っていない場合には、
エミュレーションが完全でないこともある。このような場合、
.I screen
は一部の機能が欠けていることをアプリケーションに伝えなければならない。
これは termcap を使っているマシンでは問題にはならない。なぜなら、
.I screen
は $TERMCAP 変数を使って標準の
.I screen
termcap をカスタマイズできるからである。
.PP
しかし、別のマシンに rlogin した時や、
使っているマシンが terminfo しかサポートしていない場合には、
この方法はうまくいかない。そのため
.I screen
にはこのような場合を扱う手段が用意されている。
その動作を以下に示す:
.PP
.I screen
は自力で端末名を調べようとする時、まず \*Qscreen.<term>\*U
という名前のエントリを参照する。ここで <term> は $TERM 変数の内容である。
このようなエントリが存在しないと、
.I screen
は \*Qscreen\*U
(あるいは端末の幅が広ければ (132 カラム以上) \*Qscreen-w\*U)
を試す。このエントリも見つからない場合には、
代わりに \*Qvt100\*U を使う。
.PP
つまり、重要な機能 (例えば文字削除や EOS までのクリア)
をサポートしていない端末を使っている場合でも、
これらの機能を無効にした (\*Qscreen.<dumbterm>\*U という名前の)
新しい
.I screen
用 termcap/terminfo エントリをビルドすれば良い、という考え方である。
使うマシンにこのエントリをインストールすれば、
rlogin の際にも正しい termcap/terminfo エントリを維持できる。
端末名はすべての新規ウィンドウの $TERM 変数に設定される。
.I screen
はエミュレートしている仮想端末の機能を反映させた $TERMCAP も設定する。
ただし、terminfo データベースを使っているマシンには
この変数は効果がないことに注意。
さらに、変数 $WINDOW には各ウィンドウのウィンドウ番号が設定される。
.PP
仮想端末が実際にサポートしている機能のセットは、
物理端末がサポートしている機能に依存する。
そのため、もし例えば、物理端末が下線モードをサポートしていなければ、
.I screen
は `us' や `ue' 機能をそのウィンドウの $TERMCAP 変数に設定しない。しかし、
.I screen
を実行するために、端末が最低限サポートしていなければならない機能
がいくつか存在する。
例えば、スクロール機能、画面クリア、カーソル位置の直接指定などである
(さらに、
.I screen
はハードコピー端末や、文字の重ね打ちを行う端末では動作しない)。
.PP
.\"nakano たぶん "the latter is defined" のまちがい。
また、ユーザは .screenrc で \*Qtermcap\*U コマンドを用いたり、
起動前に変数 $SCREENCAP を定義することにより、
.I screen
が用いる $TERMCAP の値をカスタマイズできる。
後者が定義されていると、その値がそのままの形で各ウィンドウの
$TERMCAP 変数にコピーされる。
これは端末の完全な定義、または端末 \*Qscreen\*U
(や \*Qscreen-w\*U)
が定義されているファイル名、のいずれかである。
.PP
システムが termcap でなく terminfo データベースを用いている場合には、
.I screen
は .screenrc コマンドの \*Qterminfo\*U に従う点に注意すること。
.PP
.I screen
が呼び出された端末の termcap エントリ中に、
ブール値の `G0' 機能があると、
.I screen
の端末エミュレーションは複数の文字集合をサポートする。
これによりアプリケーションは、例えば、
VT100 のグラフィックス文字集合や特定の国の文字集合を利用できる。
ISO 2022 に含まれるものとしては、以下の制御機能がサポートされている:
\fIロックシフト G0\fP (\fISI\fP), \fIロックシフト G1\fP (\fISO\fP),
\fIロックシフト G2\fP, \fIロックシフト G3\fP, \fIシングルシフト G2\fP,
\fIシングルシフト G3\fP。
仮想端末の生成時やリセット時には、ASCII 文字集合が \fIG0\fP から 
\fIG3\fP までに指定される。`G0' 機能が存在すれば、
.I screen
は `S0', `E0', `C0' 機能を (存在すれば) 評価する。
`S0' は、(\fISI\fP の代わりに) グラフィックス文字集合を有効にし、
開始するために端末が用いるシーケンスである。
`E0' はこれに対応して \fISO\fP の代わりに使うシーケンスである。
`C0' は、セミグラフィックスモード時に使われる、文字ごとの変換文字列を与える。
この文字列は `acsc' terminfo エントリのように構築されている。
.PP
`po' 機能と `pf' 機能が端末の termcap エントリに存在すると、
.I screen
のウィンドウ内で実行されているアプリケーションは、
出力を端末のプリンタポートに送信できる。
これを使うと、ユーザは端末に接続されているプリンタに対し、
ウィンドウのアプリケーションの出力を送信できる。
この際にも、他のウィンドウはすべてアクティブなままである
(ひとまとまりの出力ごとにプリンタポートは繰り返し有効/無効にされる)。
この副作用として、別のウィンドウで動作しているプログラムも、
同時に出力をプリンタに送信できてしまう。
プリンタに送られたデータはウィンドウには表示されない。
.I info
コマンドは、プリンタがアクティブな時には行の先頭に `PRIN' を表示する。
.PP
.I screen
はウィンドウごとにハードステータス行を管理する。
あるウィンドウが選択されると、
ディスプレイのハードステータスはそのウィンドウの
ハードステータス行に一致するよう更新される。
ディスプレイにハードステータスがなければ、
この行は screen の標準メッセージとして表示される。
ハードステータス行は
ANSI のアプリケーションプログラムコマンド
(Application Program Command, APC) である \*QESC_<string>ESC\e\*U
で変更できる。xterm ユーザに便利なように、
\*QESC]0..2;<string>^G\*U というシーケンスも使えるようになっている。
.PP
一部の機能は、それらが物理端末でちゃんと実装できている場合に限り、
仮想端末の $TERMCAP に設定される。例えば `dl' (行の削除)は、
端末が行削除または領域のスクロールのどちらかをサポートしている場合にのみ
$TERMCAP 変数に設定される。セッションを別の端末から再アタッチした時には、
これが混乱の元になりやすいので注意すること。
$TERMCAP の値は親プロセスからは変更できないからである。
.PP
「別画面 (alternate screen)」機能はデフォルトでは有効になっていない。
有効にするには .screenrc コマンド \fBaltscreen\fP をセットすること。
.PP
.I screen
が認識する制御シーケンスの一覧を以下に示す。
\*Q(V)\*U は VT100 固有の機能であることを示し、
\*Q(A)\*U は ANSI または ISO 固有の機能であることを示す。
.PP
.ta 22n
.TP 27
.B "ESC E"
次の行
.TP 27
.B "ESC D"
インデックス
.TP 27
.B "ESC M"
逆順のインデックス
.TP 27
.B "ESC H"
水平タブセット
.TP 27
.B "ESC Z"
VT100 の識別文字列を送る
.TP 27
.BR "ESC 7" "	(V)"
カーソルと属性を保存する
.TP 27
.BR "ESC 8" "	(V)"
カーソルと属性を復元する
.TP 27
.BR "ESC [s" "	(A)"
カーソルと属性を保存する
.TP 27
.BR "ESC [u" "	(A)"
カーソルと属性を復元する
.TP 27
.B "ESC c"
初期状態へのリセット
.TP 27
.B "ESC g"
可視ベル
.TP 27
.B "ESC \fPPn\fB p"
カーソルの可視制御 (97801)
.TP 27
\h'\w'ESC 'u'Pn = \fB6\fP
不可視
.TP 27
\h'\w'ESC Pn = 'u'\fB7\fP
可視
.TP 27
.BR "ESC =" "	(V)"
アプリケーションキーパッドモード
.TP 27
.BR "ESC >" "	(V)"
数値キーパッドモード
.TP 27
.BR "ESC # 8" "	(V)"
画面を E で埋める
.TP 27
.BR "ESC \e" "	(A)"
文字列の終端子
.TP 27
.BR "ESC ^" "	(A)"
プライベートなメッセージ文字列 (メッセージ行)
.TP 27
.B "ESC !"
グローバルなメッセージ文字列 (メッセージ行)
.TP 27
.B "ESC k"
定義文字列の別名
.TP 27
.BR "ESC P" "	(A)"
デバイス制御文字列。文字列を、解釈せず、直接ホストの端末に出力する。
.TP 27
.BR "ESC _" "	(A)"
アプリケーションプログラムコマンド (ハードステータス)
.TP 27
.BR "ESC ] 0 ; string ^G" "	(A)"
オペレーティングシステムのコマンド
(ハードステータス、xterm のタイトルのハック)
.TP 27
.BR "ESC ] 83 ; cmd ^G" "	(A)"
screen コマンドを実行する。
これは screen にマルチユーザのサポートが組み込まれている場合にのみ動作する。
アクセスコントロールリストのチェックには、疑似ユーザ \*Q:window:\*U
が用いられる。権限を持たず、
必要なコマンドだけを実行できるようなユーザを作るには、
\*Qaddacl :window: -rwx #?\*U を用いること。
.TP 27
.BR "Control-N" "	(A)"
ロックシフト G1 (SO)
.TP 27
.BR "Control-O" "	(A)"
ロックシフト G0 (SI)
.TP 27
.BR "ESC n" "	(A)"
ロックシフト G2
.TP 27
.BR "ESC o" "	(A)"
ロックシフト G3
.TP 27
.BR "ESC N" "	(A)"
シングルシフト G2
.TP 27
.BR "ESC O" "	(A)"
シングルシフト G3
.TP 27
.BR "ESC ( \fPPcs" "	(A)"
文字集合として G0 を指定
.TP 27
.BR "ESC ) \fPPcs" "	(A)"
文字集合として G1 を指定
.TP 27
.BR "ESC * \fPPcs" "	(A)"
文字集合として G2 を指定
.TP 27
.BR "ESC + \fPPcs" "	(A)"
文字集合として G3 を指定
.TP 27
.B "ESC [ \fPPn\fB ; \fPPn\fB H"
カーソルの位置の直接指定
.TP 27
.B "ESC [ \fPPn\fB ; \fPPn\fB f"
カーソルの位置の直接指定
.TP 27
.B "ESC [ \fPPn\fB J"
ディスプレイの中での削除
.TP 27
\h'\w'ESC [ 'u'Pn = None または \fB0\fP
カーソル位置からスクリーン末尾まで
.TP 27
\h'\w'ESC [ Pn = 'u'\fB1\fP
スクリーン先頭からカーソル位置まで
.TP 27
\h'\w'ESC [ Pn = 'u'\fB2\fP
スクリーン全体
.TP 27
.B "ESC [ \fPPn\fB K"
行の中での削除
.TP 27
\h'\w'ESC [ 'u'Pn = None or \fB0\fP
カーソル位置から行末まで
.TP 27
\h'\w'ESC [ Pn = 'u'\fB1\fP
行頭からカーソル位置まで
.TP 27
\h'\w'ESC [ Pn = 'u'\fB2\fP
行全体
.TP 27
.B "ESC [ \fPPn\fB X"
文字削除
.TP 27
.B "ESC [ \fPPn\fB A"
カーソルを上に移動
.TP 27
.B "ESC [ \fPPn\fB B"
カーソルを下に移動
.TP 27
.B "ESC [ \fPPn\fB C"
カーソルを右に移動
.TP 27
.B "ESC [ \fPPn\fB D"
カーソルを左に移動
.TP 27
.B "ESC [ \fPPn\fB E"
カーソルを次の行へ移動
.TP 27
.B "ESC [ \fPPn\fB F"
カーソルを前の行へ移動
.TP 27
.B "ESC [ \fPPn\fB G"
カーソルを水平位置へ
.\"nakano 要調査
.TP 27
.B "ESC [ \fPPn\fB `"
カーソルを水平位置へ
.TP 27
.B "ESC [ \fPPn\fB d"
カーソルを垂直位置へ
.TP 27
.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB m"
グラフィックスの解釈を選択
.TP 27
\h'\w'ESC [ 'u'Ps = None or \fB0\fP
デフォルトの解釈を行う
.TP 27
\h'\w'ESC [ Ps = 'u'\fB1\fP
ボールド
.TP 27
\h'\w'ESC [ Ps = 'u'\fB2\fP	(A)
薄い色で描画
.TP 27
\h'\w'ESC [ Ps = 'u'\fB3\fP	(A)
\fI強調\fPモード (ANSI ではイタリック表示)
.TP 27
\h'\w'ESC [ Ps = 'u'\fB4\fP
アンダーラインを引く
.TP 27
\h'\w'ESC [ Ps = 'u'\fB5\fP
ブリンクさせる
.TP 27
\h'\w'ESC [ Ps = 'u'\fB7\fP
イメージを反転させる
.TP 27
\h'\w'ESC [ Ps = 'u'\fB22\fP	(A)
通常の明度
.TP 27
\h'\w'ESC [ Ps = 'u'\fB23\fP	(A)
\fI強調\fP モードをオフにする (ANSI: イタリック化のオフ)
.TP 27
\h'\w'ESC [ Ps = 'u'\fB24\fP	(A)
アンダーラインを引かない
.TP 27
\h'\w'ESC [ Ps = 'u'\fB25\fP	(A)
ブリンクしない
.TP 27
\h'\w'ESC [ Ps = 'u'\fB27\fP	(A)
ポジティブ (反転していない) イメージ
.TP 27
\h'\w'ESC [ Ps = 'u'\fB30\fP	(A)
前景色をブラックにする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB31\fP	(A)
前景色をレッドにする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB32\fP	(A)
前景色をグリーンにする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB33\fP	(A)
前景色をイエローにする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB34\fP	(A)
前景色をブルーにする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB35\fP	(A)
前景色をマゼンダにする
.TP 27.
\h'\w'ESC [ Ps = 'u'\fB36\fP	(A)
前景色をシアンにする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB37\fP	(A)
前景色をホワイトにする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB39\fP	(A)
前景色をデフォルト色にする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB40\fP	(A)
背景色をブラックにする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB...\fP
...
.TP 27
\h'\w'ESC [ Ps = 'u'\fB49\fP	(A)
背景色をデフォルト色にする
.TP 27
.B "ESC [ \fPPn\fB g"
タブクリア
.TP 27
\h'\w'ESC [ 'u'Pn = None or \fB0\fP
現在位置のタブをクリアする
.TP 27
\h'\w'ESC [ Ps = 'u'\fB3\fP
すべてのタブをクリアする
.TP 27
.BR "ESC [ \fPPn\fB ; \fPPn\fB r" "	(V)"
スクロール領域を設定する
.TP 27
.BR "ESC [ \fPPn\fB I" "	(A)"
水平タブ
.TP 27
.BR "ESC [ \fPPn\fB Z" "	(A)"
後方タブ
.TP 27
.BR "ESC [ \fPPn\fB L" "	(A)"
行を挿入する
.TP 27
.BR "ESC [ \fPPn\fB M" "	(A)"
行を削除する
.TP 27
.BR "ESC [ \fPPn\fB @" "	(A)"
文字を挿入する
.TP 27
.BR "ESC [ \fPPn\fB P" "	(A)"
文字を削除する
.TP 27
.B "ESC [ \fPPn\fB S"
スクロール領域を上にスクロールする
.TP 27
.B "ESC [ \fPPn\fB T"
スクロール領域を下にスクロールする
.TP 27
.B "ESC [ \fPPn\fB ^"
スクロール領域を下にスクロールする
.TP 27
.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB h"
モード設定
.TP 27
.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB l"
モード解除
.TP 27
\h'\w'ESC [ 'u'Ps = \fB4\fP	(A)
挿入モード
.TP 27
\h'\w'ESC [ Ps = 'u'\fB20\fP	(A)
\fI自動ラインフィード\fPモード
.TP 27
\h'\w'ESC [ Ps = 'u'\fB34\fP
通常のカーソル表示
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?1\fP	(V)
アプリケーションカーソルキー
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?3\fP	(V)
端末の幅を 132 カラムに変更
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?5\fP	(V)
ビデオ反転
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?6\fP	(V)
\fIオリジン (origin)\fP モード
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?7\fP	(V)
\fI折り返し (wrap)\fP モード
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?9\fP
X10 マウス追跡
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?25\fP	(V)
可視カーソル
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?47\fP
別画面 (古い xterm コード)
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?1000\fP	(V)
VT200 マウス追跡
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?1047\fP
別画面 (新しい xterm コード)
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?1049\fP
別画面 (新しい xterm コード)
.TP 27
.BR "ESC [ 5 i" "	(A)"
プリンタへの転送を開始する (ANSI の Media Copy シーケンス)
.TP 27
.BR "ESC [ 4 i" "	(A)"
プリンタへの転送を止める (ANSI の Media Copy シーケンス)
.TP 27
.B "ESC [ 8 ; \fPPh\fB ; \fPPw\fB t"
ウィンドウを `Ph' 行、`Pw' カラムにリサイズする
(SunView 用の特別シーケンス)
.TP 27
.B "ESC [ c"
VT100 識別文字列を送る
.TP 27
.B "ESC [ x"
端末パラメータ報告を送る
.TP 27
.B "ESC [ > c"
VT220 のセカンダリデバイス属性文字列を送る
.TP 27
.B "ESC [ 6 n"
カーソル位置の報告を送る

.SH 入力の変換
VT100 のエミュレーションを完全に行うには、
\fIscreen\fP はユーザのキー入力によって生成される入力ストリーム中から
文字シーケンスを検出して、
VT100 形式のエスケープシーケンスを挿入しなければならない。
\fIscreen\fP では、任意のコマンドを任意の文字シーケンスへ
割り当てることが可能であり、この動作を非常に柔軟に行える。
標準の VT100 エミュレーションの場合、
コマンドは常にウィンドウの入力バッファに文字列を挿入する
(コマンド表の \fBstuff\fP コマンドも参照すること)。
キー入力によって生成されるシーケンスは、
異なるタイプの端末から再アタッチした後には変わることもあるので、
キーの termcap 名にコマンドを割り当てることもできるようになっている。
これにより \fIscreen\fP は再アタッチの後でも必ず正しい割り当てを挿入できる。
詳しい文法と使用例については \fBbindkey\fP コマンドを参照すること。
.PP
以下にデフォルトのキー割り当ての表を示す。(A) はキーボードが
アプリケーションモードに切り替えられている場合に
実行されるコマンドであることを示す。
.PP
.ta 18n 34n 50n
.nf
キーの名前	termcap 名	コマンド
\l'54n'
.ta 22n 34n 50n
カーソルキー上	ku	stuff \e033[A
		stuff \e033OA	(A)
カーソルキー下	kd	stuff \e033[B
		stuff \e033OB	(A)
カーソルキー右	kr	stuff \e033[C
		stuff \e033OC	(A)
カーソルキー左	kl	stuff \e033[D
		stuff \e033OD	(A)
ファンクションキー 0	k0	stuff \e033[10~
ファンクションキー 1	k1	stuff \e033OP
ファンクションキー 2	k2	stuff \e033OQ
ファンクションキー 3	k3	stuff \e033OR
ファンクションキー 4	k4	stuff \e033OS
ファンクションキー 5	k5	stuff \e033[15~
ファンクションキー 6	k6	stuff \e033[17~
ファンクションキー 7	k7	stuff \e033[18~
ファンクションキー 8	k8	stuff \e033[19~
ファンクションキー 9	k9	stuff \e033[20~
ファンクションキー 10	k;	stuff \e033[21~
ファンクションキー 11	F1	stuff \e033[22~
ファンクションキー 12	F2	stuff \e033[23~
Home	kh	stuff \e033[1~
End	kH	stuff \e033[4~
Insert	kI	stuff \e033[2~
Delete	kD	stuff \e033[3~
Page up	kP	stuff \e033[5~
Page down	kN	stuff \e033[6~
テンキー 0	f0	stuff 0
		stuff \e033Op	(A)
テンキー 1	f1	stuff 1
		stuff \e033Oq	(A)
テンキー 2	f2	stuff 2
		stuff \e033Or	(A)
テンキー 3	f3	stuff 3
		stuff \e033Os	(A)
テンキー 4	f4	stuff 4
		stuff \e033Ot	(A)
テンキー 5	f5	stuff 5
		stuff \e033Ou	(A)
テンキー 6	f6	stuff 6
		stuff \e033Ov	(A)
テンキー 7	f7	stuff 7
		stuff \e033Ow	(A)
テンキー 8	f8	stuff 8
		stuff \e033Ox	(A)
テンキー 9	f9	stuff 9
		stuff \e033Oy	(A)
テンキー +	f+	stuff +
		stuff \e033Ok	(A)
テンキー -	f-	stuff -
		stuff \e033Om	(A)
テンキー *	f*	stuff *
		stuff \e033Oj	(A)
テンキー /	f/	stuff /
		stuff \e033Oo	(A)
テンキー =	fq	stuff =
		stuff \e033OX	(A)
テンキー .	f.	stuff .
		stuff \e033On	(A)
テンキー ,	f,	stuff ,
		stuff \e033Ol	(A)
テンキー Enter	fe	stuff \e015
		stuff \e033OM	(A)
.fi

.SH 特殊な端末機能
以下の表では、\fIscreen\fP は認識するが、
.BR termcap (5)
のマニュアルには含まれていない端末機能をすべて示す。
これらの機能は (`/etc/termcap' の) termcap エントリに置いたり、
screenrc ファイルの `termcap', `terminfo', `termcapinfo' コマンドで
使える。これらの機能を terminfo データベースには入れるのは、
不可能な場合が多い。
.PP
.ta 5n
.TP 13
.BI LP "	(bool)"
端末は VT100 形式のマージン (`magic マージン') を持つ。
\fIscreen\fP は標準の 'xn' の方を使うようになったので、
この機能は obsolete になった。
.TP 13
.BI Z0 "	(str)"
幅を 132 カラムに変更する。
.TP 13
.BI Z1 "	(str)"
幅を 80 カラムに変更する。
.TP 13
.BI WS "	(str)"
ディスプレイをリサイズする。
この機能は指定する幅と高さを引き数に取る。
\fISunView(tm)\fP における指定例: '\eE[8;%d;%dt'
.TP 13
.BI NF "	(bool)"
端末はフロー制御を必要としない。
アプリケーションに直接 ^S と ^Q を送信する。'flow off' と同じ意味である。
この反対の機能は 'nx' である。
.TP 13
.BI G0 "	(bool)"
端末は ISO 2022 のフォント選択シーケンスを使用できる。
.TP 13
.BI S0 "	(str)"
文字集合 'G0' を指定した文字集合に切り替える。
デフォルト値は '\eE(%.' である。
.TP 13
.BI E0 "	(str)"
文字集合 'G0' を標準の文字集合に戻す。デフォルト値は '\eE(B' である。
.TP 13
.BI C0 "	(str)"
文字列をフォント '0' の変換テーブルとして使用する。
詳しくは 'ac' 機能を参照すること。
.TP 13
.BI CS "	(str)"
カーソルキーをアプリケーションモードに切り替える。
.TP 13
.BI CE "	(str)"
カーソルキーを通常モードに戻す。
.TP 13
.BI AN "	(bool)"
autonuke をオンにする。詳しくは 'autonuke' コマンドを参照すること。
.TP 13
.BI OL "	(num)"
出力バッファの上限値を設定する。詳しくは 'obuflimit' コマンドを参照すること。
.TP 13
.BI KJ "	(str)"
端末で使う漢字の種類を設定する。有効な文字列は 'encoding'
コマンドの解説を参照すること。
.TP 13
.BI AF "	(str)"
ANSI 準拠の方法で文字の前景色を変更する。この機能はほぼ常に '\eE[3%dm'
(terminfo を使うマシンでは '\eE[3%p1%dm') に設定される。
.TP 13
.BI AB "	(str)"
これは 'AF' と同様だが、背景色を変更する。
.TP 13
.BI AX "	(bool)"
ANSI セットのデフォルトの前景色/背景色 (\eE[39m / \eE[49m) を認識する。
.TP 13
.BI XC "	(str)"
現在のフォントに基づく、複数個の文字から文字列への変換を記述する。
詳細は次の節に書く。
.TP 13
.BI XT "	(bool)"
端末は xterm の特殊シーケンス (OSC, マウス追跡) を理解する。
.TP 13
.BI C8 "	(bool)"
端末は、高輝度色の表示にボールドを必要とする (例 Eterm)。
.TP 13
.BI TF "	(bool)"
欠けている機能を termcap/terminfo のエントリに追加する
(デフォルトで設定されている)。

.SH 文字の変換
\fIscreen\fP には、現在のフォントや端末の種類に基づいて、
文字(列)を任意の文字列に変換する強力な機構がある。
この機能を用いれば、あまり使わない文字群が
いろいろな国・言語のフォントページに散っているような端末でも、
通常の標準的な文字集合 (例えば ISO8851-latin1) を使える。
.sp
文法:
.nf
    \fBXC=\fP\fI<charset-mapping>\fP{\fB,,\fP\fI<charset-mapping>\fP}
    \fI<charset-mapping>\fP := \fI<designator><template>\fP{\fB,\fP\fI<mapping>\fP}
    \fI<mapping>\fP := \fI<char-to-be-mapped><template-arg>\fP
.fi
.sp
ブレース内のものは任意の数だけ指定できる。
.PP
\fI<charset-mapping>\fP は、フォント指示子 \fI<designator>\fP
('B': ASCII, 'A': イギリス語, 'K': ドイツ語、など)
に含まれる文字を、文字列にマップさせるやり方を \fIscreen\fP に伝える。
それぞれの \fI<mapping>\fP では、
1 つの文字をどんな文字列にマップさせるかを記述する。
大抵の場合、各コードの大部分は共通なので、
ここではテンプレート機構が用いられる
(例えば、別の文字集合に切り替える文字列など)。
\fI<template>\fP に '%' があると、
それはすべてその文字と同時に指定された \fI<template-arg>\fP に置き換えられる。
指定したい文字列が全く似ていない場合には、'%' をテンプレートとして用い、
文字列全体は \fI<template-arg>\fP
に置くこと。'%' そのものも使えるようにするため、
クォート機構も後に追加された。'\e'
は特殊文字 '\e', '%', ',' をクォートする。
.PP
以下に指定例を示す:
.sp
    termcap hp700 'XC=B\eE(K%\eE(B,\e304[,\e326\e\e\e\e,\e334]'
.sp
これは ISOlatin1 (文字集合 'B') のウムラウト付きの大文字を、
ドイツ語の文字集合を持つ HP700 端末向けに変換する方法を
\fIscreen\fP に指定する。'\e304' は '\eE(K[\eE(B' に変換される (以下同様)。
この行は内部参照テーブルが構築されるまでに * 3 回 * 展開されるため、
1 つの '\e' を生成するにはいくつものクォートが必要になる点に注意すること。
.PP
さらに多くのエミュレーションができるように、別の拡張も加えられている:
クォートされていない '%' がマッピングで変換された場合、
\fIscreen\fP がその \fI<designator>\fP に切り替わると、
必ずこれが端末に送られる。この特殊な場合には、
テンプレートは単に '%' とみなされる。
文字集合切り替えシーケンスと文字マッピングは、
通常あまり共通部分を持たないからである。
.PP
以下の指定例は、この拡張の使い方の 1 つを示したものである:
.sp
    termcap xterm 'XC=K%,%\eE(B,[\e304,\e\e\e\e\e326,]\e334'
.sp
この例では、ドイツ語 ('K') 文字集合の一部が xterm 上でエミュレートされる。
\fIscreen\fP が文字集合 'K' に切り替わらなければならない場合、'\eE(B'
が端末に送られる。つまり、
ASCII 文字集合がドイツ語文字集合の代わりに使われる。
テンプレートは '%' だけになり、したがってマッピングは単純である: '['
は '\e304' に、'\e' は '\e326' に、']' は '\e334' にマッピングされる。

.SH 環境変数
.PD 0
.IP COLUMNS 15
端末のカラム数 (termcap エントリより優先される)。
.IP HOME
ファイル .screenrc を探すディレクトリ。
.IP LINES 
端末の行数 (termcap エントリより優先される)。
.IP LOCKPRG
画面をロックするプログラム。
.IP NETHACKOPTIONS
nethack オプションを有効にする。
.IP PATH
実行するプログラムの探索に用いられる。
.IP SCREENCAP
端末の TERMCAP 値のカスタマイズ用。
.IP SCREENDIR
別のソケットディレクトリ。
.IP SCREENRC
別のユーザ用 screenrc ファイル。
.IP SHELL
ウィンドウをオープンした時のデフォルトのシェルプログラム
(デフォルト値は \*Q/bin/sh\*U)。
.IP STY
別のソケット名。
.IP SYSSCREENRC
別のシステム用 screenrc ファイル。
.IP TERM
端末名。
.IP TERMCAP
端末記述。
.IP WINDOW
ウィンドウの番号 (生成時)。

.SH ファイル
.PD 0
.IP .../screen-4.?.??/etc/screenrc 34
.IP .../screen-4.?.??/etc/etcscreenrc
.I screen
の配布パッケージに含まれている、
プライベート用・グローバル用各初期化ファイルの例。
.IP $SYSSCREENRC 
.IP /etc/screenrc
\fIscreen\fP の初期化コマンド群を含む。
.IP $SCREENRC
.IP $HOME/.screenrc
/etc/screenrc の後に読み込まれる
.IP $SCREENDIR/S-<login>
.IP /var/run/screen/S-<login>
ソケットディレクトリ (デフォルト)
.IP /usr/tmp/screens/S-<login>
別のソケットディレクトリ
.IP "<socket directory>/.termcap"
"termcap" 出力関数が書き込む
.IP "/usr/tmp/screens/screen-exchange または /tmp/screen-exchange"
\fIscreen\fP の「プロセス間通信バッファ」
.IP hardcopy.[0-9]
hardcopy 関数が生成する画面イメージ
.IP screenlog.[0-9]
log 関数が生成するログファイル
.IP "/usr/lib/terminfo/?/* または /etc/termcap"
端末機能データベース
.IP /var/run/utmp
ログイン記録
.IP $LOCKPRG
端末をロックするプログラム

.SH 関連項目
termcap(5), utmp(5), vi(1), captoinfo(1), tic(1)

.SH 著者
最初に作成したのは Oliver Laumann であり、最新版を作ったのは
Wayne Davison, Juergen Weigert, Michael Schroeder である。

.SH COPYLEFT
.nf
Copyright (C) 1993-2003
	Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
	Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
Copyright (C) 1987 Oliver Laumann
.fi
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
.PP
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
.PP
You should have received a copy of the GNU General Public License
along with this program (see the file COPYING); if not, write to the
Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

.SH 貢献者
.nf
Ken Beal (kbeal@amber.ssd.csd.harris.com),
Rudolf Koenig (rfkoenig@immd4.informatik.uni-erlangen.de),
Toerless Eckert (eckert@immd4.informatik.uni-erlangen.de), 
Wayne Davison (davison@borland.com),
Patrick Wolfe (pat@kai.com, kailand!pat),
Bart Schaefer (schaefer@cse.ogi.edu),
Nathan Glasser (nathan@brokaw.lcs.mit.edu),
Larry W. Virden (lvirden@cas.org),
Howard Chu (hyc@hanauma.jpl.nasa.gov),
Tim MacKenzie (tym@dibbler.cs.monash.edu.au),
Markku Jarvinen (mta@{cc,cs,ee}.tut.fi),
Marc Boucher (marc@CAM.ORG),
Doug Siebert (dsiebert@isca.uiowa.edu),
Ken Stillson (stillson@tsfsrv.mitre.org),
Ian Frechett (frechett@spot.Colorado.EDU),
Brian Koehmstedt (bpk@gnu.ai.mit.edu),
Don Smith (djs6015@ultb.isc.rit.edu),
Frank van der Linden (vdlinden@fwi.uva.nl),
Martin Schweikert (schweik@cpp.ob.open.de),
David Vrona (dave@sashimi.lcu.com),
E. Tye McQueen (tye%spillman.UUCP@uunet.uu.net),
Matthew Green (mrg@eterna.com.au),
Christopher Williams (cgw@pobox.com),
Matt Mosley (mattm@access.digex.net),
Gregory Neil Shapiro (gshapiro@wpi.WPI.EDU),
Johannes Zellner (johannes@zellner.org),
Pablo Averbuj (pablo@averbuj.com).
.fi

.SH バージョン
これはバージョン 4.0.2 である。これは Wayne Davison による
2.3PR7 カスタム版をマージしたものと、
Oliver Laumann のバージョン 2.0 へのいくつかの改良とがもとになっている。
2.x の番号が付いているバージョンはすべて Oliver Laumann の著作物である。

.SH 入手方法
.I screen
の最新の公式リリースは、gnudist.gnu.org, nic.funet.fi その他の
.I GNU
配布サイトから anonymous ftp で取得できる。
.I screen
のホームサイトは ftp.uni-erlangen.de のディレクトリ pub/utilities/screen
である。ここのサブディレクトリ `private' には、
最新のベータテスト版が置かれる。開発に協力したい場合は、
気付いた点を screen@uni-erlangen.de に送ってほしい。

.SH バグ
.PD
.IP \(bu 3
`dm' (削除モード)と `xs' を正しく扱うことができない
(これらは無視される)。`xn' は magic-margin 指示子として扱われる。
.IP \(bu
.I screen
は 2 倍高や 2 倍幅の文字を扱うことができない。
しかし、
.I vttest
の失敗が許されるのはここだけである。
.IP \(bu
異なる端末タイプから再アタッチを行ったとき、
環境変数 $TERMCAP を変更できない。
.IP \(bu
terminfo ベースのシステムのサポートが非常に限られている。
機能を $TERMCAP に追加しても全く効果が現われないことがある。
.IP \(bu
.I screen
はハードウェアタブを利用していない。
.IP \(bu
.I screen
は所有者 root に setuid してインストールしなければならない。
これは各ウィンドウに対する tty デバイスファイルの所有者を
正しく変更するためである。\*Q/etc/utmp\*U
ファイルに書き込みを行うためにも特殊な権限が必要である。
.IP \(bu
.I screen
が SIGKILL で kill された時には、\*Q/etc/utmp\*U のエントリが削除されない。
この場合、一部のプログラム ("w" や "rwho" 等)
は、実際にはログインしていないユーザをログイン中であると表示する。
.IP \(bu
ユーザが使っている tty に utmp エントリが無いとき、
.I screen
はおかしな警告を出す。
.IP \(bu
モデムラインのデバイスドライバが HANGUP シグナルを送るように
設定されていないと、このラインがハングアップした時に
.I screen
は自動的なデタッチ (あるいは終了) を行えないことがある。
.I screen
セッションをデタッチするには
コマンドラインオプション -D または -d を用いること。
.IP \(bu
パスワードを設定しているときでも、
コマンドラインオプション -D および -d によって、
パスワードを尋かれることなしにデタッチができてしまう。
.IP \(bu
\*Qbreaktype\*U と \*Qdefbreaktype\*U の両方ともが、
全端末デバイスで用いられるブレークの生成方法を変更してしまう。
前者はそのウィンドウの設定だけを変更すべきで、
後者は以降新規に生成されるウィンドウの設定だけを変更すべきである。
.IP \(bu
マルチユーザセッションにアタッチしようとすると、
そのユーザの .screenrc ファイルは評価されない。
各ユーザの個人設定は、そのセッションがブートされるときの .screenrc
ファイルに書くか、あるいは手動で変更しなければならない。
.IP \(bu
全機能を最大限に生かすためには、おかしな想像力が非常に有用となる。
.IP \(bu
バグ報告、修正、改良、T シャツ、お金、ビール、ピザ等は
.BR screen@uni-erlangen.de
まで送ってほしい。
