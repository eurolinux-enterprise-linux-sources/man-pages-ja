.\"
.\" MAN PAGE COMMENTS to
.\"
.\"	Chet Ramey
.\"	Information Network Services
.\"	Case Western Reserve University
.\"	chet@ins.CWRU.Edu
.\"
.\"	Last Change: Mon Mar  5 10:19:14 EST 2001
.\"
.\" bash_builtins, strip all but Built-Ins section
.if \n(zZ=1 .ig zZ
.if \n(zY=1 .ig zY
.TH BASH 1 "2001 Mar 5" "GNU Bash-2.05"
.\"
.\" There's some problem with having a `@'
.\" in a tagged paragraph with the BSD man macros.
.\" It has to do with `@' appearing in the }1 macro.
.\" This is a problem on 4.3 BSD and Ultrix, but Sun
.\" appears to have fixed it.
.\" If you're seeing the characters
.\" `@u-3p' appearing before the lines reading
.\" `possible-hostname-completions
.\" and `complete-hostname' down in READLINE,
.\" then uncomment this redefinition.
.\"
.\" Translated Wed Apr  7 22:55:11 JST 1999
.\"    by FUJIWARA Teruyoshi <fujiwara@linux.or.jp>
.\" Proofed by
.\"       Shinya Hanataka <hanataka@abyss.rim.or.jp>
.\"       NAKANO Takeo <nakano@apm.seikei.ac.jp>
.\"
.\" Updated to 2.04  Sun Apr 1 2001
.\"    by the members of JM Project (JM@linux.or.jp)
.\"       Satoshi Asakawa <asakawa@kanagawa.hitachi.co.jp>
.\"       Shinya Hanataka <hanataka@abyss.rim.or.jp>
.\"       Akihiro Motoki <mokkun@iname.com>
.\"       NAKANO Takeo <nakano@apm.seikei.ac.jp>
.\"       Yuichi SATO <sato@complex.eng.hokudai.ac.jp>
.\"       Kentaro Shirakata <argrath@ub32.org>
.\"       TAKEI Nobumitsu <takei@webmasters.gr.jp>
.\"       UCHIDA Norihiro <KY4N-UCD@asahi-net.or.jp>
.\"
.\" Updated to 2.05  Sat 14 Apr 2001
.\"    by NAKANO Takeo
.\"
.\"WORD:	positional parameter	位置パラメータ
.\"WORD:	preamble		前置部分
.\"WORD:	postscript		後置部分
.\"WORD:	level of variable indirection	間接変数レベル
.\"WORD:	arithmetic expansion	算術式展開
.\"WORD:	naming open file	名前付きオープンファイル
.\"WORD:	collation weight	照合重さ
.\"WORD:	collating symbol	照合シンボル
.\"WORD:	collating sequence	照合順序
.\"WORD:	range expression	範囲表現
.\"WORD:	composite pattern	複合パターン
.\"WORD:	sub-pattern	サブパターン
.\"WORD:	history list	履歴リスト
.\"WORD:	basename	ベース名
.\"WORD:	file descriptor	ファイル・ディスクリプター
.\"WORD:	exit status		終了ステータス
.\"WORD:	return status		返却ステータス
.\"
.de }1
.ds ]X \&\\*(]B\\
.nr )E 0
.if !"\\$1"" .nr )I \\$1n
.}f
.ll \\n(LLu
.in \\n()Ru+\\n(INu+\\n()Iu
.ti \\n(INu
.ie !\\n()Iu+\\n()Ru-\w\\*(]Xu-3p \{\\*(]X
.br\}
.el \\*(]X\h|\\n()Iu+\\n()Ru\c
.}f
..
.\"
.\" File Name macro.  This used to be `.PN', for Path Name,
.\" but Sun doesn't seem to like that very much.
.\"
.de FN
\fI\|\\$1\|\fP
..
.SH 名前
bash \- GNU Bourne-Again SHell
.SH 書式
.B bash
[options]
[file]
.SH 著作権
.if n Bash is Copyright (C) 1989-2001 by the Free Software Foundation, Inc.
.if t Bash is Copyright \(co 1989-2001 by the Free Software Foundation, Inc.
.SH 説明
.B bash
は、標準入力やファイルから読み込んだコマンドを実行する、
\fBsh\fR 互換のコマンド言語インタプリタです。
.B bash
には、\fIKorn\fP シェルや \fIC\fP シェル (\fBksh\fP や \fBcsh\fP)
の便利な機能も採り入れられています。
.PP
.B bash
は IEEE POSIX Shell and Tools specification (IEEE Working Group 1003\.2)
に準拠する実装を目指しています。
.SH オプション
.B bash
は以下のオプションを起動時に解釈します
(組み込みコマンド \fBset\fR の説明で述べられている
1 文字のシェルオプションも使えます):
.PP
.PD 0
.TP 10
.BI \-c "\| string\^"
.B \-c
オプションが指定されると、コマンドが
.I string
から読み込まれます。
.I string
の後に引き数があれば、これらは
位置パラメータ (positional parameter:
.B $0
からはじまるパラメータ) に代入されます。
.TP
.B \-r
.B \-r
オプションが指定されると、
.B bash
は
.I 制限された状態 (restricted)
となります (後述の
.SM
.B 制限付きのシェル
を参照)。
.TP
.B \-i
.B \-i
オプションが指定されると、
.B bash
は
.I 対話的 (interactive)
に動作します。
.TP
.B \-s
.B \-s
オプションが指定された場合と、
オプションをすべて処理した後に引き数が残っていなかった場合には、
コマンドは標準入力から読み込まれます。
このオプションを使うと、
対話的シェルを起動するときに
位置パラメータを設定できます。
.TP
.B \-D
.\"UNSOLVED: ouput は output の typo
二重引用符によるクォート文字列 (double-quoted strings) に
\fB$\fP が前置されたものを、全てリストして標準出力に出力します。
これらは、カレントロケールが \fBC\fP または \fBPOSIX\fP 以外の時に、
翻訳の対象となるべき文字列です。
このオプションを指定すると、
自動的に \fB\-n\fP オプションも指定されたことになります。
つまりコマンドは全く実行されません。
.TP
.B \-\-
.B \-\-
はオプションの終わりを示し、それ以降のオプション処理を行いません。
.B \-\-
以降の引き数は全て、ファイル名や引き数として扱われます。
引き数
.B \-
は
\fB\-\-\fP
と同じです。
.PD
.PP
.B bash
が解釈するオプションには複数の文字からなるものもたくさんあります。
このようなオプションを認識させるためには、
コマンドライン中で
1 文字のオプションよりも前に置かなければなりません。
.PP
.PD 0
.TP
.B \-\-dump\-po\-strings
\fB\-D\fP と同じですが、
出力は GNU \fIgettext\fP の
\fBpo\fP (ポータブルオブジェクト) ファイル形式で行われます。
.TP
.B \-\-dump\-strings
\fB\-D\fP と同じです。
.TP
.B \-\-help
使用方法についてのメッセージを標準出力に表示し、正常終了します。
.TP
.PD 0
\fB\-\-init\-file\fP \fIfile\fP
.TP
\fB\-\-rcfile\fP \fIfile\fP
.PD
対話的シェルとして起動された場合、
個人用の初期化ファイル
.I ~/.bashrc
の代わりに
.I file
からコマンドを実行します (後述の
.SM
.B 起動
セクションを参照)。
.TP
.B \-\-login
ログインシェル (後述の
.SM
.B 起動
セクションを参照)
として起動されたかのように
.B bash
を動作させます。
.TP
.B \-\-noediting
シェルが対話的動作の場合、コマンドラインを読み込むときに GNU
.B readline
ライブラリを使用しません。
.TP
.B \-\-noprofile
システム全体用の起動ファイル
.FN /etc/profile
および個人用の初期化ファイル
.IR ~/.bash_profile ,
.IR ~/.bash_login ,
.I ~/.profile
のいずれも読み込みません。デフォルトでは、
.B bash
はログインシェルとして起動された時に
これらのファイルを読み込みます (後述の
.SM
.B 起動
セクションを参照)。
.TP
.B \-\-norc
シェルが対話的動作を行う場合に、個人用初期化ファイル
.I ~/.bashrc
の読み込み・実行を行いません。シェルが
.BR sh
として起動された場合には、このオプションはデフォルトで有効になります。
.TP
.B \-\-posix
\fBbash\fP の動作のうち、
デフォルトの振舞いが POSIX 1003.2 の標準と異なる部分を、
標準に適合するように変更します (\fIposix モード\fP)。
.TP
.B \-\-restricted
シェルの動作を制限します (後述の
.SM
.B 制限付きのシェル
セクションを参照)。
.TP
.B \-\-verbose
\fB\-v\fP と同じです。
.\"UNSOLVED -v の説明は前にあるべきだと思う。
.TP
.B \-\-version
実行された
.B bash
のバージョン情報を標準出力に表示し、正常終了します。
.PD
.SH 引き数
オプション処理の後に引き数が残っており、かつ
.B \-c
オプションと
.B \-s
オプションのいずれも指定されていない場合、
最初の引き数はファイル名とみなされ、
そのファイルにシェルコマンドが記述されているとみなされます。
このように
.B bash
が起動された場合、
.B $0
にそのファイルの名前が設定されます
(残りの引き数は位置パラメータに設定されます)。
.B bash
はこのファイルからコマンドの読み込みと実行を行い、そして終了します。
\fBbash\fP の終了ステータスは、
このスクリプト中で実行された最後のコマンドの終了ステータスになります。
コマンドが全く実行されなければ、終了ステータスは 0 です。
.SH 起動
\fIログインシェル(login shell)\fPとは、0 番目の引き数の最初の文字が
.BR \-
であるシェル、または
.B \-\-login
オプション付きで起動されたシェルのことです。
.PP
\fI対話的な\fPシェルとは、
オプションでない引数がなく、
標準入力と標準出力がいずれも端末に接続されていて (これは
.IR isatty (3)
で調べられます)、
.B \-c
オプションが指定されていない状態で起動されたシェル、または
.B \-i
オプション付きで起動されたシェルのことです。
.B bash
が対話的に動作している場合には、
.SM
.B PS1
が設定され、
.B $\-
に
.B i
が含まれます。
これを利用すると、対話的動作の状態であるかどうかを、
シェルスクリプトや起動ファイルの内部で調べられます。
.PP
以下の段落では、
.B bash
がどのように起動ファイルを実行するかを説明します。
以下のファイルのいずれかが、
「存在しているが読み込みできない」場合は、
.B bash
はエラーを報告します。ファイル名に含まれるチルダは、
後述の
.SM
.B 展開
セクションにおける
.B "チルダ展開"
の項目で述べるように展開されます。
.PP
.B bash
が対話的なログインシェルとして起動されるか、
\fB\-\-login\fP オプション付きの非対話的シェルとして起動されると、
\fI/etc/profile\fP ファイルが存在すれば、
.B bash
はまずここからコマンドを読み込んで実行します。
このファイルを読んだ後、
.B bash
は \fI~/.bash_profile\fP, \fI~/.bash_login\fP, \fI~/.profile\fP をこの
順番で探します。
.B bash
は、この中で最初に見つかり、かつ読み込みが可能であるファイルから
コマンドを読み込んで実行します。
.B \-\-noprofile
オプションを使ってシェルを起動すれば、
この動作を行わないようにできます。
.PP
ログインシェルが終了するときには、
\fI~/.bash_logout\fP ファイルがあれば、
.B bash
はこれを読み込んで実行します。
.PP
ログインシェルでない対話的シェルとして起動されると、
\fI~/.bashrc\fP ファイルがあれば、
.B bash
はここからコマンドを読み込み、実行します。
この動作は
.B \-\-norc
オプションで行わないようにできます。
\fB\-\-rcfile\fP \fIfile\fP オプションを使うと、
コマンドの読み込みと実行を \fI~/.bashrc\fP からでなく
\fIfile\fP から行わせることができます。
.PP
(例えばシェルスクリプトを実行するために) 非対話的に起動されると、
.B bash
は環境変数
.SM
.B BASH_ENV
を調べ、この変数が定義されていればその値を展開し、
得られた値をファイル名とみなして、
そこからコマンドの読み込みと実行を行います。
つまり
.B bash
は以下のコマンドが実行されたのと同じように動作します:
.sp .5
.RS
.if t \f(CWif [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi\fP
.if n if [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
.RE
.sp .5
ただし、ファイル名を探すために
.SM
.B PATH
環境変数の値が使われることはありません。
.PP
.BR sh
という名前で
.B bash
を起動すると、
.B bash
は古くからある
.B sh
の起動動作をできるだけ真似しようとします。
また POSIX 標準にもできるだけ従おうとします。
対話的なログインシェルとして起動されると、
あるいは \fB\-\-login\fP オプション付きの非対話的シェルとして起動されると、
このシェルはまず
.I /etc/profile
と
.IR ~/.profile
の順でコマンドの読み込みと実行をしようとします。
.B \-\-noprofile
オプションを使うと、この動作を行わないようにできます。
.BR sh
という名前の対話的シェルとして起動されると、
.B bash
は環境変数
.SM
.BR ENV
を調べ、この変数が定義されていればその値を展開し、
展開で得た値をコマンドの読み込みと実行を行うためのファイル名として使います。
.B sh
という名前で起動されたシェルは、
他の起動ファイルからコマンドの読み込みと起動を行うことはないので、
.B \-\-rcfile
オプションは全く効果を持ちません。
.B sh
という名前の非対話的シェルとして起動されると、
このシェルは他の起動ファイルを何も読み込みません。
.B sh
として起動された場合、
.B bash
は起動ファイルの読み込みを行った後に
.I POSIX
モードに入ります。
.PP
.B \-\-posix
コマンドラインオプション等により
.B bash
が
.I POSIX
モードで起動されると、
.B bash
は起動ファイルに関して POSIX 標準に従います。
このモードでは、対話的シェルは
.SM
.B ENV
環境変数を展開し、
展開して得られた名前のファイルからコマンドの読み込みと実行を行います。
他の起動ファイルは全く読み込みません。
.PP
.B bash
は、自分を起動したのがリモートシェルデーモン (通常は \fIrshd\fP)
かどうかを調べます。
\fIrshd\fP によって実行されていると
.B bash
が判断した場合、
\fI~/.bashrc\fP が存在し、かつ読み込み可能であれば、
.B bash
はコマンドをこのファイルから読み込んで実行します。
\fBsh\fP として呼び出された場合には、この動作は行いません。
.B \-\-norc
オプションを使えばこの動作を禁止できますし、
.B \-\-rcfile
オプションを使えば他のファイルを読ませるようにもできます。
しかし一般的には \fIrshd\fP は
これらのオプションを付けてシェルを起動しませんし、
指定もできないようになっています。
.PP
シェルが実ユーザ (グループ) ID と異なる実効ユーザ (グループ) ID で起動され、
かつ \fB\-p\fP オプションが与えられていない場合は、
起動ファイルは全く読み込まれず、シェル関数は環境から継承されず、
\fBSHELLOPTS\fP が環境変数に含まれていても無視され、
実効ユーザ ID には実ユーザ ID が設定されます。
\fB\-p\fP オプションが起動時に与えられた場合、
起動時の動作は同じですが、
実効ユーザ ID は再設定されません。
.SH 定義
.PP
このドキュメントの残りの部分では、
以下の定義を使用します。
.PD 0
.TP
.B ブランク (blank)
空白文字またはタブ文字
.TP
.B 単語 (word)
シェルが 1 単位とみなす文字並び。
.BR トークン(token)
とも言われます。
.TP
.B 名前 (name)
英数字とアンダースコア文字だけから構成され、
かつ最初の文字が英字かアンダースコア文字である
.IR 単語 。
.B 識別子 (identifier)
とも言われます。
.TP
.B メタ文字 (metacharacter)
クォートされていない場合に、単語区切りとなる文字。
以下の文字のうちのいずれかです:
.br
.RS
.PP
.if t \fB|  &  ;  (  )  <  >  スペース  タブ\fP
.if n \fB|  & ; ( ) < > スペース タブ\fP
.RE
.PP
.TP
.B 制御演算子
制御機能を持つ\fIトークン\fP。
以下のシンボルのうちのいずれかです:
.RS
.PP
.if t \fB\(bv\(bv  &  &&  ;  ;;  (  )  |  <newline>\fP
.if n \fB|| & && ; ;; ( ) | <newline>\fP
.RE
.PD
.SH 予約語
\fI予約語 (reserved word)\fP
とはシェルにとって特別な意味を持つ単語です。
以下の単語がクォートされておらず、
かつ単純なコマンド (simple command) の
先頭の単語 (後述の
.SM
.B シェルの文法
を参照) であるか、
.B case 
コマンドや
.B for
コマンドの 3 番目の単語である場合には、予約語として認識されます:
.if t .RS
.PP
.B
.if n ! case  do done elif else esac fi for function if in select then until while { } time [[ ]]
.if t !    case    do    done    elif    else    esac    fi    for    function    if    in    select    then    until    while    {    }    time    [[    ]]
.if t .RE
.RE
.SH シェルの文法
.SS 単純なコマンド (Simple Commands)
.PP
単純なコマンド (\fIsimple command\fP) とは、
変数の代入を並べたもの (これは省略可能です) の後に、
ブランク区切りの単語とリダイレクションを記述し、
最後に制御演算子を置いたものです。
最初の単語は実行するコマンドを指定します。
残りの単語は起動されるコマンドに引き数として渡されます。
.PP
単純なコマンドの返り値はコマンドの終了コードですが、シグナル
.IR n
を受けてコマンドが終了した場合には 128+\fIn\^\fP となります。
.SS パイプライン (Pipeline)
.PP
\fIパイプライン (pipeline)\fPは、記号
.BR |
で区切った 1 つ以上のコマンド列です。
パイプラインのフォーマットを以下に示します:
.RS
.PP
[\fBtime\fP [\fB\-p\fP]] [ ! ] \fIcommand\fP [ \fB|\fP \fIcommand2\fP ... ]
.RE
.PP
.I command
の標準出力は
.IR command2
の標準入力に接続されます。
この接続は、
コマンドで指定したどのリダイレクションよりも先に実行されます
(後述の
.SM
.B リダイレクション
を参照)。
.PP
パイプラインの前に、予約語である
.B !
がある場合、
そのパイプラインの終了ステータスは最後のコマンドの終了ステータスの論理値の
NOT を取ったものになります。
それ以外の場合には、
パイプラインのステータスは最後のコマンドの終了ステータスになります。
値を返す前に、シェルはパイプライン中の全てのコマンドが終了するのを待ちます。
.PP
パイプラインの前に予約語
.B time
がある場合、コマンドの実行にかかった
経過時間・ユーザ時間・システム時間がパイプラインの終了時に報告されます。
\fB\-p\fP オプションを指定すると、
出力フォーマットが POSIX 仕様に変わります。
変数
.SM
.B TIMEFORMAT
には、経過時間情報の表示の仕方を指定するフォーマット文字列を
設定できます (後述の
.B シェル変数
の項の
.SM
.B TIMEFORMAT
に関する説明を参照)。
.PP
パイプライン中の各コマンドは、それぞれ別のプロセスとして
(つまりサブシェル内で) 実行されます。
.SS リスト
.PP
\fIリスト (list)\fP とは、1つ以上のパイプラインを演算子
.BR ; ,
.BR & ,
.BR && ,
.BR \(bv\(bv
のいずれかで区切って並べ、最後に
.BR ; ,
.BR & ,
.BR <newline> 
のいずれか (これは省略可能です) を置いたものです。
.PP
リスト演算子のうち、
.B &&
と
.B \(bv\(bv
の優先順位は同じです。これらの次に、
.B ;
と
.BR &
が同じ優先順位で続きます。
.PP
コマンドが制御演算子
.BR &
で終わっている場合、シェルはコマンドをサブシェル内で
\fIバックグラウンド (background)\fP で実行します。
シェルはコマンドが終了するのを待たずに、返却ステータス 0 を返します。
コマンドを
.B ;
で区切った場合には、これらは順番に実行されます。
シェルはそれぞれのコマンドが終了するのを順番に待ちます。
返却ステータスは、最後に実行したコマンドの終了ステータスになります。
.PP
制御演算子
.B &&
は AND リストを示し、
.B \(bv\(bv
は OR リストを示します。
AND リストは
.RS
.PP
\fIcommand1\fP \fB&&\fP \fIcommand2\fP
.RE
.PP
という形式であり、
.I command1
が終了ステータス 0 を返した場合に限り
.I command2
が実行されます。
.PP
OR リストは
.RS
.PP
\fIcommand1\fP \fB\(bv\(bv\fP \fIcommand2\fP
.PP
.RE
.PP
という形式であり、
.I command1
が 0 以外の終了ステータスを返した場合に限り
.I command2
が実行されます。AND リストと OR リストの返却ステータスは、
リスト中で最後に実行されたコマンドの終了ステータスです。
.SS 複合コマンド(Compound Commands)
.PP
\fI複合コマンド (compound command)\fP を以下に示します:
.TP
(\fIlist\fP)
\fIlist\fP はサブシェル内で実行されます。
シェルの環境に影響を与えるような変数の代入や組み込みコマンドは、
コマンドの終了後に影響を残しません。
返却ステータスは \fIlist\fP の終了ステータスです。
.TP
{ \fIlist\fP; }
\fIlist\fP が単に現在のシェル環境で実行されます。
\fIlist\fP の最後は改行文字かセミコロンでなければなりません。これは
\fIグループコマンド(group command)\fP と呼ばれます。返却ステータスは
\fIlist\fP の終了ステータスです。
.TP
((\fIexpression\fP))
\fIexpression\fP が後述の
.SM
.BR 算術式評価
で説明される規則に従って評価されます。
式の値が 0 でない場合、返却ステータスは 0 になります。そうでない場合、
返されるステータスは 1 になります。これは \fBlet "\fIexpression\fP"\fR
と全く同じものです。
.TP
\fB[[\fP \fIexpression\fP \fB]]\fP
条件式 \fIexpression\fP の評価値に従って 0 または 1 を返します。
式は後述の
.SM
.BR 条件式
で説明する、プライマリによって構成されます。
単語分割とパス名展開は \fB[[\fP と \fB]]\fP
の間の単語に対しては行われません。
チルダ展開、パラメータと変数の展開、算術式展開、コマンド置換、
プロセス置換、クォート除去は実行されます。
.if t .sp 0.5
.if n .sp 1
\fB==\fP 演算子と \fB!=\fP 演算子が使われたとき、
演算子の右の文字列はパターンと解釈され、
後述の\fBパターンマッチング\fPで説明する規則に従ってマッチングが行われます。
文字列がパターンにマッチすれば返り値は 0 であり、
マッチしなければ返り値は 1 になります。
パターンの任意の部分をクォートして、文字列としてマッチさせることもできます。
.if t .sp 0.5
.if n .sp 1
式は以下の演算子を使って繋げられます。
以下に演算子を優先度の順に示します:
.if t .sp 0.5
.if n .sp 1
.RS
.PD 0
.TP
.B ( \fIexpression\fP )
\fIexpression\fP の値を返します。これを用いて、
演算子の通常の優先度を変更できます。
.TP
.B ! \fIexpression\fP
.I expression
が偽ならば真になります。
.TP
\fIexpression1\fP \fB&&\fP \fIexpression2\fP
.I expression1
と
.I expression2
が両方とも真であれば真になります。
.TP
.if t \fIexpression1\fP \fB\(bv\(bv\fP \fIexpression2\fP
.if n \fIexpression1\fP \fB||\fP \fIexpression2\fP
.I expression1
と
.I expression2
のどちらかが真であれば真となります。
.PD
.RE
.LP
\fIexpression1\fP の値だけで条件式全体の返り値が決定できれば、
\fB&&\fP 演算子と
.if t \fB\(bv\(bv\fP
.if n \fB||\fP
演算子は \fIexpression2\fP を実行しません。
.TP
\fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP ] ; \fBdo\fP \fIlist\fP ; \fBdone\fP
\fBin\fP に続く単語のリストが展開され、要素のリストが生成されます。
変数 \fIname\fP には、このリストの各要素が順番にセットされ、その度に
\fIlist\fP が実行されます。「\fBin\fP \fIword\fP」が省略された場合、
\fBfor\fP コマンドは、設定されている位置パラメータそれぞれに対して
\fIlist\fP を一度ずつ実行します(後述の
.SM
.B パラメータ
を参照)。
返却ステータスは実行された最後のコマンドの終了ステータスになります。
\fBin\fP に続く要素を展開した結果が空となった場合、
コマンドは全く実行されず、返却ステータス 0 が返されます。
.TP
\fBfor\fP (( \fIexpr1\fP ; \fIexpr2\fP ; \fIexpr3\fP )) ; \fBdo\fP \fIlist\fP ; \fBdone\fP
最初に、算術式\fIexpr1\fPが、後述の
.SM
.BR 算術式評価
で説明される規則に従って評価されます。
次に、算術式\fIexpr2\fPがゼロになるまで繰り返し評価されます。
算術式\fIexpr2\fPの評価結果がゼロでなければ、その度毎に\fIlist\fPが実行され、
算術式\fIexpr3\fPが評価されます。
どの算術式も省略された場合は、
評価結果が 1 とみなされた場合のように振る舞います。
返却ステータスは \fIlist\fP 中で実行された
最後のコマンドの終了ステータスとなりますが、
算術式のいずれかが無効である場合には不正な値となります。
.TP
\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP ] ; \fBdo\fP \fIlist\fP ; \fBdone\fP
\fBin\fP に続く単語のリストが展開され、要素のリストが生成されます。
展開された単語の集合が番号付きで標準エラー出力に出力されます。
「\fBin\fP \fIword\fP」が省略された場合、
位置パラメータが出力されます (後述の
.SM
.B パラメータ
を参照)。続いて
.B PS3
が表示され、標準入力から 1 行の読み込みが行われます。
表示された単語のいずれかに対応する数字がこの行に含まれていれば、
.I name
の値としてその単語が設定されます。
行が空であれば、単語とプロンプトが再び表示されます。
EOF を読み込むとコマンドが終了します。
これ以外の値の場合には、
.I name
には空文字列が設定されます。読み込んだ行は変数
.BR REPLY
に格納されます。
.B break
または
.B return
コマンドが実行されるまで、選択を行うたびに
.I list
が実行されます。
.B select
の終了ステータスは、
.IR list
中で最後に実行したコマンドの終了ステータスですが、
コマンドが全く実行されなかった場合には 0 となります。
.TP
\fBcase\fP \fIword\fP \fBin\fP [ [(] \fIpattern\fP [ \fB|\fP \fIpattern\fP ] \
... ) \fIlist\fP ;; ] ... \fBesac\fP
\fBcase\fP コマンドは最初に \fIword\fP を展開し、それぞれの
\fIpattern\fP に対して順にマッチングを試みます。
マッチングの際にはパス名展開 (後述の
.B パス名展開
を参照) と同じ規則が用いられます。
マッチするものが見つかると、これに対応する \fIlist\fP が実行されます。
マッチするものが見つかったら、それ以降のマッチングは行われません。
マッチするパターンが無ければ、終了ステータスは 0 になります。
マッチするものがあったら、終了ステータスは
\fIlist\fP 中で最後に実行されたコマンドの終了ステータスになります。
.TP
\fBif\fP \fIlist\fP; \fBthen\fP \fIlist;\fP \
[ \fBelif\fP \fIlist\fP; \fBthen\fP \fIlist\fP; ] ... \
[ \fBelse\fP \fIlist\fP; ] \fBfi\fP
最初に
.B if 
.I list
が実行されます。この終了ステータスが 0 ならば、\fBthen\fP \fIlist\fP
が実行されます。
そうでなければ \fBelif\fP \fIlist\fP がそれぞれ順番に実行され、
この終了ステータスが 0 ならば、対応する \fBthen\fP \fIlist\fP
が実行され、コマンドが終了します。そうでなければ、\fBelse\fP \fIlist\fP
が (もし存在すれば) 実行されます。
終了ステータスは最後に実行されたコマンドの終了ステータスですが、
真と評価された条件が全く無い場合には 0 となります。
.TP
.PD 0
\fBwhile\fP \fIlist\fP; \fBdo\fP \fIlist\fP; \fBdone\fP
.TP
\fBuntil\fP \fIlist\fP; \fBdo\fP \fIlist\fP; \fBdone\fP
.PD
\fBwhile\fP コマンドは、\fIlist\fP 中の最後のコマンドが終了ステータス
0 を返すまで、繰り返して \fBdo\fP \fIlist\fP を実行します。\fBuntil\fP
コマンドは \fBwhile\fP コマンドとほぼ同じですが、
評価の条件が否定となる点が異なります。
.B do
.I list
は、
.I list
中の最後のコマンドが
0 以外の終了ステータスを返す限りずっと実行されます。
\fBwhile\fP コマンドと \fBuntil\fP コマンドの終了ステータスは、
\fBdo\fP \fIlist\fP で実行された最後のコマンドの終了ステータスになりますが、
コマンドが全く実行されなかった場合には 0 になります。
.TP
[ \fBfunction\fP ] \fIname\fP () { \fIlist\fP; }
\fIname\fP という名前の関数を定義します。関数の\fI本体(body)\fPは、
{ と } で囲まれたコマンドの
.I リスト
です。単純なコマンドの名前として \fIname\fP が指定されると、
必ずこのリストが実行されます。
関数の終了ステータスは、
関数本体で最後に実行されたコマンドの終了ステータスです (後述の
.SM
.B 関数
を参照)。
.SH コメント (COMMENTS)
シェルが対話的でない場合、または対話的なシェルにおいて
組み込みコマンドの
.B shopt
に対する
.B interactive_comments
オプションが有効となっている (後述の
.SM
.B シェルの組み込みコマンド
を参照すること) 場合には、
.B #
で始まる単語があると、その単語とその行の残りの文字が全て無視されます。
対話シェルでは、
.B interactive_comments
オプションが有効でなければコメントは使えません。対話シェルでは、
.B interactive_comments
オプションはデフォルトで有効になっています。
.SH クォート
\fIクォート (quoting)\fP を使うと、
特定の文字や単語のシェルに対する特別な意味を取り除けます。
クォートを用いると、特殊文字の特殊な扱いを無効にすることや、
予約語が予約語として識別されることを防いだり、
パラメータの展開を防げます。
.PP
前述の
.SM
.B 定義
で挙げた\fIメタ文字 (metacharacters)\fP にはそれぞれ特殊な意味があるので、
その文字自身を表すためにはクォートしなければなりません。
.PP
コマンド履歴展開機能が使われている場合、履歴の展開を防ぐためには、
履歴展開 (\fIhistory expansion\fP) 文字 (普通 \fB!\fP)
をクォートしなければなりません。
.PP
クォートの方法には、
.IR "エスケープ文字(escape character)" ,
シングルクォート、ダブルクォートの 3 種類があります。
.PP
クォートされていないバックスラッシュ (\fB\e\fP) は
.IR エスケープ文字
です。エスケープ文字は <newline> という例外を除き、
後に続く文字 1 つの文字としての値を保持させます。
\fB\e\fP<newline> という組合せが現われ、
かつバックスラッシュ自身がクォートされていない場合には、
\fB\e\fP<newline> は行を継続することを表します
(つまり、入力ストリームから改行文字が削除され、実質的に無視されます)。
.PP
シングルクォートで文字を囲むと、
クォート内部のそれぞれの文字は文字としての値を保持します。
シングルクォートの間にシングルクォートを置くことはできません。
これはバックスラッシュを前に付けても同じです。
.PP
ダブルクォートで文字を囲むとクォート内部の全ての文字は文字としての値を
保持しますが、
.BR $ ,
.BR ` ,
.BR \e
は例外となります。
.B $
と
.B `
はダブルクォートの内部でも特殊な意味を失いません。
バックスラッシュの場合は、次の文字が
.BR $ ,
.BR ` ,
\^\fB"\fP\^,
.BR \e ,
.BR <newline>
のいずれかである場合に限り特殊な意味を失いません。
前にバックスラッシュを付ければ、
ダブルクォート文字をダブルクォートによるクォートの内部で
クォートできます。
.PP
特殊なパラメータである
.B *
と
.B @
は、ダブルクォート内部でも特殊な意味を失いません (後述の
.SM
.B パラメータ
を参照)。
.PP
\fB$\fP'\fIstring\fP' の形式を持つ単語は特殊な扱いを受けます。
この単語は \fIstring\fP に展開され、
それから ANSI C 標準で仕様が決められている、
バックスラッシュでエスケープされている文字に置き換えられます。
バックスラッシュエスケープシーケンスは、
(もし存在すれば) 以下のようにデコードされます:
.RS
.PD 0
.TP
.B \ea
警告 (ベル)
.TP
.B \eb
バックスペース
.TP
.B \ee
エスケープ文字
.TP   
.B \ef
フォームフィード文字
.TP  
.B \en
改行文字
.TP     
.B \er
復帰文字
.TP
.B \et
水平タブ文字
.TP   
.B \ev
垂直タブ文字
.TP
.B \e\e
バックスラッシュ
.TP
.B \e'
シングルクォート
.TP   
.B \e\fInnn\fP
ASCII コードの 8 進値が \fInnn\fP である文字 (1 文字につき数字 3 桁)。
.TP
.B \ex\fInnn\fP
ASCII コードの 16 進値が \fInnn\fP である文字 (1 文字につき数字 3 桁)。
.PD
.RE
.LP
展開された結果はシングルクォートされているのと同じ状態で、
ドル記号は存在しなかったかのように扱われます。
.PP
ダブルクォートされた文字列の前にドル記号(\fB$\fP)があると、
文字列は現在のロケールに従って変換されます。
現在のロケールが \fBC\fP または \fBPOSIX\fP ならば、
ドル記号は無視されます。文字列が変換されたり置換された場合には、
その結果はダブルクォートされているのと同じ状態になります。
.SH パラメータ
.I パラメータ (parameter)
は値を保持するためのものです。パラメータは
.IR 名前 、
数字、後述の
.BR 特殊なパラメータ
で挙げる特殊文字のいずれかで表現されます。シェルでの用法においては、
.I 変数(variable)
とは
.I 名前
で表現されたパラメータです。
.PP
パラメータに値が代入されていれば、
そのパラメータは設定 (set) されていると言われます。
空文字列も有効な値です。一度値を設定すると、組み込みコマンドの
.B unset
を使わなければ設定を取り消す (unset する) ことはできません
(後述の
.SM
.B シェルの組み込みコマンド
を参照)。
.PP
.I 変数
には、以下の構文で代入できます:
.RS
.PP
\fIname\fP=[\fIvalue\fP]
.RE
.PP
.I value
が与えられなかった場合、変数には空文字列が代入されます。全ての
.I value
に対して、チルダ展開、パラメータと変数の展開、コマンド置換、
算術式展開、クォート除去が行われます (後述の
.B 展開
を参照)。変数の
.B 整数
属性が設定されている場合 (後述の
.BR シェルの組み込みコマンド
を参照)、$((...)) の展開を使っていなくても
.I value
に対しての算術展開が行われます (後述の
.B 算術式展開
を参照)。
.BR 特殊パラメータ
で後述する \fB"$@"\fP という例外を除いて、単語の分割は行われません。
パス名展開も実行されません。
.SS 位置パラメータ(Positional Parameters)
.PP
.I 位置パラメータ (positional parameter)
は、1 桁以上の数値で表されるパラメータです。ただし 0 は含みません。
位置パラメータは、シェルが起動されたときにシェルの引き数が代入されますが、
組み込みコマンドの
.B set
を使って代入し直すこともできます。
代入文を使って位置パラメータへの代入を行うことはできません。
シェル関数が実行されると、
位置パラメータは一時的に置き換えられます (後述の
.SM
.B 関数
を参照)。
.PP
2 桁以上の数値を含む位置パラメータを展開するときには、ブレース ({})
で囲まなければなりません (後述の
.SM
.B 展開
を参照)。
.SS 特殊パラメータ
.PP
シェルはいくつかのパラメータを特別扱いします。
このようなパラメータは参照されるだけであり、
値を代入することは許されません。
.PD 0
.TP
.B *
(1 から始まる) 全ての位置パラメータに展開されます。
ダブルクォートの内部で展開が行われたときは、
それぞれのパラメータを特別な変数である
.SM
.B IFS
の最初の文字で区切って並べた 1 つの単語に展開されます。つまり、
"\fB$*\fP" は "\fB$1\fP\fIc\fP\fB$2\fP\fIc\fP\fB...\fP" と同じです。
ここで
.I c
は変数
.SM
.B IFS
の値の最初の文字です。
.SM
.B IFS
が設定されていなければ、パラメータは空白で区切られます。
.SM
.B IFS
が空文字列の場合、パラメータの間には区切り文字は入らず、
全てのパラメータは繋げられます。
.TP
.B @
(1 から始まる) 全ての位置パラメータに展開されます。
ダブルクォートの内部で展開が行われたときは、
それぞれのパラメータは別々の単語に展開されます。
つまり "\fB$@\fP" は "\fB$1\fP" "\fB$2\fP" ... と同じです。
位置パラメータが無い場合には、"\fB$@\fP" と
.B $@
を展開しても空文字列になります (つまり取り除かれます)。
.TP
.B #
位置パラメータの個数を示す 10 進値に展開されます。
.TP
.B ?
最後に実行されたフォアグラウンドのパイプラインの
終了ステータスに展開されます。
.TP
.B \-
現在のオプションフラグに展開されます。
これは起動の時に指定したり、組み込みコマンド
.B set
で設定したり、(
.B \-i
オプション等で) シェル自身が設定したりします。
.TP
.B $
シェルのプロセス ID に展開されます。
() を使ったサブシェルの内部では、$ はサブシェルではなく、
現在のシェルのプロセス ID に展開されます。
.TP
.B !
最後に実行されたバックグラウンド (非同期) コマンドの
プロセス ID に展開されます。
.TP
.B 0
シェルまたはシェルスクリプトの名前に展開されます。
これはシェルの初期化時に設定されます。
コマンドを記述したファイルを指定して
.B bash
を起動した場合、
.B $0
にはそのファイルの名前が設定されます。
.B \-c
オプションを付けて
.B bash
を起動した場合、実行する文字列の後に引き数があれば、その最初の値が
.B $0
に設定されます。このオプションを指定していない場合には、
.BR bash
を起動する時に使用した名前が引き数 0 として与えられ 
.B $0
に設定されます。
.TP
.B _
シェルの起動時には、引き数リストで渡された、
実行するシェルまたはシェルスクリプトの絶対ファイル名が設定されます。
その後は、前のコマンドに対する最後の引き数 (展開後のもの) に展開されます。
また、実行する各コマンドの完全なファイル名が設定され、
そのコマンドの環境にエクスポートされます。
メールをチェックするときには、
このパラメータは現在チェックしているメールのファイル名を保持します。
.PD
.SS シェル変数
.PP
以下の変数はシェルが設定します:
.PP
.PD 0
.TP
.B PPID
そのシェルの親のプロセス ID。この変数は読み込み専用です。
.TP
.B PWD
.B cd
コマンドで設定された現在の作業ディレクトリ。
.TP
.B OLDPWD
.B cd
コマンドで設定された、1 つ前の作業ディレクトリ。
.TP
.B REPLY
組み込みコマンド
.B read
に引き数が与えられなかった時に読み込まれた行が設定されます。
.TP
.B UID
現在のユーザのユーザ ID に展開されます。
初期化はシェルの起動時に行われます。
この変数は読み込み専用です。
.TP
.B EUID
現在のユーザの実効ユーザ ID に展開されます。
初期化はシェルの起動時に行われます。
この変数は読み込み専用です。
.TP
.B GROUPS
現在のユーザがメンバになっているグループのリストを含んだ配列変数です。
.SM
.B GROUPS
への代入は効果がなく、エラーステータスを返します。
.SM
.B GROUPS
が unset された場合はこの変数の特殊な性質はなくなります。
その後に再設定されたとしても元に戻りません。
.TP
.B BASH
現在実行している
.BR bash
を起動したときに使われた、完全なファイル名に展開されます。
.TP
.B BASH_VERSION
現在実行している
.BR bash
のバージョンを示す文字列に展開されます。
.TP
.B BASH_VERSINFO
読み込み専用の配列変数で、配列の各要素は現在実行されている
.BR bash
のバージョン情報を持っています。
配列変数の要素に代入される内容を以下に示します:
.sp .5
.RS
.PD 0
.TP 24
.B BASH_VERSINFO[\fR0\fP]
メジャーバージョン番号 (\fIリリース\fP)。
.TP
.B BASH_VERSINFO[\fR1\fP]
マイナーバージョン番号 (\fIバージョン\fP)。
.TP
.B BASH_VERSINFO[\fR2\fP]
パッチレベル。
.TP
.B BASH_VERSINFO[\fR3\fP]
ビルドバージョン。
.TP
.B BASH_VERSINFO[\fR4\fP]
リリースステータス (\fIbeta1\fP など)。
.TP
.B BASH_VERSINFO[\fR5\fP]
\fBMACHTYPE\fP の値。
.PD
.RE
.TP
.B SHLVL
.B bash
の実体が起動されるたびに 1 ずつ増えます。
.TP
.B RANDOM
このパラメータが参照される度に、
0 から 32767 までのランダムな整数が生成されます。
.SM
.BR RANDOM
に値を代入すると、乱数の列を初期化できます。
.SM
.B RANDOM
を
.B unset
すると、この変数の特殊な性質は無くなります。後で再び
.B set
しても元には戻りません。
.TP
.B SECONDS
このパラメータを参照すると、シェルが起動されてからの秒数が返されます。
.SM
.BR SECONDS
に値を代入した場合、それ以降の参照において返される値は、
代入された値と代入以降の秒数を足した値になります。
.SM
.B SECONDS
を
.B unset
すると、この変数の特殊な性質は無くなります。後で再び
.B set
しても元には戻りません。
.TP
.B LINENO
この変数が参照されると、
シェルはスクリプトや関数における現在の行番号 (1から始まります) を表す
10 進値を代入します。スクリプトや関数の内部でない場合には、
意味のある値が代入されることは保証されません。
.SM
.B LINENO
を
.B unset
すると、この変数の特殊な性質は無くなります。後で再び
.B set
しても元には戻りません。
.TP
.B HISTCMD
現在のコマンドの履歴番号 (履歴リストにおけるインデックス) です。
.SM
.B HISTCMD
を
.B unset
すると、この変数の特殊な性質は無くなります。後で再び
.B set
しても元には戻りません。
.TP
.B FUNCNAME
現在実行中のシェル関数の名前です。
この変数はシェル関数を実行している間のみ存在します。
.SM
.B FUNCNAME
への代入は効果がなく、エラーステータスを返します。
.SM
.B FUNCNAME
を
.B unset
すると、この変数の特殊な性質は無くなります。後で再び
.B set
しても元には戻りません。
.TP
.B DIRSTACK
現在のディレクトリスタックの内容を持つ配列変数 (後述の
.B 配列
を参照) です。組み込みコマンド
.B dirs
を使うと、スタック中のディレクトリがスタック順に表示されます。
配列変数の要素に代入を行うと、
既にスタックに入っているディレクトリを変更できますが、
ディレクトリの追加と削除を行うためには、組み込みコマンドの
.B pushd
と
.B popd
を使わなければなりません。
この変数に代入を行っても現在の作業ディレクトリは変わりません。
.SM
.B DIRSTACK
を
.B unset
すると、この変数の特殊な性質は無くなります。後で再び
.B set
しても元には戻りません。
.TP
.B PIPESTATUS
フォアグラウンドのパイプラインで最後に実行されたプロセスの
終了ステータスのリストを含む配列変数です (後述の
.B 配列
を参照)。
.TP
.B OPTARG
組み込みコマンド
.B getopts
で処理した最後のオプション引き数の値です (後述の
.SM
.B シェルの組み込みコマンド
を参照)。
.TP
.B OPTIND
組み込みコマンド
.B getopts
で次に処理されるオプション引き数のインデックスです (後述の
.SM
.B シェルの組み込みコマンド
を参照)。
.TP
.B HOSTNAME
現在のホスト名が自動的に設定されます。
.TP
.B HOSTTYPE
.B bash
を実行するマシンの種類をユニークに記述する文字列が自動的に設定されます。
デフォルト値はシステム依存です。
.TP
.B OSTYPE
.B bash
を実行するオペレーティングシステムを記述する文字列が自動的に設定されます。
デフォルト値はシステム依存です。
.TP
.B MACHTYPE
.B bash
を実行するシステムの種類を完全に指定する文字列が、
GNU 標準の \fIcpu-company-system\fP の形式で設定されます。
デフォルト値はシステム依存です。
.TP
.B SHELLOPTS
コロン区切りのリストで、有効になっているシェルのオプションを示します。
リスト中のそれぞれの単語は、組み込みコマンド
.B set
の
.B \-o
オプション (後述の
.SM
.B シェルの組み込みコマンド
を参照) に対する有効な引き数になっています。
.SM
.B SHELLOPTS
に入っているオプションは、\fBset \-o\fP を実行した場合にも
.I on
であると報告されます。
この変数が
.B bash
の起動時に環境変数に入っていた場合、
どの起動ファイルを読むよりも前にリスト中のシェルオプションが有効になります。
この変数は読み込み専用です。
.TP
.B COMP_WORDS
現在のコマンドラインの各単語からなる配列変数
(後述の \fB配列\fP 参照) です。
この変数はプログラム補完機能 (後述の \fBプログラム補完\fP を参照)
から呼ばれたシェル関数においてのみ有効です。
.TP
.B COMP_CWORD
現在カーソル位置が置かれている単語の
\fB${COMP_WORDS}\fP におけるインデックスです。
この変数はプログラム補完機能 (後述の \fBプログラム補完\fP を参照)
から呼ばれたシェル関数においてのみ有効です。
.TP
.B COMP_LINE
現在のコマンドラインです。
この変数はプログラム補完機能 (後述の \fBプログラム補完\fP を参照)
から呼ばれたシェル関数においてのみ有効です。
.TP
.B COMP_POINT
現在のコマンドの先頭からの相対値として与えられた
カーソル位置のインデックスです。
現在のカーソル位置が現在の現在のコマンドの最後にある場合、
この変数の値は \fB${#COMP_LINE}\fP と等しくなります。
この変数はプログラム補完機能 (後述の \fBプログラム補完\fP を参照)
から呼ばれたシェル関数においてのみ有効です。
.PD
.PP
以下の変数はシェルが使用します。場合によっては、
.B bash
がデフォルト値を変数に代入します。このような場合については後述します。
.PP
.PD 0
.TP
.B IFS
.I 内部フィールド区切り文字 (Internal Field Separator)
です。展開を行った後に単語を分割する場合や、組み込みコマンドの
.B read
を使った時に行を単語に分割する場合に使われます。
デフォルト値は ``<空白><タブ><改行>'' です。
.TP
.B PATH
コマンドの検索パスです。
シェルがコマンドを検索するディレクトリをコロンで区切って並べたリストです
(後述の
.SM
.B コマンドの実行
を参照)。デフォルトのパスはシステム依存で、
.BR bash
をインストールしたシステム管理者が設定します。
一般的な値は
.if t \f(CW/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.\fP
.if n ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.''
です。
.TP
.B HOME
現在のユーザのホームディレクトリです。
組み込みコマンド \fBcd\fP のデフォルトの引き数になります。
この変数の値は、チルダ展開を実行するときにも使われます。
.TP
.B CDPATH
.B cd
コマンドの検索パスです。これは、
.B cd
コマンドで指定した対象ディレクトリを探すディレクトリを
コロンで区切って並べたリストです。
例えば、``.:~:/usr'' といった値になります。
.TP
.B BASH_ENV
\fBbash\fP がシェルスクリプトを実行する時にこの値が設定されている場合、
この値は
.RI ( ~/.bashrc
のように)
シェルを初期化するコマンドが書かれているファイル名と解釈されます。
.SM
.B BASH_ENV
の値をファイル名として処理する前には、パラメータ展開、コマンド置換、
算術的展開が行われます。
.SM
この結果のファイルを検索する際には
.B PATH
は使用されません。
.TP
.B MAIL
このパラメータにファイル名が設定されており、かつ変数
.SM
.B MAILPATH
が設定されていなければ、
.B bash
は指定されたファイルへのメールの到着をユーザに通知します。
.TP
.B MAILCHECK
.B bash
がメールをチェックする頻度を (秒数で) 指定します。
デフォルト値は 60 秒です。
メールをチェックする時間になると、
シェルはプライマリのプロンプトを表示する前にチェックを行います。
この変数が unset された場合、
あるいはこの変数に 0 より大きい数値以外が代入された場合は、
シェルはメールのチェックを行いません。
.TP
.B MAILPATH
メールのチェックに使うファイル名をコロンで区切って並べたリストです。
特定のファイルにメールが到着したときに出力される
メッセージは、`?' を使ってファイル名をメッセージから区切ることによって
指定できます。メッセージのテキスト中で使われたときは、
\fB$_\fP は現在のメールファイルの名前に展開されます。
設定例:
.RS
.PP
\fBMAILPATH\fP='/var/mail/bfox?"You have mail":~/shell\-mail?"$_ has mail!"'
.PP
この変数のデフォルト値は
.B bash
が与えますが、
.B bash
が使うユーザのメールファイルの位置はシステム依存です
(/var/mail/\fB$USER\fP 等)。
.RE
.TP
.B PS1
このパラメータの値は展開されてプライマリのプロンプト文字列として使われます。
(後述の
.SM
.B プロンプト
を参照)、
デフォルト値は ``\fB\es\-\ev\e$ \fP'' です。
.TP
.B PS2
このパラメータの値は
.B PS1
と同じように展開され、セカンダリのプロンプト文字列として使われます。
デフォルト値は ``\fB> \fP'' です。
.TP
.B PS3
このパラメータの値は
.B select
コマンド (前述の
.SM
.B シェルの文法
を参照) のプロンプトとして使われます。
.TP
.B PS4
このパラメータは
.B PS1
と同じように展開されます。この値は実行トレース中に
.B bash
が表示する各コマンド前に出力されます。
複数段の間接レベル (levels of indirection) を示すときは、
.SM
.B PS4
の最初の文字が必要に応じて複数回表示されます。
デフォルト値は ``\fB+ \fP'' です。
.TP
.B TIMEFORMAT
このパラメータの値は、予約語である
.B time
が先頭に付いているパイプラインに対して、
時間情報の表示の仕方を指定するフォーマット文字列として使われます。
\fB%\fP は、時間の値などに展開される
エスケープシーケンスを示すための文字です。
エスケープシーケンスとその意味を以下に示します。
ただし、ブレース ([]) は省略可能であることを表しま
す。
.sp .5
.RS
.PD 0
.TP 10
.B %%
\fB%\fP 文字そのもの。
.TP
.B %[\fIp\fP][l]R
経過した秒数。
.TP
.B %[\fIp\fP][l]U
ユーザモードで使われた CPU の秒数。
.TP
.B %[\fIp\fP][l]S
システムモードで使われた CPU の秒数。
.TP
.B %P
CPU のパーセンテージ。(%U + %S) / %R で算出されます。
.PD
.RE
.IP
\fIp\fP 省略可能で、\fI精度 (precision)\fP が何桁であるかを指定します。
つまり小数点以下の桁数を指定します。この値が 0 ならば、
小数点や小数の部分は出力されません。
また、小数点以下で指定できるのは 3 桁までです。
つまり、\fIp\fP の値が 3 より大きければ 3 に変更されます。
\fIp\fP を指定しなければ、この値は 3 となります。
.IP
\fBl\fP は省略可能ですが、指定すると、分を含み、
\fIMM\fPm\fISS\fP.\fIFF\fP という形式の長いフォーマットになります。
小数を含むかどうかは \fIp\fP の値によって決まります。
.IP
この変数が設定されていなければ、 \fBbash\fP は
\fB$'\enreal\et%3lR\enuser\et%3lU\ensys\t%3lS'\fP
という値が指定されているかのように動作します。
この値が空文字列ならば、時間の情報は表示されません。
フォーマット文字列の表示の際には、末尾に改行文字が追加されます。
.TP
.B HISTSIZE
コマンド履歴に記憶するコマンドの数 (後述の
.SM
.B HISTORY
を参照)。
.TP
.B HISTFILE
コマンド履歴が保存されるファイルの名前 (後述の
.SM
.B 履歴
を参照)。デフォルト値は \fI~/.bash_history\fP です。
設定されていない場合、
対話シェルが終了する時に履歴の保存が行われません。
.TP
.B HISTFILESIZE
履歴ファイルに保持する履歴の最大数です。この変数に値が代入された場合、
その行数を越えないように、必要に応じて履歴ファイルが切り詰められます。
デフォルト値は 500 です。対話シェルが終了する時にも、
履歴ファイルのサイズはファイル書き込みの後にこのサイズに切り詰められます。
.TP
.B OPTERR
値として 1 が設定されている場合、
.B bash
は組み込みコマンド
.B getopts
(後述の
.SM
.B シェルの組み込みコマンド
を参照) を使って生成したエラーメッセージを表示します。
シェルが起動されたり、シェルスクリプトが実行される度に、
.SM
.B OPTERR
は 1 に初期化されます。
.TP
.B LANG
\fBLC_\fP で始まる変数で特に選択されない任意のカテゴリに対して、
ロケールのカテゴリを決めるために使います。
.TP
.B LC_ALL
この変数はロケールのカテゴリを指定する \fBLC_\fP 変数と \fBLANG\fP の
値を全て上書きします。
.TP
.B LC_COLLATE
この変数はパス名展開の結果をソートするときに使用される照合順序と、
パス名展開とパターンマッチングにおける
範囲展開、同値クラス、照合シーケンスの動作決定します。
.TP
.B LC_CTYPE
この変数は、パス名展開とパターンマッチングにおける
文字の解釈と文字クラスの挙動を決めます。
.TP
.B LC_MESSAGES
この変数は、\fB$\fP の後に続くダブルクォートされた文字列の
翻訳に使うロケールを決めます。
.TP
.B LC_NUMERIC
この変数は数字のフォーマットに使用するロケールカテゴリを決定します。
.TP
.B LINES
組み込みコマンド
.B select
によって、選択されたリストを表示する際の行数の決定に用いられます。
SIGWINCH を受信すると自動的に設定されます。
.\"nakano 原文は column length.
.TP
.B COLUMNS
組み込みコマンド
.B select
によって、選択されたリストを表示する際の端末幅の決定に用いられます。
SIGWINCH を受信すると自動的に設定されます。
.B PROMPT_COMMAND
設定されていると、プライマリプロンプトを出す前に毎回、
この値がコマンドとして実行されます。
.TP
.B IGNOREEOF
単独で入力された
.SM
.B EOF
文字を受け取ったときの対話シェルの動作を制御します。
この変数が設定されていれば、指定されている値の数だけの
.SM
.B EOF
文字を連続して行頭の文字として入力しなければ
.B bash
は終了しません。この変数に数値以外の値が設定されている場合や、
値が設定されていない場合には、デフォルト値として 10 が使われます。
この変数が存在しなければ、
.SM
.B EOF
文字はシェルへの入力の終わりを示します。
.TP
.B TMOUT
0 より大きい値が設定されていると、
この値はプライマリプロンプトを出した後に入力を待つ秒数として解釈されます。
この秒数だけ待った時点で入力が無ければ
.B bash
は終了します。
.TP
.B FCEDIT
組み込みコマンド
.B fc
が使うデフォルトのエディタです。
.TP
.B FIGNORE
ファイル名補完 (後述の
.SM
.B READLINE
を参照) を行う際に無視するサフィックスを
コロンで区切って並べたリストです。
.SM
.B FIGNORE
のエントリのいずれかにサフィックスがマッチするファイル名は、
ファイル名補完にマッチするファイルのリストから除外されます。
例えば値として 
``.o:~'' を設定します。
.TP
.B GLOBIGNORE
パス名展開で無視するファイル名の集合を定義するパターンを
コロンで区切って並べたリストです。
パス名展開パターンにマッチするファイル名が
.SM
.BR GLOBIGNORE
内のパターンのどれかにもマッチする場合、
これはマッチしたもののリストから削除されます。
.TP
.B INPUTRC
.B readline
の起動ファイルのファイル名です。これはデフォルト値の
.FN ~/.inputrc
(後述の
.SM
.B READLINE
を参照) を上書きします。
.TP
.B HISTCONTROL
.IR ignorespace
の値が設定されていると、
.B 空白
文字で始まる行は履歴リストに入りません。
.IR ignoredups
の値が設定されていると、
履歴の最後の行にマッチする行は履歴リストに入りません。
.I ignoreboth
の値はこれらの 2 つのオプションを同時に実現します。
設定されていないか上記のいずれの値でもない場合には、
パーザが読み込んだ全ての行は
.BR HISTIGNORE
の値が示す条件の下で履歴リストに保存されます。
この変数は既に古くなっており、この機能は
.BR HISTIGNORE
変数で用いることになっています。
複数行にまたがる複雑なコマンドの場合は
2 番目以降の行が調べられることはありません。よって、これらは
.BR HISTCONTROL
の値に関わらず履歴に追加されます。
.TP
.B HISTIGNORE
どのコマンド行を履歴リストに保存するかを決めるために使うパターンを
コロンで区切って並べたリストです。
それぞれのパターンは行の先頭と比較され、
行全体が完全に一致しなければなりません
(`\fB*\fP' が暗黙的に追加されるこ
とはありません)。各パターンの評価は
.B HISTCONTROL
で指定したチェックが行われた後の行に対して実行されます。
通常のシェルのパターンマッチング文字以外に、
`\fB&\fP' が履歴の前の行にマッチします。
バックスラッシュを使って `\fB&\fP' をエスケープできます。
マッチングを試みる前にバックスラッシュは取り除かれます。
複数行にまたがる複雑なコマンドの場合、2 番目以降の行は調べられません。
よって、これらは
.BR HISTIGNORE
の値に関わらず履歴に追加されます。
.TP
.B histchars
2 文字または 3 文字で、
履歴の展開とトークン分割 (後述の
.SM
.B 履歴展開
を参照) を制御します。
最初の文字は \fI履歴展開 (history expansion)\fP 文字であり、
履歴展開の先頭を示す文字です。通常、これは `\fB!\fP' です。
2 番目の文字は \fI簡易置換 (quick substitution)\fP
文字であり、前に入力したコマンドの文字列を
別の文字列に置き換えて再実行を行うための省略表現として使います。
デフォルト値は `\fB^\fP' です。
3 番目の文字は省略可能です。単語の先頭でこの文字が見つかると、
行の残りの部分がコメントとなるような文字を指定します。
これは通常は `\fB#\fP' です。
履歴コメント文字があると、
その行の残りの単語に対する履歴置換はスキップされます。
この文字があるからといって、
必ずしもシェルのパーザが行の残りの部分をコメントとして扱うわけではありません。
.TP
.B HOSTFILE
.FN /etc/hosts
と同じフォーマットであり、
シェルがホスト名を補完する必要があるときに読み込むファイルの名前を示します。
シェルの実行中でも補完するホスト名のリストを変更できます。
この変数が変更された次の機会にホスト名の補完を試みるとき、
.B bash
は新しいファイルの内容を既存のデータベースに追加します。
.SM
.B HOSTFILE
が設定されているがその値が空文字列の場合、
\fBbash\fP は補完可能なホスト名のリストを取得するために
.FN /etc/hosts
を使用します。
.SM
.B HOSTFILE
が unset された場合は、ホスト名のリストはクリアされます。
.TP
.B auto_resume
この変数はシェルがユーザとジョブ制御の相互作用をどのように扱うかを決めます。
この変数を設定した場合、1 語からなるリダイレクト無しの単純なコマンドが、
停止中ジョブの実行再開候補として扱われます。
曖昧な指定は許されません。
入力された文字列で始まるジョブが複数ある場合には、
最後にアクセスされたものが選ばれます。
ここでの
.I 名前
とは、コマンドを起動する際に使ったコマンドラインのことです。
この値に
.IR exact
が設定されている場合、
与えられた文字列は停止しているジョブの名前に
正確にマッチしなければなりません。
.IR substring
が設定されている場合は、
与えられた文字列は停止しているジョブの名前の部分文字列に
マッチする必要があります。
.I substring
という値は、ジョブ識別子の
.B %?
に似た機能を持っています (後述の
.SM
.B ジョブ制御
を参照)。これ以外の値が設定されている場合、
与えられた文字列は停止しているジョブの名前の
プレフィックスでなければなりません。これはジョブ識別子の
.B %
と似た機能を持っています。
.TP
.B COMPREPLY
\fBbash\fP が可能な補完候補を読み込む配列変数です。
この値はプログラム補完機能 (後述の \fBプログラム補完\fP を参照)
によって呼び出されたシェル関数によって生成されます。
.PD
.SS 配列
.B bash
は 1 次元の配列変数を扱うことができます。
全ての変数は配列として使用できます。
.B declare
組み込みコマンドを使えば、明示的に配列を宣言できます。
配列のサイズの上限はありませんし、
メンバのインデックス付けや代入を
連続的にしなければならないという条件もありません。
配列のインデックス付けは 0 から始まる整数を用いて行います。
.PP
変数の代入の際に \fIname\fP[\fIsubscript\fP]=\fIvalue\fP
という記法が使われた場合、配列は自動的に生成されます。
.I subscript
は算術式として扱われますが、この式は評価すると
0 以上の数値になるものでなければなりません。
明示的に配列を宣言するには、
.B declare \-a \fIname\fP
を使います (後述の
.SM
.B シェルの組み込みコマンド
を参照)。
.B declare \-a \fIname\fP[\fIsubscript\fP]
も許されます。\fIsubscript\fP は無視されます。
組み込みコマンドの
.B declare
と
.B readonly
を使うと、配列変数に対して属性を設定できます。
どちらの属性も配列のメンバ全てに対して適用されます。
.PP
配列の代入は
\fIname\fP=\fB(\fPvalue\fI1\fP ... value\fIn\fP\fB)\fP
という形式の複合代入 (compound assignment) を用いて行います。
ここでそれぞれの
\fIvalue\fP の形式は [\fIsubscript\fP]=\fIstring\fP です。
必要なのは \fIstring\fP だけです。
ブラケット([])と添字を省略しなかった場合、
そのインデックスに対して代入が行われます。
省略した場合には、代入される要素のインデックスは、
その文の中で直前に代入されたインデックスに 1 を加えたものになります。
インデックスは 0 から始まります。
この記法は組み込みコマンド
.B declare
でも使えます。個別の配列要素に対する代入は、先に説明した
\fIname\fP[\fIsubscript\fP]=\fIvalue\fP の記法を使って行います。
.PP
配列の任意の要素は、${\fIname\fP[\fIsubscript\fP]}
を使って参照できます。
パス名展開との衝突を避けるためにブレースが必要です。
\fI添字(subscript)\fPが \fB@\fP か \fB*\fP ならば、その単語は
\fIname\fP の全ての要素に展開されます。これらの添字が異なるのは、
単語がダブルクォートの内部にある場合だけです。
単語がダブルクォートされていれば、${\fIname\fP[*]} は
1 つの単語に展開されます。
この単語は、配列の各メンバの値を特殊変数
.SM
.B IFS
の値で区切って並べたものです。${\fIname\fP[@]}は、
\fIname\fP の各要素を別々の単語に展開します。
配列のメンバが全く無いときは、${\fIname\fP[@]}
は空の単語に展開されます。
これは特殊パラメータ \fB*\fP や \fB@\fP に似ています (前述の
.B 特殊パラメータ
を参照)。${#\fIname\fP[\fIsubscript\fP]} は
${\fIname\fP[\fIsubscript\fP]} の長さに展開されます。
\fIsubscript\fP が \fB*\fP または \fB@\fP の場合は、
配列中の要素数に展開されます。添字無しで配列変数を参照すると、
要素 0 を参照したことになります。
.PP
組み込みコマンドの
.B unset
は配列の破棄に使われます。\fBunset\fP \fIname\fP[\fIsubscript\fP]
とすると、インデックスが \fIsubscript\fP である配列の要素が破棄されます。
\fBunset\fP \fIname\fP (\fIname\fP は配列) または
\fBunset\fP \fIname\fP[\fIsubscript\fP]
(\fIsubscript\fP が \fB*\fP または \fB@\fP) とすると、
配列全体が破棄されます。
.PP
組み込みコマンドの
.BR declare ,
.BR local ,
.B readonly
いずれにおいても、
.B \-a
オプションで配列を指定できます。組み込みコマンド
.B read
では、
.B \-a
オプションを使えば標準入力から読み込んだ単語のリストを
配列に代入できます。組み込みコマンド
.B set
と
.B declare
では、別の変数への代入に再利用できるような形で配列の値を表示します。
.SH 展開
展開はコマンドラインが単語へ分割された後に
(コマンドライン上で) 行われます。行われる展開は
7 種類あります:
.IR "ブレースの展開 (brace expansion)" ,
.IR "チルダの展開 (tilde expansion)" ,
.IR "パラメータと変数の展開 (parameter and variable expansion)" ,
.IR "コマンド置換 (command substitution)" ,
.IR "算術式展開 (arithmetic expansion)" ,
.IR "単語の分割 (word splitting)" ,
.IR "パス名の展開 (pathname expansion)" 。
.PP
展開の順序は次のようになります: ブレース展開、チルダ展開、パラメータ・
変数・算術式展開、コマンド置換 (左から右へ)、単語分割、パス名展開。
.PP
これらに加えて \fIプロセス置換 (process substitution)\fP
をサポートできるシステムもあります。
.PP
展開した部分の単語の数が変化することがあるのは、ブレース展開、
単語の分割、パス名展開だけです。他の展開では、
1 つの単語は 1 つの単語に展開されます。
この規則の唯一の例外は先に説明した
 "\fB$@\fP" と "\fB${\fP\fIname\fP\fB[@]}\fP" の展開 (
.SM
.B パラメータ
を参照) だけです。
.SS ブレース展開
.PP
.I "ブレース展開 (brace expansion)"
を使うと、任意の文字列を生成できます。この機構は
\fIパス名展開\fPに似ていますが、
生成されたファイル名が実在する必要はありません。
ブレース展開されるパターンは、
.IR "前置部分 (preamble: 省略可能)" 、
対になるブレースの間にコンマで区切って並べた文字列、
.I 後置部分 (postscript: 省略可能)
を順に並べたものです。
前置部分はブレース内にある文字列それぞれの先頭部分に追加され、
後置部分は左から右に順に展開されて得られた
それぞれの文字列の末尾に追加されます。
.PP
ブレースの展開は入れ子にできます。
展開して得られた文字列はソートされず、
左から右への順番がそのまま残ります。
例えば a\fB{\fPd,c,b\fB}\fPe は `ade ace abe' と展開されます。
.PP
ブレースの展開は他のどの展開よりも前に実行されます。
また、他の展開において特殊な意味を持つ文字もそのまま結果に残ります。
つまり、厳密にテキスト操作だけを行います。
.B bash
は、展開の文脈やブレースの間のテキストに対して
文法的な解釈を適用することは一切ありません。
.PP
正しい形のブレース展開には、クォートされていない開きブレースと
閉じブレース、また少なくとも 1 つのクォートされていないコンマが
含まれていなければなりません。正しい形でないブレース展開は全て、
変更されないでそのまま残ります。
\fB{\fP や \fB,\fP をバックスラッシュでクォートすれば、
ブレース展開の一部と解釈されないようにできます。
パラメータ展開との衝突を避けるため、文字列 \fB${\fP
はブレース展開の対象とは解釈されません。
.PP
この仕組みは、
生成される文字列の共通先頭部分が上記の例より長い場合に、
短縮表現としてよく使用されます:
.RS
.PP
mkdir /usr/local/src/bash/{old,new,dist,bugs}
.RE
あるいは
.RS
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
.RE
.PP
ブレース展開の導入によって、伝統的な
.B sh
とは少し非互換になった部分があります。
.B sh
は単語の一部として開きブレースや閉じブレースが現われても特別扱いはせず、
そのまま出力に残します。
.B bash
はブレース展開の結果として単語からブレースを取り除きます。例えば
.B sh
に \fIfile{1,2}\fP のように入力された単語はそのままの形で出力されますが、
.B bash
ではこの同じ単語は展開されて
.I file1 file2
のように出力されます。
厳密に
.B sh
と互換にしたければ、
.B bash
を
.B +B 
オプションを付けて起動するか、
.B set
コマンドに
.B +B
オプションを与えてブレース展開を無効にしてください
(後述する
.SM
.B シェル組み込みコマンド
を参照)。
.SS チルダ展開
.PP
クォートされていないチルダ (`\fB~\fP') で単語が始まった場合、
クォートされていないスラッシュよりも前にある文字すべて
(クォートされていないスラッシュが無ければすべての文字)
はチルダプレフィックス (\fItilde-prefix\fP) と解釈されます。
クォートされている文字がチルダプレフィックス中に無ければ、
チルダプレフィックス中のチルダ以降の文字は、
\fIログイン名 (login name)\fP になる可能性がある文字列として扱われます。
このログイン名が空文字列ならば、チルダはシェルパラメータ
.SM
.B HOME
の値に置き換えられます。
.SM
.B HOME
が設定されていない場合は、代わりにシェルを実行しているユーザの
ホームディレクトリに置き換えられます。
ログイン名が空でなければ、
チルダプレフィックスは指定されたログイン名に対応する
ホームディレクトリに置き換えられます。
.PP
チルダプレフィックスが `~+' ならば、チルダプレフィックスはシェル変数
.SM
.B PWD
の値に置き換えられます。
チルダプレフィックスが `~\-' ならば、シェル変数
.SM
.B OLDPWD
の値に置き換えられます (値が設定されていれば)。
チルダプレフィックス中のチルダより後の文字が数値 \fIN\fP であれば
(数値の前に `+' や `\-' を置くこともできます)、
チルダプレフィックスはディレクトリスタック内の対応する要素に置換されます。
置換される要素は、チルダプレフィックスを引き数として組み込みコマンド
.B dirs
を実行したときに表示されるものです。
チルダプレフィックスにおけるチルダ以降の文字が、
先行する `+' や `-' のない数値である場合は、`+' であるとみなされます。
.PP
ログイン名が有効でない場合や、チルダ展開が失敗した場合には、
単語は置き換えられません。
.PP
全ての変数代入において、
.B :
や
.B =
の直後にクォートされていないチルダプレフィックスがないかチェックが行われます。
もし見つかった場合にはこれらもチルダ展開されます。
したがって、
.SM
.BR PATH ,
.SM
.BR MAILPATH ,
.SM
.BR CDPATH
への代入にチルダを含むファイル名を使えば、
シェルは展開された値を代入します。
.SS パラメータの展開
.PP
`\fB$\fP' 文字があると、パラメータ展開、コマンド置換、
算術式展開が行われます。展開されるパラメータ名やシンボルは、
ブレースで括ることもできます。
ブレースは省略可能ですが、
変数の直後に変数名の一部と解釈できる文字が置かれた場合に、
その文字と共に変数が展開されてしまうのを防ぐために用意されています。
.PP
ブレースを使った場合、マッチングを終えるブレースは最初の `\fB}\fP' です。
ただしバックスラッシュでエスケープされているものや
クォートされている文字列中のものは含まれませんし、
算術式展開やコマンド置換、パラメータ展開に入っているものも含まれません。
.PP
.PD 0
.TP
${\fIparameter\fP}
\fIparameter\fP の値が置換されます。ブレースが必要になるのは、
.I parameter
が 2 桁以上の数字を持つ位置パラメータの場合や、
.I parameter
の直後の文字を名前の一部として解釈させたくない場合です。
.PD
.PP
\fIparameter\fP の最初の文字が感嘆符である場合、間接変数レベル
(level of variable indirection) という概念が導入されます。
\fBbash\fP は、展開に \fIparameter\fP  そのものの値を使用するのでなく、
\fIparameter\fP の感嘆符を除いた残りの文字を変数名として扱い、
その変数の値をその後の展開に使用します。
これが\fI間接展開 (indirect expansion)\fP と呼ばれるものです。
ただし ${!\fIprefix\fP*} の展開は例外です。これは以下で説明します。
.PP
以下に示すそれぞれの場合、\fIword\fP に対してチルダ展開、
パラメータ展開、コマンド置換、算術式展開が行われます。
部分文字列展開以外の場合、
\fBbash\fP はパラメータが設定されているか、空ではないかを調べます。
コロンを省略した場合には設定されているかどうかのみを調べます。
.PP
.PD 0
.TP
${\fIparameter\fP\fB:\-\fP\fIword\fP}
\fBデフォルトの値を使います\fP。
.I parameter
が設定されていないか空文字列であれば、
.I word
を展開したものに置換されます。そうでなければ、
.I parameter
の値に置換されます。
.TP
${\fIparameter\fP\fB:=\fP\fIword\fP}
\fBデフォルトの値を代入します\fP。
.I parameter
が設定されていないか空文字列であれば、
.I word
を展開したものが
.I parameter
に代入されます。それから
.I parameter
の値への置換が行われます。
位置パラメータや特殊パラメータへの代入をこのように行うことはできません。
.TP
${\fIparameter\fP\fB:?\fP\fIword\fP}
\fB空文字列または設定されていない場合にエラーを表示します\fP。
.I parameter
が空文字列または設定されていない場合、\fIword\fP を展開したもの
.RI ( word
がなければ
パラメータが空文字列または設定されていないことを示すメッセージ)
が標準エラー出力に出力されます。シェルが対話的でなければ、
シェルは終了します。パラメータに空文字列以外が設定されていれば、
\fIparameter\fP の値への置換が行われます。
.TP
${\fIparameter\fP\fB:+\fP\fIword\fP}
\fB別の値を使用します\fP。
.I parameter
が空文字列または設定されていなければ、空文字列に置換されます。
そうでなければ
.I word
を展開したものに置換されます。
.TP
.PD 0
${\fIparameter\fP\fB:\fP\fIoffset\fP}
.TP
${\fIparameter\fP\fB:\fP\fIoffset\fP\fB:\fP\fIlength\fP}
.PD
\fB部分文字列展開\fP。
\fIparameter\fP を展開したものから最大 \fIlength\fP 文字を取り出します。
先頭の文字は \fIoffset\fP で指定します。\fIlength\fP を省略すると、
\fIoffset\fP で指定した文字を先頭にして、
\fIparameter\fP の残り全部が含まれる部分文字列に展開します。
\fIlength\fP と \fIoffset\fP は算術式です (後述の
.SM
.B 算術式評価
を参照)。
\fIlength\fP の評価結果は 0 以上の数でなければなりません。
\fIoffset\fP を評価すると 0 未満の数になる場合、この値は
\fIparameter\fP の値の末尾からのオフセットとして使われます。
\fIparameter\fP が \fB@\fP ならば、結果は \fIoffset\fP から始まる
\fIlength\fP 個の位置パラメータになります。
\fIparameter\fP が @ または * のインデックスが付いている配列名ならば、
結果は配列の ${\fIparameter\fP[\fIoffset\fP]} を先頭とする要素
\fIlength\fP 個となります。位置パラメータを使う場合以外は、
部分文字列のインデックスは 0 から始まります。位置パラメータの場合には、
インデックスは 1 から始まります。
.TP
${\fB!\fP\fIprefix\fP\fB*\fP}
\fIprefix\fP で始まるすべての変数の名前に展開して、
.SM
.B IFS
特殊変数の最初の文字によって区切ります。
.TP
${\fB#\fP\fIparameter\fP}
\fIparameter\fP の値に含まれる文字数に置換されます。
.I parameter
が
.B *
または
.B @
ならば、位置パラメータの数に置換されます。
.I parameter
が
.B *
または
.B @
が添字になっている配列名ならば、配列中の要素数に置換されます。
.TP
.PD 0
${\fIparameter\fP\fB#\fP\fIword\fP}
.TP
${\fIparameter\fP\fB##\fP\fIword\fP}
.PD
.I word
が展開され、パス名展開の場合と同じようなパターンを作ります。
このパターンが
.I parameter
の値の先頭部分とマッチする場合、展開して得られる値は
.I parameter
を展開した値から最短一致パターン (``\fB#\fP''の場合)
または最長一致パターン (``\fB##\fP'' の場合)
を取り除いたものになります。
.I parameter
が
.B @
または
.BR *
である場合、
パターンを削除する操作は全ての位置パラメータに順番に適用され、
展開結果はリストとして得られます。
.I parameter
が
.B @
または
.B *
が添字になっている配列変数である場合、
パターンを削除する操作は配列の全ての要素に順番に適用され、
展開結果はリストとして得られます。
.TP
.PD 0
${\fIparameter\fP\fB%\fP\fIword\fP}
.TP
${\fIparameter\fP\fB%%\fP\fIword\fP}
.PD
.I word
が展開され、パス名展開の場合と同じようなパターンを作ります。
このパターンが
.I parameter
を展開した値の末尾の部分とマッチする場合、展開結果は
.I parameter
を展開した値から最短一致パターン (``\fB%\fP'' の場合)
または最長一致パターン (``\fB%%\fP'' の場合)
を取り除いたものになります。
.I parameter
が
.B @
または
.B *
である場合、
パターンを削除する操作は全ての位置パラメータに順番に適用され、
展開結果はリストとして得られます。
.I parameter
が
.B @
または
.B *
が添字になっている配列変数である場合、
パターンを削除する操作は配列の全ての要素に順番に適用され、
展開結果はリストとして得られます。
.TP
.PD 0
${\fIparameter\fP\fB/\fP\fIpattern\fP\fB/\fP\fIstring\fP}
.TP
${\fIparameter\fP\fB//\fP\fIpattern\fP\fB/\fP\fIstring\fP}
.PD
\fIpattern\fP が展開され、
パス名展開の場合と同じようなパターンを作ります。
\fIparameter\fP の展開が行われ、
その値のうち \fIpattern\fP に最長一致する部分が
\fIstring\fP に置換されます。
前者の形式の場合には、最初にマッチした部分だけが置換されます。
後者の形式の場合には、マッチした部分は全て \fIstring\fP に置換されます。
\fIpattern\fP が \fB#\fP で始まる場合には、パターンは \fIparameter\fP 
を展開した値の先頭にマッチしなければなりません。
\fIpattern\fP が \fB%\fP で始まる場合には、パターンは \fIparameter\fP 
を展開した値の末尾にマッチしなければなりません。
\fIstring\fP が空の場合には \fIpattern\fP にマッチした部分は削除されます。
またこの場合には、\fIpattern\fP の後に続く \fB/\fP は省略可能です。
.I parameter
が
.B @
または
.B *
である場合、置換操作は全ての位置パラメータに順番に適用され、
展開結果はリストとして得られます。
.I parameter
が
.B @
または
.B *
が添字になっている配列変数である場合、
置換操作は配列の全ての要素に順番に適用され、
展開結果はリストとして得られます。
.SS コマンド置換
.PP
\fIコマンド置換 (command substitution)\fP を用いると、
コマンド名をコマンドの出力で置き換えできます。
コマンド置換には以下の 2 つの形式があります:
.PP
.RS
.PP
\fB$(\fP\fIcommand\fP\|\fB)\fP
.RE
または
.RS
\fB`\fP\fIcommand\fP\fB`\fP
.RE
.PP
.B bash
による展開は、\fIcommand\fP の実行およびコマンド置換の部分を
コマンドの標準出力と置換することにより実行されます。
この際、末尾の改行文字は削除されます。
文字列の途中にある改行文字は削除されませんが、
単語分割の際に削除されることがあります。
コマンド置換 \fB$(cat \fIfile\fP)\fR は、同じ意味を持ち、
しかも高速な \fB$(< \fIfile\fP)\fR に置き換え可能です。
.PP
バッククォートを使う古い形式の置換を用いたとき、
バックスラッシュは文字通りの意味を保ちますが、
.BR $ ,
.BR ` ,
.B \e
の前にある場合は例外となります。
バックスラッシュが前置されていないバッククォートがあると、
そこでコマンド置換は閉じられます。
$(\^\fIcommand\fP\|) という形式を用いたときは、
括弧の間にある全ての文字がコマンドとなります。
特別扱いされる文字はありません。
.PP
コマンド置換は入れ子にできます。
バッククォート形式の時に入れ子を行うには、
内側のバッククォートをバックスラッシュでエスケープします。
.PP
置換がダブルクォート内部にある場合には、
置換の結果に対する単語分割とパス名展開は行われません。
.SS 算術式展開
.PP
算術式展開を使うと、算術式を評価して、その結果に置換できます。
算術式展開のフォーマットを次に示します:
.RS
.PP
\fB$((\fP\fIexpression\fP\fB))\fP
.RE
.PP
.I expression
はダブルクォート内部にある場合と同様に扱われますが、
括弧の内側のダブルクォートが特別扱いされることはありません。
式に含まれる全てのトークンに対して、
パラメータ展開・文字列展開・コマンド置換・クォートの削除が行われます。
算術式置換は入れ子にできます。
.PP
評価は後述の
.SM
.B "算術式評価"
で示す規則に基づいて行われます。
.I expression
が不正であれば、
.B bash
は評価の失敗を示すメッセージを出力し、置換を全く行いません。
.SS プロセス置換
.PP
\fIプロセス置換 (process substitution)\fP がサポートされるのは、
名前付きパイプ (\fIFIFO\fP) または名前付きオープンファイルの
\fB/dev/fd\fP メソッドをサポートしているシステムです。これは
\fB<(\fP\fIlist\^\fP\fB)\fP
または
\fB>(\fP\fIlist\^\fP\fB)\fP
の形になります。
プロセス \fIlist\fP は、その入力や出力が
\fIFIFO\fP または \fB/dev/fd\fP 中の
何らかのファイルに接続された状態で実行されます。
このファイルの名前は、展開の結果として、
引き数のかたちで現在のコマンドに渡されます。
\fB>(\fP\fIlist\^\fP\fB)\fP の形式を使った場合、
ファイルへの書き込みは \fIlist\fP への入力となります。
\fB<(\fP\fIlist\^\fP\fB)\fP の形式を使った場合、
引き数として渡されたファイルは
\fIlist\fP の出力を得るために読み込まれます。
.PP
利用可能であれば、プロセス置換 (process substitution) は、
パラメータ展開・変数展開・コマンド置換・算術式展開と同時に行われます。
.SS 単語の分割
.PP
シェルはパラメータ展開・コマンド置換・算術式展開
(ダブルクォートの内部ではこれらの展開は行われません)
の結果をスキャンし、
.I "単語分割"
を行います。
シェルは
.SM
.B IFS
のそれぞれの文字を区切り文字として扱い、
他の展開の結果をこれらの文字によって単語に分割します。
.SM
.B IFS
が設定されていないか、その値が正確にデフォルト値の
.BR <スペース><タブ><改行>
ならば、
.SM
.B IFS
文字の任意の列で単語が区切られます。
.SM
.B IFS
がデフォルト以外の値を持っていれば、空白文字
.RB ( スペース
および
.BR タブ )
の列は単語の先頭と末尾では無視されます。これは空白文字が
.SM
.BR IFS
の値 (
.SM
.B IFS
空白文字) に含まれる限り成り立ちます。
.SM
.B IFS
に含まれ、
.SM
.B IFS
空白文字ではない文字は全て、隣接する任意の
.SM
.B IFS
空白文字と一緒になってフィールドの区切りとなります。
.SM
.B IFS
空白文字の列も区切り文字として扱われます。
.SM
.B IFS
の値が空文字列であれば、単語分割は全く行われません。
.PP
明示的に指定した空の引き数(\^\f3"\^"\fP
または \^\f3'\^'\fP\^)は削除されずに残ります。
クォートされていない暗黙的な空の引き数が、
値を持たないパラメータを展開した結果として得られますが、
これらは削除されます。
値を持たないパラメータがダブルクォート内部で展開されると、
これは空である引き数となり、消されずに残ります。
.PP
展開が行われなければ単語分割も行われない点に注意してください。
.SS パス名展開
.PP
.B \-f
オプションが指定されていなければ、単語分割を行った後に
.B bash
はそれぞれの単語が
.BR * ,
.BR ? ,
.B [
を含んでいるかどうか調べます。
これらの文字のいずれかが見つかると、その単語は
.I パターン
と見なされ、
パターンにマッチするファイル名を
アルファベット順にソートしたリストに置換されます。
マッチするファイル名が見つからず、かつシェルのオプション
.B nullglob
が無効ならば、その単語は変更されずにそのまま残ります。
.B nullglob
オプションが設定されていて、かつマッチするファイル名が見つからなければ、
その単語は削除されます。
シェルのオプション
.B nocaseglob
が有効ならば、マッチングにおいてアルファベットの大文字と小文字は区別さ
れません。
パターンをパス名展開に使うとき、名前の先頭やスラッシュの直後の
.B ``.''
は明示的にマッチさせなければなりません。ただしシェルのオプション
.B dotglob
が設定されている場合は例外です。
パス名のマッチングを行うとき、
スラッシュ文字は必ず明示的にマッチさせなければなりません。
これ以外の場合には、
.B ``.''
が特別扱いされることはありません。
シェルのオプション
.BR nocaseglob ,
.BR nullglob ,
.B dotglob
の詳しい説明については、後述の
.SM
.B シェルの組み込みコマンド
に書かれている
.B shopt
の説明を参照してください。
.PP
シェル変数
.SM
.B GLOBIGNORE
を使って、
.I パターン
にマッチするファイル名の集合を制限できます。
.SM
.B GLOBIGNORE
が設定されていれば、マッチするファイル名のうち
.SM
.B GLOBIGNORE
中のパターンにもマッチしたものは、
マッチしたもののリストから取り除かれます。
ファイル名
.B ``.''
と
.B ``..''
は必ず無視されます。これは
.SM
.B GLOBIGNORE
が設定されていても同じです。しかし、
.SM
.B GLOBIGNORE
を設定するとシェルオプションの
.B dotglob
が有効になるので、
.B ``.''
で始まる他のファイル名は全てマッチします。
.B ``.''
で始めるファイル名を無視する古い動作をさせるには、
.B ``.*''
を
.SM
.B GLOBIGNORE
のパターンに含めてください。
.SM
.B GLOBIGNORE
が設定されていなければ、
.B dotglob
オプションは無効になります。
.PP
\fBパターンマッチング\fP
.PP
パターンに含まれる文字のうち、後述する特殊パターン文字以外の文字は、
自分自身にマッチします。NUL 文字がパターン中に現われてはいけません。
特殊パターン文字をその文字そのものにマッチさせるためには、
クォートしなければなりません。
.PP
特殊パターン文字は以下の意味を持っています:
.PP
.PD 0
.TP
.B *
空文字列を含む、任意の文字列にマッチします。
.TP
.B ?
任意の 1 文字にマッチします。
.TP
.B [...]
括られた文字のうち任意の 1 文字にマッチします。
2 つの文字の間にハイフンを入れたものは、
.I 範囲表現 (range expresion)
を表します。ソート順で 2 つの文字の間にある任意の文字と、
両端の 2 文字がマッチします。
ソートには現在のロケールの照合順序 (collating sequance)
と文字セットが用いられます。
.B [
の次の文字が
.B !
または
.B ^
ならば、括られた文字に含まれない任意の文字がマッチします。
範囲表現における文字のソート順は、
現在のロケール (およびシェル変数
.B LC_COLLATE
が指定されていればその値)
によって決定されます。
.B \-
は、文字集合の最初または最後の文字として含めると
マッチングの対象にできます。
.B ]
は、文字集合の最初の文字として含めるとマッチングの対象にできます。
.br
.if t .sp 0.5
.if n .sp 1
.B [
と
.B ]
の間では、\fI文字クラス (character classes)\fP を指定できます。
指定には \fB[:\fP\fIclass\fP\fB:]\fP という記法を使います。ここで
\fIclass\fP は POSIX.2 標準で定義されている以下のクラスのいずれかです:
.PP
.RS
.B
.if n alnum alpha ascii blank cntrl digit graph lower print punct space upper xdigit
.if t alnum   alpha   ascii   blank   cntrl   digit   graph   lower   print   punct   space   upper   xdigit
.br
文字クラスは、そのクラスの属する任意の文字にマッチします。
.br
.if t .sp 0.5
.if n .sp 1
.B [
と
.B ]
の間では、\fI同値クラス (equivalence class)\fP を指定できます。
指定には \fB[=\fP\fIc\fP\fB=]\fP という記法を使います。
これは現在のロケールにおける定義において \fIc\fP と同じ 
照合重さ (collation weight) を持つ全ての文字にマッチします。
.br
.if t .sp 0.5
.if n .sp 1
.B [
と
.B ]
の間では、\fB[.\fP\fIsymbol\fP\fB.]\fP という記述は照合シンボル
\fIsymbol\fP にマッチします。
.RE
.PD
.PP
組み込みコマンドの \fBshopt\fP を使ってシェルのオプション
\fBextglob\fP が有効にされていると、
拡張パターンマッチング演算子がいくつか認識されるようになります。
以下の説明では、\fIpattern-list\fP は
\fB|\fP で区切られた 1 つ以上のパターンのリストであるものとします。
以下のサブパターンを 1 つあるいは複数使うことにより、
複合パターンを作れます。
.sp 1
.PD 0
.RS
.TP
\fB?(\fP\^\fIpattern-list\^\fP\fB)\fP
与えられたパターンが 0 回または 1 回現われるとマッチします。
.TP
\fB*(\fP\^\fIpattern-list\^\fP\fB)\fP
与えられたパターンが 0 回以上現われるとマッチします。
.TP
\fB+(\fP\^\fIpattern-list\^\fP\fB)\fP
与えられたパターンが 1 回以上現われるとマッチします。
.TP
\fB@(\fP\^\fIpattern-list\^\fP\fB)\fP
与えられたパターンのうち 1 つだけにマッチします。
.TP
\fB!(\fP\^\fIpattern-list\^\fP\fB)\fP
与えられたパターンいずれにも含まれないもの全てにマッチします。
.RE
.PD
.SS クォートの削除
.PP
先に処理される展開の後、クォートされていない
.BR \e ,
.BR ' ,
\^\f3"\fP\^ 
のうち、先の展開の結果でないものは全て削除されます。
.SH リダイレクト
シェルが解釈する特別な記法を用いると、コマンドの実行前に入出力を
.I リダイレクト
できます。またリダイレクトを使うと、
現在のシェル実行環境に対してファイルをオープンしたり
クローズしたりできます。以下に示すリダイレクト演算子は、
.I 単純なコマンド
の前や途中に置くことができ、また
.I コマンド
の後に置けます。
リダイレクトは左から右へと、現われた順に処理されます。
.PP
以下の説明においては、ファイル・ディスクリプター番号が省略され、
かつリダイレクト演算子の最初の文字が
.B <
ならば、リダイレクトは標準入力 (ファイル・ディスクリプター 0) を参照します。
リダイレクト演算子の最初の文字が
.BR >
ならば、リダイレクトは標準出力 (ファイル・ディスクリプター 1) を参照します。
.PP
以下の説明では、リダイレクト演算子の次の単語に対しては、
特に説明しない限り、
ブレース展開・チルダ展開・パラメータ展開・コマンド置換・
算術式展開・クォート削除・パス名展開・単語分割が行われます。
ある単語が複数の単語に展開された場合はエラーになります。
.PP
リダイレクトの順番には意味がある点に注意してください。
例えば、次のコマンド
.RS
.PP
ls \fB>\fP dirlist 2\fB>&\fP1
.RE
.PP
は標準出力と標準エラー出力を両方ともファイル
.IR dirlist
に書き込みますが、次のコマンド
.RS
.PP
ls 2\fB>&\fP1 \fB>\fP dirlist
.RE
.PP
では標準出力だけがファイル
.IR dirlist
に書き込まれます。なぜなら後者の場合には、標準エラー出力は
.IR dirlist
にリダイレクトされる前の標準出力の複製となるからです。
.PP
\fBbash\fP は、
以下の表にあるようなファイル名がリダイレクトに使用されると、
それらを特別に扱います。
.RS
.PP
.PD 0
.TP
.B /dev/fd/\fIfd\fP
\fIfd\fP が有効な整数ならばファイル・ディスクリプター \fIfd\fP が複製されます。
.TP
.B /dev/stdin
ファイル・ディスクリプター 0 が複製されます。
.TP
.B /dev/stdout
ファイル・ディスクリプター 1 が複製されます。
.TP
.B /dev/stderr
ファイル・ディスクリプター 2 が複製されます。
.TP
.B /dev/tcp/\fIhost\fP/\fIport\fP
\fIhost\fP が有効なホスト名またはインターネットアドレスで
\fIport\fP が整数のポート番号ならば、
\fBbash\fP は対応するソケットに対して TCP 接続のオープンを試みます。
.TP
.B /dev/udp/\fIhost\fP/\fIport\fP
\fIhost\fP が有効なホスト名またはインターネットアドレスで
\fIport\fP が整数のポート番号ならば、
\fBbash\fP は対応するソケットに対して UDP 接続のオープンを試みます。
\" 訳注 UDP connection というのはナンセンス?!?
.PD
.RE
.PP
ファイルのオープンや作成に失敗すると、リダイレクトも失敗します。
.SS 入力のリダイレクト
.PP
入力をリダイレクトすると、
.I word
を展開した結果の名前を持つファイルがオープンされ、ファイル・ディスクリプター
.IR n
で読み込めるようになります。
.I n
が指定されていなければ、読み込みは標準入力
(ファイル・ディスクリプター 0) で行われます。
.PP
入力のリダイレクトは、一般的には以下の形式です:
.RS
.PP
[\fIn\fP]\fB<\fP\fIword\fP
.RE
.SS 出力のリダイレクト
.PP
出力をリダイレクトすると、
.I word
の展開した結果の名前を持つファイルがオープンされ、ファイル・ディスクリプター
.IR n
で書き込めるようになります。
.I n
が指定されていなければ、書きこみは標準出力
(ファイル・ディスクリプター 1) に行われます。
ファイルが存在しなかった場合は作成されます。
ファイルが存在した場合はサイズ 0 に切り詰められます。
.PP
出力のリダイレクトは、一般的には以下の形式です:
.RS
.PP
[\fIn\fP]\fB>\fP\fIword\fP
.RE
.PP
リダイレクト演算子が
.BR >
であり、かつ
.B noclobber
オプションが組み込みコマンド
.B set
に対して設定されている場合、\fIword\fP の展開で得たファイルが存在し、
かつそれが通常ファイルならば、リダイレクトは失敗します。
リダイレクト演算子が
.BR >|
の場合や、
リダイレクト演算子が
.B >
で組み込みコマンド
.B set
に対する
.B noclobber
オプションが設定されていない場合、
\fIword\fP という名前のファイルが存在していてもリダイレクトが試みられます。
.SS リダイレクトによる追加出力
.PP
この形式を使って出力のリダイレクトを行うと、
.I word
を展開した結果の名前を持つファイルがオープンされ、ファイル・ディスクリプター
.IR n
に対する出力がこのファイルに追加されるようになります。
.I n
を指定しなければ、標準出力 (ファイル・ディスクリプター 1) で追加されます。
ファイルが存在しなければ、新しく作られます。
.PP
追加出力は一般的には以下の形式です:
.RS
.PP
[\fIn\fP]\fB>>\fP\fIword\fP
.RE
.PP
.SS 標準出力と標準エラー出力のリダイレクト
.PP
この構造を使うと、
標準出力 (ファイル・ディスクリプター 1) と標準エラー出力
(ファイル・ディスクリプター 2) の両方を、
.I word
を展開した結果の名前を持つファイルにリダイレクトできます。
.PP
標準出力と標準エラー出力に対する形式は 2 つあります:
.RS
.PP
\fB&>\fP\fIword\fP
.RE
および
.RS
\fB>&\fP\fIword\fP
.RE
.PP
両者のうち望ましいのは前者の方です。これは次のものと同じ意味です:
.RS
.PP
\fB>\fP\fIword\fP 2\fB>&\fP1
.RE
.SS ヒアドキュメント(Here Documents)
.PP
この形式のリダイレクトを用いると、
シェルは現在のソースから入力を読み込みます。
この読み込みは
.I word
を単独で含む行 (末尾にブランク文字があってはいけません)
が現われるまで続きます。
その行までに読み込んだ行は、
コマンドの標準入力として扱われます。
.PP
ヒアドキュメントの形式を以下に示します:
.RS
.PP
.nf
\fB<<\fP[\fB\-\fP]\fIword\fP
        \fIhere\-document\fP
\fIdelimiter\fP
.fi
.RE
.PP
.I word
に対するパラメータ展開・コマンド置換・算術式展開・
パス名展開は全く行われません。
.I word
が一部でもクォートされている場合は、
.I delimiter
は
.I word
のクォートをほどいた結果 (クォート文字を削除した結果) となり、
ヒアドキュメントに含まれる行では展開が行われなくなります。
\fIword\fP がクォートされていなければ、
ヒアドキュメント中の全ての行に対して
パラメータ展開・コマンド置換・算術式展開が行われます。
後者の場合には
.B \e<newline>
という文字列は無視されます (出力から取り除かれます)。
また
.BR \e ,
.BR $ ,
.B `
といった文字は
.B \e
を用いてクォートしなければなりません。
.PP
リダイレクト演算子が
.BR <<\-
ならば、行頭にあるタブ文字は全て入力行および
.IR delimiter
を含む行から取り除かれます。
これにより、シェルスクリプト中のヒアドキュメントを
自然な形でインデントさせることができます。
.SS ファイル・ディスクリプターの複製
.PP
リダイレクト演算子
.RS
.PP
[\fIn\fP]\fB<&\fP\fIword\fP
.RE
.PP
を使うと入力ファイル・ディスクリプターを複製できます。
.I word
が 1 桁以上の数値に展開された場合、
.I n
で示されるファイル・ディスクリプターが生成され、
そのファイル・ディスクリプターのコピーとなります。
.I word
に含まれる数値が入力のためにオープンされたファイル・ディスクリプターを
指していない場合、リダイレクト・エラーが起きます。
.I word
を評価した結果が
.BR \-
となった場合、ファイル・ディスクリプター
.I n
はクローズされます。
.I n
が指定されていない場合、標準入力
(ファイル・ディスクリプター 0) が使われます。
.PP
同様に、演算子
.RS
.PP
[\fIn\fP]\fB>&\fP\fIword\fP
.RE
.PP
を使って出力ファイル・ディスクリプターを複製できます。
.I n
が指定されていない場合は、標準出力
(ファイル・ディスクリプター 1) が使われます。
.I word
に含まれる数値が、出力のためにオープンされた
ファイル・ディスクリプターを指していない場合、
リダイレクト・エラーが起きます。特別な場合ですが、
\fIn\fP が省略され、かつ \fIword\fP が
1 桁以上の数字には展開されなかった場合、
前に説明したように標準出力と標準エラー出力がリダイレクトされます。
.SS 読み書きのためのファイル・ディスクリプターのオープン
.PP
リダイレクト演算子が
.RS
.PP
[\fIn\fP]\fB<>\fP\fIword\fP
.RE
.PP
ならば、
.I word
を展開した結果の名前を持つファイルがファイル・ディスクリプター
.IR n
での読み書きのためにオープンされます。
.I n
が指定されていなければ、
ファイル・ディスクリプター 0 で読み書きが行われます。
ファイルが存在しなければ、新しく生成されます。
.SH エイリアス
\fIエイリアス(alias)\fP を使うと、
ある単語が単純なコマンドの先頭の単語として使われた場合に、
この文字列を別の単語に置換できます。
シェルはエイリアスのリストを管理しています。
このリストは組み込みコマンドの
.B alias
と
.B unalias
を使って設定および設定の取り消しできます (後述の
.SM
.B シェルの組み込みコマンド
を参照)。
各コマンドの最初の単語がクォートされていない場合、
エイリアスかどうかが確認され、
エイリアスならばその単語はそのエイリアスのテキストと置換されます。
エイリアス名と置換されるテキストには、
シェルの入力として有効なものは何でも含めることができます。
これには先に挙げた
.I メタ文字
も含まれますが、
例外としてエイリアス名に \fI=\fP を含めることはできません。
置換されるテキストの最初の単語に対しても
エイリアスかどうかの評価がされますが、
最初の単語が展開されるエイリアスと同じ場合には
展開は 1度しか行われません。つまり
.B ls
が
.BR "ls \-F"
のエイリアスとなっているような場合には、
.B bash
は置換される文字列を再帰的に展開することはありません。
エイリアスの値の最後の文字が
.I ブランク文字
の場合、エイリアスに続く次のコマンドの単語に対しても
エイリアス展開が試みられます。
.PP
エイリアスは
.B alias
コマンドで作成とリスト表示を行い、
.B unalias
コマンドで削除します。
.PP
置換されるテキストに引き数を入れる仕組みはありません。
引き数が必要ならば、シェル関数を使わなければなりません (後述の
.SM
.B 関数
を参照)
.PP
シェルが対話的でない時には、
.B shopt
コマンドによって
.B expand_aliases
オプションが設定されていない場合に限り、
エイリアスの展開は行われません (後述の
.SM
\fBシェルの組み込みコマンド\fP
における
.B shopt
の説明を参照)。
.PP
エイリアスの定義や利用に関係する規則には、紛らわしい点があります。
.B bash
は、ある行に書かれているコマンドを実行する前に必ず、
少なくとも 1 回は行全体を読み込みます。
エイリアスが展開されるのはコマンドを読み込んだ時であり、
実行する時ではありません。
したがって、別のコマンドと同じ行でエイリアス定義を行った場合には、
次の入力行が読み込まれるまではエイリアスの効果は現われません。
同じ行にあるエイリアス定義の後のコマンドは、
新しいエイリアスの影響を受けません。
この動作は関数を実行する場合にも問題になります。
エイリアスが展開されるのは関数定義が読み込まれる時であり、
関数が実行される時ではありません。
なぜなら、関数定義自身も複合コマンドだからです。
その結果として、関数内で定義されたエイリアスは、
その関数が実行されるまでは利用できません。
安全のため、エイリアス定義は独立した行で行うべきです。
複合コマンド内で
.B alias
を使ってはいけません。
.PP
ほとんど全ての用途において、
シェル関数でエイリアスを代用できます。
.SH 関数
シェル関数は、後で使うために一連のコマンドを保存するものです。
シェル関数の定義は既に
.SM
.BR シェルの文法
で説明しています。
シェル関数名が単純なコマンド名として使われた場合、
関数名に対応するコマンド群が実行されます。
関数は現在のシェルのコンテキスト内で実行されます。
つまり、新しいプロセスを生成して関数を処理することはありません
(これはシェルスクリプトと対照的な点です)。
関数の実行中には、関数に与えた引き数が位置パラメータとなります。
特殊パラメータ
.B #
は更新され、この変更が反映されます。
位置パラメータ 0 は変わりません。
関数の実行中は
.SM
.B FUNCNAME
変数に関数の名前が設定されます。
シェル実行環境の状態は全て、関数とその呼び出し側で同じになりますが、
例外として
.SM
.B DEBUG
トラップ (後述の
.SM
.B シェルの組み込みコマンド
の項で、組み込みコマンド
.B trap
の説明を参照) は継承されません。
.PP
関数ローカルの変数は、組み込みコマンド
.B local
で宣言できます。
普通は、変数とその値は関数とその呼び出し側で共有されます。
.PP
組み込みコマンド
.B return
が関数中で実行された場合、関数は終了し、
関数呼び出しの次のコマンドから実行が再開されます。
関数の終了時には、位置パラメータの値と特殊パラメータ
.B #
の値は、関数の実行前の値に戻ります。
.PP
関数の名前と定義をリスト表示するには、組み込みコマンドの
.B declare
や
.B typeset
を、オプション
.B \-f
を付けて実行します。
.B declare
や
.B typeset
をオプション
.B \-F
で実行すると、関数名だけがリスト表示されます。
関数をエクスポートして、
サブシェルでその関数が自動的に定義されている状態にできます。
これを行うには、組み込みコマンドの
.B export
に
.B \-f
オプションを付けて実行します。
.PP
関数は再帰させることができます。
再帰呼び出しの回数には制限はありません。
.SH 算術式評価
シェルにおいては、特定の状況下で算術式を評価させることができます
(組み込みコマンドの \fBlet\fP と \fB算術式展開\fP を参照)。
評価は long 型の整数として行われ、
オーバーフローのチェックは行われません。
ただし、0 での除算はトラップされ、エラーとしてのフラグが立てられます。
演算子とその優先度、結合規則は C 言語と同じです。
以下のリストは、
同じ優先度を持つ演算子をグループとしてまとめて列挙したものです。
優先度の高いものから順に列挙しています。
.PP
.PD 0
.TP
.B \fIid\fP++ \fIid\fP\-\-
変数を評価し、その後 increment (加算)/ decrement (減算) する。
.TP
.B ++\fIid\fP \-\-\fIid\fP
変数を increment (加算) / decrement (減算) してから評価する。
.TP
.B \- +
単項式の負と正
.TP
.B ! ~
論理的否定とビット単位の否定
.TP
.B **
指数 (累乗)
.TP
.B * / %
乗算、除算、剰余
.TP
.B + \-
加算と減算
.TP
.B << >>
左ビットシフトと右ビットシフト
.TP
.B <= >= < >
比較
.TP
.B == !=
等値と非等値
.TP
.B &
ビット単位の AND
.TP
.B ^
ビット単位の排他的 OR
.TP
.B |
ビット単位の OR
.TP
.B &&
論理的 AND
.TP
.B ||
論理的 OR
.TP
.B \fIexpr\fP?\fIexpr\fP:\fIexpr\fP
条件付き実行
.TP
.B = *= /= %= += \-= <<= >>= &= ^= |=
代入
.TP
.B \fIexpr1\fP , \fIexpr2\fP
コンマ
.PD
.PP
シェル変数をオペランドにすることもできます。
パラメータ展開は式の評価より前に行われます。
式の中では、パラメータの値は long 型の整数に強制的に変換されます。
式の中では、シェル変数を (パラメータ展開規則を用いずに)
変数名で参照できます。
変数の値は変数が参照された際に算術式として評価されます。
式で用いるためにシェル変数の整数属性を有効にする必要はありません。
.PP
先頭が 0 である定数は 8 進数として解釈されます。
先頭が 0x または 0X ならば 16 進数として解釈されます。
それ以外の場合には、数値は
[\fIbase#\fP]n の形式で表します。ここで \fIbase\fP は 2 から 64 の間の
10 進数であり、算術的な意味での基数を表します。
\fIn\fP はその基数における数を表します。
ある桁において 9 より大きい数字を表すには文字を使います。
文字を使う場合には、アルファベット小文字、大文字、_, @ をこの順番で使います。
\fIbase\fP が 36 以下の場合には、大文字と小文字は区別されず、
大文字と小文字のどちらを使っても
10 から 35 までの数字を表現できます。
.PP
演算子は優先度の順に評価されます。括弧内にある部分式は最初に評価され、
前述の優先規則よりも優先させることができます。
.SH 条件式
条件式は複合コマンド \fB[[\fP と組み込みコマンドの \fBtest\fP および
\fB[\fP によって使用でき、ファイルの属性を調べたり、
文字列比較や算術式比較を行ったりできます。
式は以下に示す単項のプライマリや二値のプライマリから構成されます。
プライマリのいずれかに対する
\fIfile\fP 引き数が \fI/dev/fd/n\fP という形式ならば、
ファイル・ディスクリプター \fIn\fP が調べられます。
プライマリのいずれかに対する \fIfile\fP 引き数が
\fI/dev/stdin\fP、\fI/dev/stdout\fP、\fI/dev/stderr\fP
のいずれかであれば、 対応するファイル・ディスクリプターが調べられます。
( \fI/dev/stdin\fP、\fI/dev/stdout\fP、\fI/dev/stderr\fP に対応する
ファイル・ディスクリプターはそれぞれ 0、1、2 です。)
.sp 1
.PD 0
.TP
.B \-a \fIfile\fP
\fIfile\fP が存在すれば真となります。
.TP
.B \-b \fIfile\fP
\fIfile\fP が存在し、かつブロック特殊ファイルならば真となります。
.TP
.B \-c \fIfile\fP
\fIfile\fP が存在し、かつキャラクタ特殊ファイルならば真となります。
.TP
.B \-d \fIfile\fP
\fIfile\fP が存在し、かつディレクトリならば真となります。
.TP
.B \-e \fIfile\fP
\fIfile\fP が存在すれば真となります。
.TP
.B \-f \fIfile\fP
\fIfile\fP が存在し、かつ通常ファイルならば真となります。
.TP
.B \-g \fIfile\fP
\fIfile\fP が存在し、かつ set-group-id されていれば真となります。
.TP
.B \-h \fIfile\fP
\fIfile\fP が存在し、かつシンボリックリンクならば真となります。
.TP
.B \-k \fIfile\fP
\fIfile\fP が存在し、かつ ``sticky''
ビットが設定されていれば真となります。
.TP
.B \-p \fIfile\fP
\fIfile\fP が存在し、かつ名前付きパイプ (FIFO) ならば真となります。
.TP
.B \-r \fIfile\fP
\fIfile\fP が存在し、かつ読み込み可能ならば真となります。
.TP
.B \-s \fIfile\fP
\fIfile\fP が存在し、かつそのサイズが 0 より大きければ真となります。
.TP
.B \-t \fIfd\fP
ファイル・ディスクリプター
.I fd
がオープンされており、かつ端末を参照していれば真となります。
.TP
.B \-u \fIfile\fP
\fIfile\fP が存在し、
かつ set-user-id ビットが設定されていれば真となります。
.TP
.B \-w \fIfile\fP
\fIfile\fP が存在し、かつ書き込み可能ならば真となります。
.TP
.B \-x \fIfile\fP
\fIfile\fP が存在し、かつ実行可能ならば真となります。
.TP
.B \-O \fIfile\fP
\fIfile\fP が存在し、かつ (実行中のシェルの)
実効ユーザ ID に所有されていれば真となります。
.TP
.B \-G \fIfile\fP
\fIfile\fP が存在し、かつ (実行中のシェルの)
実効グループ ID に所有されていれば真となります。
.TP
.B \-L \fIfile\fP
\fIfile\fP が存在し、かつシンボリックリンクならば真となります。
.TP
.B \-S \fIfile\fP
\fIfile\fP が存在し、かつソケットならば真となります。
.TP
.B \-N \fIfile\fP
\fIfile\fP が存在し、
かつ前回読み込まれた後に修正されていれば真となります。
.TP
\fIfile1\fP \-\fBnt\fP \fIfile2\fP
\fIfile1\fP が (変更日時に関して) \fIfile2\fP より新しければ真となります。
.TP
\fIfile1\fP \-\fBot\fP \fIfile2\fP
\fIfile1\fP が \fIfile2\fP より古ければ真となります。
.TP
\fIfile1\fP \fB\-ef\fP \fIfile2\fP
\fIfile1\fP と \fIfile2\fP とで
デバイス番号と i-ノード番号が同じならば真となります。
.TP
.B \-o \fIoptname\fP
シェルオプション
.I optname
が有効ならば真となります。後述する組み込みコマンド
.B set
に対するオプションの説明中にあるオプション一覧を参照してください。
.TP
.B \-z \fIstring\fP
\fIstring\fP の長さが 0 ならば真となります。
.TP
.B \-n \fIstring\fP
.TP
\fIstring\fP
.I string
の長さが 0 でなければ真となります。
.TP
\fIstring1\fP \fB==\fP \fIstring2\fP
文字列が同じならば真となります。\fB==\fP の代わりに \fB=\fP も使えます。
.TP
\fIstring1\fP \fB!=\fP \fIstring2\fP
2 つの文字列が異なれば真となります。
.TP
\fIstring1\fP \fB<\fP \fIstring2\fP
現在のロケールにおいて、\fIstring1\fP が \fIstring2\fP よりも
辞書順で前にある場合に真となります。
.TP
\fIstring1\fP \fB>\fP \fIstring2\fP
現在のロケールにおいて、\fIstring1\fP が \fIstring2\fP よりも
辞書順で後にある場合に真となります。
.TP
.I \fIarg1\fP \fBOP\fP \fIarg2\fP
.SM
.B OP
は
.BR \-eq ,
.BR \-ne ,
.BR \-lt ,
.BR \-le ,
.BR \-gt ,
.BR \-ge
のいずれかです。
これらの二値演算子が真を返すのはそれぞれ、
\fIarg1\fP が \fIarg2\fP に対して等しい場合、
等しくない場合、小さい場合、小さいか等しい場合、大きい場合、
大きいか等しい場合です。
.I arg1
や
.I arg2
には、正または負の整数を使用できます。
.PD
.SH 単純なコマンドの展開
単純なコマンドを実行すると、シェルは以下に示す展開、代入、
リダイレクションを左から右の順で実行します。
.IP 1.
パーザが変数代入 (コマンド名の前にあるもの)
またはリダイレクションと判断した単語は、
保存されて後で処理されます。
.IP 2.
変数代入でもリダイレクションでもない単語が展開されます。
もし展開の後に残っている単語があれば、
その最初の単語がコマンド名となり、残りが引き数となります。
.IP 3.
リダイレクションが前述の
.SM
.BR リダイレクション
で説明したように実行されます。
.IP 4.
変数代入の \fB=\fP の後にあるテキストに対して、チルダ展開、
パラメータ展開、コマンド置換、算術式展開、クォート削除が行われます。
この処理は変数を代入する前に行われます。
.PP
コマンド名が残らなかった場合には、
変数を代入した結果が現在のシェル環境に効果を及ぼします。
そうでない場合、変数は実行されるコマンドの環境に追加されるだけで、
現在のシェル環境には影響を与えません。
読み込み専用の変数に対して代入をしようとするとエラーが発生し、
そのコマンドは 0 でないステータスで終了します。
.PP
コマンド名が残らなかった場合、リダイレクションは行われますが、
現在のシェル環境は影響を受けません。
リダイレクションのエラーが起きると、
コマンドは 0 でないステータスで終了します。
.PP
展開の後にコマンド名が残っている場合、後述するように実行が進行します。
そうでない場合はコマンドは終了します。
展開のいずれかがコマンド置換である場合には、
コマンドの終了ステータスは
最後に実行されたコマンド置換の終了ステータスになります。
コマンド置換が行われなかった場合には、
コマンドはステータス 0 で終了します。
.SH コマンドの実行
コマンドが単語に分割された後に、
単純なコマンドとそれに対する引き数リスト
(引き数リストは省略可能) となった場合、以下の動作が行われます。
.PP
コマンド名にスラッシュが含まれない場合、
シェルはコマンドの位置を特定しようとします。
その名前のシェル関数が存在すれば、前に
.SM
.BR 関数
で説明したようにその関数が呼び出されます。
名前が関数にマッチしない場合には、
シェルはシェルの組み込みコマンドのリストを探します。
マッチするものがあった場合、その組み込みコマンドが呼び出されます。
.PP
名前がシェル関数も組み込みコマンドでなく、
かつスラッシュを含まない場合には、
.B bash
は
.SM
.B PATH
の各要素を検索し、その名前の実行ファイルを含むディレクトリを探します。
.B bash
はハッシュ表を使って実行ファイルの完全なパス名を記憶します (後述の
.SM
.B シェルの組み込みコマンド
の
.B hash
の項を参照)。
.SM
.B PATH
に含まれるディレクトリの完全な探索は、
そのコマンドがハッシュ表の中に無い場合にのみ行われます。
検索にも失敗すると、シェルはエラーメッセージを出力し、
終了ステータス 127 を返します。
.PP
検索に成功したか、コマンド名に 1 つ以上のスラッシュが含まれる場合には、
シェルは指定されたプログラムを独立した実行環境で実行します。
引き数 0 には指定された名前が設定され、
コマンドに対する残りの引き数には
(もしあれば) 指定された引き数が設定されます。
.PP
このファイルが実行可能フォーマットでないために実行が失敗し、
かつディレクトリでもない場合には、
このファイルは \fIシェルスクリプト(shell script)\fPであると見なされます。
シェルスクリプトとは、シェルのコマンドが書かれているファイルのことです。
シェルスクリプトを実行するためにサブシェルが呼び出されます。
このサブシェルは自分自身を再初期化し、
シェルスクリプトを処理するために
新しいシェルが起動されたかのような結果になります。ただし、
親が記憶しているコマンドの位置 (後述の
.SM
\fBシェルの組み込みコマンド\fP
における
.B hash
の項を参照) は子にも引き継がれます。
.PP
プログラムが
.BR #!
で始まるファイルである場合、
最初の行の残りの部分はこのプログラムのインタプリタを指定します。
シェルは指定されたインタプリタをオペレーティングシステム上で実行します。
オペレーティングシステムは、この実行可能フォーマットを直接処理しません。
インタプリタに対する引き数は、
プログラムの先頭の行のインタプリタ名の後の省略可能な引き数 1 つと、
その後のプログラム名、さらに
(もしあれば) その後のコマンドへの引き数から構成されます。
.SH コマンド実行環境
シェルは以下の要素からなる\fI実行環境(execution environment)\fPを持ちます:
.sp 1
.IP \(bu
起動時にそのシェルが継承したオープンされているファイル。
これは組み込みコマンド \fBexec\fP に与えられている
リダイレクション機能で変更されます。
.IP \(bu
現在の作業ディレクトリ (current working directory)。これは \fBcd\fP,
\fBpushd\fP, \fBpopd\fP で設定するか、
あるいは起動時にそのシェルが継承します。
.IP \(bu
ファイル作成モードのマスク。
これは \fBumask\fP で設定するか、あるいはそのシェルの親から継承します。
.IP \(bu
\fBtrap\fP で設定された現在のトラップ。
.IP \(bu
シェルのパラメータ。これは変数の代入か \fBset\fP で設定されるか、
あるいはその環境内にある親シェルから継承します。
.IP \(bu
実行中に定義されるか、その環境内にある親シェルから継承したシェル関数。
.IP \(bu
起動時に有効にしたか
(デフォルト値あるいはコマンドライン引き数で設定した値)、
\fBset\fP で有効にしたオプション。
.IP \(bu
\fBshopt\fP で有効にしたオプション。
.IP \(bu
\fBalias\fP で定義したシェルエイリアス。
.IP \(bu
各種プロセスID。これにはバックグラウンドジョブや \fB$$\fP の値、
\fB$PPID\fP の値が含まれます。
.PP
組み込みコマンドやシェル関数を除く単純なコマンドを実行するとき、
このコマンドは独立した実行環境内で呼び出されます。
この環境は以下の要素から成り立っています。
特に断らない限り、この値はシェルから引き継がれます。
.sp 1
.IP \(bu
シェルのオープンしているファイルと、
コマンドに対するリダイレクションで指定した変更・追加をこれに加えたもの。
.IP \(bu
現在の作業ディレクトリ
.IP \(bu
ファイル作成モードのマスク
.IP \(bu
エクスポートするシェル変数と、
そのコマンドに対してエクスポートされた変数。
これらは環境で渡されます。
.IP \(bu
シェルが捕捉したトラップは、
そのシェルの親から継承された値に再設定されます。
そのシェルが無視したトラップは無視されます。
.PP
この独立の環境内で呼び出されたコマンドが、
(親である) シェルの実行環境に影響を及ぼすことはできません。
.PP
コマンド置換と非同期コマンドは、サブシェル環境内で呼び出されます。
このサブシェル環境はシェル環境を複製したものです。ただし、
シェルが捕捉したトラップは、
そのシェルの起動時に親から継承した値に再設定されます。
パイプラインの一部として起動された組み込みコマンドは、
サブシェル環境で実行されます。サブシェル環境に対して行われた変更は、
元のシェル実行環境に影響を及ぼすことはできません。
.SH 環境
プログラムの起動時には、
.I 環境 (environment)
と呼ばれる文字列の配列が渡されます。
これは \fI変数名\fP\-\fI値\fP のペアからなるリストで、
.IR "変数名\fR=\fP値"
という形になります。
.PP
シェルは、環境を操作する様々な方法を提供しています。
起動時には、シェルは自分自身の環境を調べ、
見つかった名前それぞれに対してパラメータを生成し、
それに自動的に印を付けて子プロセスに
.I エクスポート (export)
します。実行されたコマンドは環境を継承します。
.B export
コマンドまたは
.B declare \-x
コマンドを用いると、
パラメータや関数の追加と削除を環境に対して行えます。
環境内のパラメータの値が変更されると、
新しい値は環境の一部となり、古い値と置き換わります。
実行されたコマンドが継承する環境は、
シェルの最初の環境から、
変数の値がシェル中で変更されたり、
一部のペアが
.B unset
コマンドで削除されたり、
.B export
コマンドや
.B declare \-x
コマンドで追加されたりしたものになります。
.PP
.I 単純なコマンド
や関数に対する環境は、一時的に修正できます。
これは、既に
.SM
.BR パラメータ
の項で説明したように、パラメータ代入を前に置くことで行います。
このような代入が影響を与えるのは、
そのコマンドが参照する環境だけです。
.PP
.B \-k
オプションを設定 (後述の組み込みコマンド
.B set
を参照) すると、コマンド名の前に置いたものだけではなく、
.I 全ての
パラメータ代入がそのコマンドの環境に影響を与えます。
.PP
.B bash
が外部コマンドを起動したときには、変数
.B _
にはコマンドの完全なファイル名が設定され、
環境変数としてそのコマンドに渡されます。
.SH 終了ステータス
シェルは、終了コード 0 で終了したコマンドは正常終了したとみなします。
終了コード 0 は成功を示します。
0 以外の終了コードは失敗を示します。
あるコマンドが致命的なシグナル \fIN\fP で終了したときには、
\fBbash\fP は「128+\fIN\fP」の値を終了ステータスに使います。
.PP
コマンドが見つからなかった場合には、
そのコマンドを実行するために生成された子プロセスが
ステータス 127 を返します。
コマンドが見つかったけれど実行できなかった場合には、
返却ステータスは 126 です。
.PP
展開やリダイレクションの際のエラーのために
コマンドが失敗した場合には、
0 より大きい終了ステータスが返されます。
.PP
シェルの組み込みコマンドは、
成功した場合にはステータス 0 (\fI真\fP) を返し、
実行中にエラーが起こった場合には 0 でない値 (\fI偽\fP) を返します。
.PP
\fBbash\fP 自身が返す終了ステータスは、文法エラーが起きなければ、
実行した最後のコマンドの終了ステータスです。
文法エラーの場合には 0 でない値が終了ステータスとなります。
後述の組み込みコマンド \fBexit\fP も参照してください。
.SH シグナル
\fBbash\fP が対話的であり、トラップが全く無いとき、\fBbash\fP は
.SM
.B SIGTERM
を無視し (したがって \fBkill 0\fP では対話シェルは kill されません)、
.SM
.B SIGINT
を捕捉、処理します
(したがって組み込みコマンド \fBwait\fP は割り込み可能です)。
どんな場合でも、\fBbash\fP は
.SM
.BR SIGQUIT
を無視します。
ジョブ制御が有効な状態ならば、
.B bash
は
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU ,
.SM
.BR SIGTSTP
を無視します。
.PP
\fBbash\fP が起動した同期ジョブは、
シェルが自分の親から継承した値をシグナルハンドラに設定します。
ジョブ制御が有効でないときには、非同期コマンドは
.SM
.B SIGINT
と
.SM
.B SIGQUIT
も無視します。
コマンド置換の結果として実行されたコマンドは、
キーボードで生成されたジョブ制御シグナルを無視します。
無視されるシグナルは
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU ,
.SM
.BR SIGTSTP
です。
.PP
デフォルトでは、シェルは
.SM
.BR SIGHUP
を受け取ると終了します。
終了する前には、シェルは実行中・停止中の全てのジョブに対して
.B SIGHUP
を再送信します。停止しているジョブには
.SM
.B SIGCONT
が送られ、このジョブが
.SM
.BR SIGHUP
を受け取るようにします。
特定のジョブに対してシェルからシグナルが送られないようにするためには、
組み込みコマンド
.B disown
(後述の
.SM
.B シェルの組み込みコマンド
を参照) を使って、そのジョブをジョブテーブルから削除するか、あるいは
.B "disown \-h"
を使って、
.SM
.B SIGHUP
を受け取らないようにマークを付けます。
.PP
シェルオプションの
.B huponexit
が
.BR shopt
を使って設定された場合、対話的なログインシェルが終了するときに、
.B bash
は
.SM
.B SIGHUP
を全てのジョブに送ります。
.PP
コマンドの完了を待っている間に、トラップが設定されたシグナルを
\fBbash\fP が受け取ったとき、
そのトラップはコマンドが完了するまで実行されません。
\fBbash\fP が組み込みコマンドの
\fBwait\fP を使って非同期コマンドを待っている時に、
トラップが設定されているシグナルを受け取ると、
組み込みコマンド \fBwait\fP は即座に復帰させられます。
この際の終了ステータスは 128 より大きい値になります。
また復帰するのはトラップが実行された直後です。
.SH ジョブ制御
.I ジョブ制御(job control)
とは、プロセスの実行を選択的に停止 (\fIサスペンド/suspend\fP) させ、
後に再び実行を続けさせる (\fIリジューム/resume\fP) 機能のことです。
ユーザは通常、システムの端末ドライバと
.B bash
を組み合わせて使い、対話的インタフェースを通してこの機能を利用します。
.PP
シェルはパイプラインごとに
.I ジョブ(job)
を構成します。シェルは現在実行中のジョブのテーブルを保存しています。
このテーブルは
.B jobs
コマンドを使ってリスト表示できます。
.B bash
がジョブを非同期的に
.RI ( バックグラウンド
で) 起動したときには、
.B bash
は以下のような行を出力します:
.RS
.PP
[1] 25647
.RE
.PP
これは、このジョブのジョブ番号は 1 であり、
このジョブを構成するパイプライン中の最後のプロセスの ID が
25647 であることを示しています。
1 つのパイプラインに含まれる全てのプロセスは同じジョブのメンバです。
.B bash
は、ジョブ制御の基礎として
.I ジョブ
という抽象化機構を使います。
.PP
ジョブ制御のためのユーザインタフェースの実装を容易にするために
オペレーティングシステムは
\fI現在の端末プロセスのグループ ID (current terminal process group ID)\fP
という情報を管理しています。
このプロセスグループのメンバ
(プロセスグループ ID が現在の端末プロセスのグループ ID と等しいプロセス) は、
.SM
.BR SIGINT
のような、キーボードで生成されたシグナルを受け取ります。
このようなプロセスは
.I フォアグラウンド (foreground)
にあると言われます。
.I バックグラウンド (background)
プロセスは、
プロセスのグループ ID が端末のグループ ID と異なるプロセスです。
このようなプロセスは、キーボードで生成したシグナルの影響を受けません。
端末への読み書きが許されるのはフォアグラウンドプロセスだけです。
バックグラウンドプロセスが端末からの読み込み
(端末への書き込み) を行おうとすると、
このプロセスには端末ドライバから
.SM
.B SIGTTIN (SIGTTOU)
シグナルが送られます。
このシグナルを捕捉しなければ、プロセスは停止します。
.PP
.B bash
を動かしているオペレーティングシステムがジョブ制御をサポートしているならば、
ユーザは
.B bash
を使ってジョブ制御を行えます。
プロセスの動作中に
.I サスペンド
文字(通常は
.BR ^Z , 
Control-Z) を打ち込むと、そのプロセスは停止させられ、
.B bash
に制御が戻ります。
.I "遅延サスペンド (delayed suspend)"
文字 (通常は
.BR ^Y , 
Control-Y) を打ち込むと、
そのプロセスは端末から入力を読み込もうとしたときに停止させられ、
制御が
.B bash
に戻ります。
このときユーザはこのジョブの状態を操作できます。
利用できるのは、バックグラウンドで実行を継続するならば
.B bg
コマンド、フォアグラウンドで実行を継続するならば
.B fg
コマンド、プロセスを kill するなら
.B kill
コマンドです。\fB^Z\fP の効果は即座に現われるので、
未出力の出力や先行入力した文字が破棄されるという副作用があります。
.PP
シェル上でジョブを参照する方法は色々あります。文字
.B %
はジョブ名の始まりを示します。ジョブ番号
.I n
は
.B %n
として参照できます。
ジョブの参照には、
ジョブを起動する時に使った名前の先頭部分や
コマンドライン中に現われる部分文字列を使うこともできます。
例えば、
.B %ce
は停止しているジョブ
.B ce
を指します。先頭の部分がマッチするジョブが複数個ある場合には、
.B bash
はエラーを報告します。一方、
.BR %?ce
を用いると、文字列
.B ce
をコマンドライン中に含む任意のジョブを参照できます。
部分文字列がマッチするジョブが複数個ある場合には、
.B bash
はエラーを報告します。シンボル
.B %%
および
.B %+
は、シェルが覚えている
.IR "カレントジョブ (current job)"
を指します。これは、フォアグラウンドで起動されている時に停止されたか、
バックグラウンドで起動された最後のジョブです。
.I "前のジョブ (previous job)"
は
.BR %\-
を使って参照できます。jobs コマンドの出力においては、
カレントジョブには必ず
.BR +
というフラグが付き、前のジョブには
.BR \-
というフラグが付きます。
.PP
単にジョブを呼べば、
そのジョブをフォアグラウンドに持ってきます。つまり、
.B %1
は
\fB``fg %1''\fP
と同義であり、
ジョブ 1 をバックグラウンドからフォアウグラウンドに持ってきます。
同様に
.B ``%1 &''
はジョブ 1 をバックグラウンドで実行再開させます。これは
\fB``bg %1''\fP
と同じ意味です。
.PP
ジョブの状態が変わると、シェルはそれを即座に知ります。
.B bash
がジョブの状態変化を報告するのは通常、プロンプトを出力する直前です。
これは他の出力を妨害しないためです。組み込みコマンド
.B set
で
.B \-b
オプションが指定されていると、
.B bash
はこのような変化を即座に報告します。
.PP
ジョブを停止させたままで
.B bash
を終了 (exit) させようとすると、シェルは警告メッセージを出力します。
このような時には、
.B jobs
コマンドを使ってジョブの状態を調べられます。
間にコマンドを挟まずに
.B bash
を再び終了させようとすると、
シェルは警告を繰り返さないで、
停止されているジョブを終了させます。
.SH プロンプト
対話的に動作している場合、
.B bash
はコマンドを読む込み準備ができた時にプライマリプロンプト
.SM
.B PS1
を表示し、コマンドを完成させるためにまだ入力が必要な時に
セカンダリプロンプト
.SM
.B PS2
を表示します。
.B bash
ではこれらのプロンプト文字列をカスタマイズできます。
この際にはバックスラッシュでエスケープされた
各種特殊文字を挿入でき、
これは以下のようにデコードされます:
.RS
.PD 0
.TP
.B \ea
ASCII のベル文字 (07)
.TP
.B \ed
"曜日 月 日" という形式の日付 (例: "Tue May 26")
.TP
.B \ee
ASCII のエスケープ文字 (033)
.TP
.B \eh
ホスト名のうち最初の `.' までの部分
.TP
.B \eH
ホスト名
.TP
.B \ej
シェルによって現在管理されているジョブの数
.TP
.B \el
シェルの端末デバイスのベース名 (basename)
.TP
.B \en
改行
.TP
.B \er
復帰
.TP
.B \es
シェルの名前。つまり
.B $0
のベース名 (最後のスラッシュ以降の部分)
.TP
.B \et
24 時間の HH:MM:SS 形式の現在の時刻
.TP
.B \eT
12 時間の HH:MM:SS 形式の現在の時刻
.TP
.B \e@
12 時間の HH:MM am/pm 形式の現在の時刻
.TP
.B \eu
現在のユーザのユーザ名
.TP
.B \ev
\fBbash\fP のバージョン (例: 2.00)
.TP
.B \eV
\fBbash\fP のリリース。バージョンにパッチレベルを加えたもの (例 : 2.00.0)
.TP
.B \ew
現在の作業ディレクトリ
.TP
.B \eW
現在の作業ディレクトリのベース名
.TP
.B \e!
このコマンドの履歴番号
.TP
.B \e#
このコマンドのコマンド番号
.TP
.B \e$
実効 UID が 0 の場合に
.BR # 、
それ以外の場合は
.B $
.TP
.B \e\fInnn\fP
8進数 \fInnn\fP に対応する文字
.TP
.B \e\e
バックスラッシュ
.TP
.B \e[
非表示文字のシーケンスの開始。
これを使うと、プロンプト中に端末の制御シーケンスを埋め込むことができます。
.TP
.B \e]
非表示文字のシーケンスを終了します。
.PD
.RE
.PP
コマンド番号と履歴番号は異なるのが普通です:
コマンドの履歴番号とは履歴リスト内での位置です。
履歴リストは履歴ファイルから読み込めます。
(後述の
.SM
.B 履歴
を参照)
一方コマンド番号は、
現在のシェルのセッション中に実行された一連のコマンドの列における位置です。
この文字列がデコードされた後、さらにパラメータ展開、コマンド置換、
算術式展開、クォート削除が適用されます。展開はシェルオプション
.B promptvars
(後述の
.SM
.B シェルの組み込みコマンド
の項にある
.B shopt
コマンドの説明を参照) の値に基づいて行われます。
.SH "READLINE ライブラリ"
readline は対話シェルを使うときに入力の読み込みを処理するライブラリです。
ただし、シェルの起動時に
.B \-\-noediting
オプションが指定された場合には使われません。
デフォルトでは、行編集に使うコマンドは emacs のコマンドに似ています。
vi 形式の行編集インタフェースも使えます。
シェルを起動した後に行編集機能を無効にするには、組み込みコマンド
.B set
(後述の
.SM
.B シェルの組み込みコマンド
を参照) に対して
.B +o emacs
オプションまたは
.B +o vi
オプションを設定してください。
.SS "Readline セクションにおける記法"
.PP
このセクションでは、emacs 形式の記法を使ってキーストロークを表します。
コントロールキーは C\-\fIkey\fR で表します
(例: C\-n は Control\-N の意味です)。同様に
.I メタ
キーは M\-\fIkey\fR で表すので、M\-x は Meta\-X を表すことになります。
.RI ( メタ
キーが無いキーボードでは、M\-\fIx\fP は ESC \fIx\fP を表します。つまり、
エスケープキーを押した後に
.I x
キーを押します。これは ESC を
\fIメタプレフィックス (meta prefix)\fP にする操作です。
M\-C\-\fIx\fP の組み合わせは、ESC\-Control\-\fIx\fP
あるいはエスケープキーを押した後に、コントロールキーを押したまま
.I x
を押すことを示します。)
.PP
Readline のコマンドには数値の
.I 引き数
を指定できます。通常これは繰り返しの回数として作用します。
ただし場合によっては、引き数の符号が意味を持つこともあります。
前方に作用するコマンド (例: \fBkill\-line\fP) に負の引き数を渡すと、
コマンドは後方に作用します。
引き数に対する動作がこの説明と異なるコマンドについては後で説明します。
.PP
コマンドがテキストを\fIキル (kill)\fP すると説明されている時は、
削除されたテキストは、
後で取り出せる (\fIヤンク (yank)\fP できる) ように保存されます。
キルされたテキストは、\fIキルリング (kill ring)\fP に保存されます。
連続してキルを行うと、テキストは 1 つのまとまりとして保存されるので、
全部を一度にヤンクできます。テキストをキルしないコマンドが挟まると、
キルリング上のテキストが分離されます。
.SS "Readline の初期化"
.PP
コマンドを初期化ファイル (\fIinputrc\fP ファイル) に追加すると、
readline をカスタマイズできます。このファイルの名前は、変数
.SM
.B INPUTRC
の値から決まります。この変数が設定されていない場合のデフォルト値は
.I ~/.inputrc
です。
readline ライブラリを使うプログラムが起動する際には、
この初期化ファイルが読み込まれ、キー割り当てと変数が設定されます。
readline の初期化ファイル中で使用できる基本的構文は、
以下のように少ししかありません。
空行は無視されます。
\fB#\fP で始まる行はコメントです。
\fB$\fP で始まる行は条件文です。
それ以外の行はキー割り当てと変数の設定です。
.PP
デフォルトのキー割り当ては
.I inputrc 
ファイルで変更できます。このライブラリを使う他のプログラムからも、
独自のコマンドとキー割り当てを追加できます。
.PP
例えば、
.RS
.PP
M\-Control\-u: universal\-argument
.RE
や
.RS
C\-Meta\-u: universal\-argument
.RE
を
.I inputrc
ファイルに書くと、M\-C\-u で readline の
.I universal\-argument
コマンドが実行されるようになります。
.PP
認識されるシンボリックな文字名を以下に示します:
.IR RUBOUT ,
.IR DEL ,
.IR ESC ,
.IR LFD ,
.IR NEWLINE ,
.IR RET ,
.IR RETURN ,
.IR SPC ,
.IR SPACE ,
.IR TAB 。
.PP
readline では、コマンド名だけでなくキーにも文字列を割り当てできます。
つまり、そのキーが押されると文字列が挿入されます
(\fIマクロ\fP, \fImacro\fP)。
.SS "Readline のキー割り当て"
.PP
.I inputrc
ファイルにおける制御キーの割り当て方は単純です。
必要なものは、コマンドの名前あるいはマクロのテキストと、
これらが割り当てられるキーシーケンスだけです。
名前は 2 通りの方法で指定できます。
つまり、シンボリックなキーの名前
(たぶん、これに \fIMeta\-\fP や \fIControl\-\fP
プレフィックスが付いたもの) による指定と、
キーシーケンスによる指定です。
.PP
「\fBkeyname\fP:\^\fIfunction\-name\fP」あるいは
「\fBkeyname\fP:\^\fImacro\fP」の形式を使うときには、
.I keyname
は英語で書き下したキーの名前となります。例を以下に示します:
.sp
.RS
Control-u: universal\-argument
.br
Meta-Rubout: backward-kill-word
.br
Control-o: "> output"
.RE
.LP
この例では、
.I C\-u
が
.B universal\-argument
に、
.I M\-DEL
が
.B backward\-kill\-word
に割り当てられます。
また、
.I C\-o
はマクロの実行に割り当てられ、右辺値に展開されます (つまり、テキスト
.if t \f(CW> output\fP
.if n ``> output''
が編集行に挿入されます)。
.PP
後者の形式である「\fB"keyseq"\fP:\^\fIfunction\-name\fP」または
「\fB"keyseq"\fP:\^\fImacro\fP」においては、
.B keyseq
は先程の
.B keyname
とは異なり、
ダブルクォートで括ってキーシーケンス全体を示す文字列を表記しています。
以下の例で示すように、GNU Emacs 形式のキーエスケープの一部を使えます。
ただしシンボリックな文字名は認識されません。
.sp
.RS
"\eC\-u": universal\-argument
.br
"\eC\-x\eC\-r": re\-read\-init\-file
.br
"\ee[11~": "Function Key 1"
.RE
.PP
この例でも、
.I C\-u
が
.B universal\-argument
機能に割り当てられています。
.I "C\-x C\-r"
は
.B re\-read\-init\-file
機能に割り当てられ、
.I "ESC [ 1 1 ~"
は
.B "Function Key 1"
.if t \f(CWFunction Key 1\fP.
.if n ``Function Key 1''.
という文字列の挿入に割り当てられています。
.PP
GNU Emacs 形式のエスケープシーケンスを以下に全て示します:
.RS
.PD 0
.TP
.B \eC\-
コントロールプレフィックス
.TP
.B \eM\-
メタプレフィックス
.TP
.B \ee
エスケープ文字
.TP
.B \e\e
バックスラッシュ
.TP
.B \e"
" という文字
.TP
.B \e'
\' という文字
.RE
.PD
.PP
GNU Emacs 形式のエスケープシーケンスに加えて、
別形式のバックスラッシュエスケープも使えます:
.RS
.PD 0
.TP
.B \ea
警告 (ベル)
.TP
.B \eb
バックスペース
.TP
.B \ed
削除 (delete)
.TP
.B \ef
フォームフィード
.TP
.B \en
改行
.TP
.B \er
復帰
.TP
.B \et
水平タブ
.TP
.B \ev
垂直タブ
.TP
.B \e\fInnn\fP
ASCII コードの 8 進値が \fInnn\fP である文字  (1 文字につき数字 3 桁)
.TP
.B \ex\fInnn\fP
ASCII コードの 16 進値が \fInnn\fP である文字 (1 文字につき数字 3 桁)
.RE
.PD
.PP
マクロのテキストを入力する際には、マクロ定義を示すために
シングルクォートやダブルクォートを使わなければなりません。
クォートされていないテキストは関数名と見なされます。
マクロ本体では、前述のバックスラッシュによるエスケープは展開されます。
バックスラッシュはマクロのテキスト内の他の文字を全てエスケープします。
これには " や ' も含まれます。
.PP
.B bash
では、組み込みコマンドの
.B bind
を使って、readline の現在の キー割り当ての表示と変更を行えます。
また組み込みコマンド
.B set
に対して
.B \-o
オプションを使えば、編集モードを対話的利用の途中に切替え可能です
(後述の
.SM
.B シェルの組み込みコマンド
を参照)。
.SS "Readline の変数"
.PP
Readline の動作をカスタマイズできる変数は他にもあります。
変数は
.I inputrc
ファイル中に
.RS
.PP
\fBset\fP \fIvariable\-name\fP \fIvalue\fP
.RE
.PP
という形式の文で設定できます。
特に断らない限り、readline の変数は
.B On
または
.B Off
のいずれかです。
変数とそのデフォルト値を以下に示します:
.PP
.PD 0
.TP
.B bell\-style (audible)
readline が端末のベルを鳴らそうとしたときの動作を制御します。
\fBnone\fP が設定されている場合は、readline はベルを鳴らしません。
\fBvisible\fP が設定されている場合には、可能であれば可視ベル
(visible bell) が用いられます。\fBaudible\fP が設定されている場合には、
readline は端末のベルを鳴らそうとします。
.TP
.B comment\-begin (``#'')
readline の
.B insert\-comment
コマンドが実行されたときに挿入される文字列です。
このコマンドは emacs モードでは
.B M\-#
に割り当てられ、vi コマンドモードでは
.B #
に割り当てられます。
.TP
.B completion\-ignore\-case (Off)
\fBOn\fP が設定されていると、
readline がファイル名のマッチングと補完を行う際に
大文字と小文字が区別されません。
.TP
.B completion\-query\-items (100)
\fBpossible\-completions\fP コマンドが生成した補完候補の数が、
いくつを越えると表示の可否をユーザに問い合わせるのかを決めます。
この変数には 0 以上の任意の整数を設定できます。
補完の候補数がこの変数の値以上の場合には、
ユーザに対して候補を表示するかどうかの問い合わせがなされます。
そうでない場合には、単に端末に補完の候補がリスト表示されます。
.TP
.B convert\-meta (On)
\fBOn\fP を設定すると、readline は
8 番目のビットがセットされている文字を
ASCII のキーシーケンスに変換します。
変換は、8 番目のビットを落として、
エスケープ文字を前に追加することによって行います
(実際にはエスケープ文字を\fIメタプレフィックス\fPとして用います)。
.TP
.B disable\-completion (Off)
\fBOn\fP を設定すると、readline は単語の補完を行わなくなります。
補完される文字の編集行への挿入は、
その文字を \fBself-insert\fP に割り当てたかのように行われます。
.TP
.B editing\-mode (emacs)
readline の起動時に \fIemacs\fP と
\fIvi\fP のどちらに似たキー割り当てを使うのかを制御します。
.B editing\-mode
には
.B emacs
と
.BR vi
のいずれかを指定できます。
.TP
.B enable\-keypad (Off)
\fBOn\fP を設定すると、
readline は呼び出された時にアプリケーションキーパッドを有効にしようとします。
一部のシステムでは、矢印キーを使うためにこれを有効にする必要があります。
.TP
.B expand\-tilde (Off)
\fBon\fP を設定すると、
readline が単語の補完を試みるときにチルダ展開が行われます。
.TP
.B horizontal\-scroll\-mode (Off)
\fBon\fP が設定されている時、readline は表示の際に行を
1 つしか使わないようになります。つまり行がスクリーンの幅より長くなると、
新しい行に折り返すのではなく、1 つの入力行の中で横にスクロールします。
.TP
.B input\-meta (Off)
\fBOn\fP が設定されていると、readline は 8 ビットの入力が可能になりま
す(つまり、読み込んだ文字の再上位ビットを落としません)。この動作は、端
末のサポートとは無関係に行われます。
.B meta\-flag
という名前は、この変数の別名です。
.TP
.B isearch\-terminators (``C\-[C\-J'')
インクリメンタル検索を終了させる文字からなる文字列です
(終了後にその文字がコマンドとして実行されることもありません)。
この変数に値が設定されていなければ、
\fIESC\fP と \fIC\-J\fP でインクリメンタル検索が終わります。
.TP
.B keymap (emacs)
現在の readline のキーマップを設定します。
正しいキーマップ名を全て挙げると、
\fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi,
vi\-command, vi\-insert\fP となります。\fIvi\fP は \fIvi\-command\fP
と等価で、\fIemacs\fP は \fIemacs\-standard\fP と等価です。
デフォルト値は
.IR emacs
です。
.B editing\-mode
の値もデフォルトキーマップに影響を与えます。
.TP
.B mark\-directories (On)
\fBOn\fP が設定されていると、
補完されたディレクトリ名の末尾にスラッシュが追加されます。
.TP
.B mark\-modified\-lines (Off)
\fBOn\fP が設定されていると、履歴行を表示する際に、
以前に変更されたものの先頭にアスタリスク (\fB*\fP) を付けて表示します。
.TP
.B output\-meta (Off)
\fBOn\fP が設定されていると、
readline は 8 番目のビットが立っている文字を直接表示します。
メタ文字を前置したエスケープシーケンスでの表示は行いません。
.TP
.B print\-completions\-horizontally (Off)
\fBOn\fP が設定されていると、
readline は補完でマッチするものをアルファベット順にして、
縦方向ではなく横方向に並べて表示します。
.TP
.B show\-all\-if\-ambiguous (Off)
これは補完機能のデフォルトの挙動を変えます。
.B On
が設定されている場合、単語に対する補完候補が複数個あると、
マッチするものが即座にリスト表示されます。ベルは鳴らされません。
.TP
.B visible\-stats (Off)
\fBOn\fP が設定されていると、
\fIstat\fP(2) で得られるファイルの種類を表す文字が、
補完候補のリスト表示の際に追加されます。
.PD
.SS Readline の条件構文
.PP
Readline には、
C 言語のプリプロセッサの条件付きコンパイル機能と
似たコンセプトに基づく機能が実装されています。
これを使うとキー割り当てや変数の設定を評価の結果として実行できます。
パーザディレクティブは 4 つあります。
.IP \fB$if\fP
.B $if
構文を使うと、編集モードや使っている端末、
readline を使っているアプリケーションに基づいた割り当てを行えます。
評価文のテキストは行の最後までです。
これを分離するには文字は必要ありません。
.RS
.IP \fBmode\fP
\fB$if\fP ディレクティブの \fBmode=\fP 形式は、
readline が emacs モードか
vi モードのどちらになっているかを調べるために使います。
例えばこれを \fBset keymap\fP コマンドと一緒に使い、
readline が emacs モードで始まった時だけ
キーの割り当てを \fIemacs\-standard\fP や 
\fIemacs\-ctlx\fP キーマップに設定できます。
.IP \fBterm\fP
\fBterm=\fP 形式を使うと、
端末固有のキー割り当てを入れることができます。
これは端末のファンクションキーが出力する
キーシーケンスを割り当てる場合などに使えます。
.B =
の右辺の単語は、
端末の完全な名前および最初の
\fB\-\fP の前までの部分的な名前の両方に対して評価されます。
これにより例えば、
.I sun
は
.I sun
と
.I sun\-cmd
の両方にマッチできます。
.IP \fBapplication\fP
\fBapplication\fP はアプリケーション固有の設定を入れるために使います。
readline ライブラリを使っているプログラムはそれぞれ
\fIアプリケーション名 (application name)\fP を設定するので、
初期化ファイルはそれが特定の値かどうかを調べられます。
これを使って、キーシーケンスを特定のプログラム用の
便利な機能に割り当てできます。例えば以下のコマンドは、
bash 内で現在または 1 つ前の単語をクォートするキーシーケンスを追加します:
.sp 1
.RS
.nf
\fB$if\fP Bash
# Quote the current or previous word
"\eC\-xq": "\eeb\e"\eef\e""
\fB$endif\fP
.fi
.RE
.RE
.IP \fB$endif\fP
このコマンドは上の例で見たように、\fB$if\fP コマンドを終了させます。
.IP \fB$else\fP
\fB$if\fP ディレクティブのこの分岐内におけるコマンドは、
評価が失敗した時に実行されます。
.IP \fB$include\fP
このディレクティブはファイル名 1 つを引き数に取り、
そのファイルからコマンドとキー割り当てを読み込みます。
例えば以下のディレクティブを使うと
\fI/etc/inputrc\fP が読み込まれます:
.sp 1
.RS
.nf
\fB$include\fP \^ \fI/etc/inputrc\fP
.fi
.RE
.SS 検索
.PP
readline には、指定した文字列を含む行をコマンド履歴内から探すコマンド
が用意されています (後述の
.SM
.B 履歴
を参照)。検索のモードには、
.I インクリメンタル (incremental)
モードと
.I 非インクリメンタル (non-incremental)
モードの 2 つがあります。
.PP
インクリメンタル検索は、
ユーザが検索文字列の入力を終えるより前に検索を開始します。
検索文字列に文字が追加されるたびに、
readline は現在まで入力した文字列にマッチする履歴から
次のエントリを表示します。インクリメンタル検索で必要なのは、
探している履歴エントリを見つけるために必要な数の文字だけです。
インクリメンタル検索を終了させるには、
\fBisearch-terminators\fP の値に入っている文字を使います。
この変数に値が代入されていない場合には、エスケープ文字または
Control-J でインクリメンタル検索が終了します。
Control-G はインクリメンタル検索を異常終了させ、元の行を復元します。
検索が終了すると、検索文字列を含む履歴エントリが現在の行になります。
.PP
マッチした他の履歴リストのエントリを見つけるには、Control-S または
Control-R を適宜入力します。これにより、
今まで入力した検索文字列にマッチする次のエントリを
履歴の前方または後方に向かって探します。
readline に割り当てられた他のキーシーケンスを入力すると検索が終わり、
そのコマンドが実行されます。例えば、\fI改行\fPは検索を終了させて、
その行を入力します。これにより、履歴リスト中のコマンドが実行されます。
.PP
インクリメンタルでない検索の場合には、
履歴行にマッチするものの検索を始める前に検索する文字列全体を読み込みます。
検索文字列には、ユーザが入力したものか、現在の行の内容の一部を使えます。
.SS "Readline のコマンド名"
.PP
以下に示すのは、
コマンドの名前およびそれらが割り当てられている
デフォルトのキーシーケンスの一覧です。
対応するキーシーケンスが無いコマンド名には、
デフォルトではキーは割り当てられていません。
以下の説明では、\fIポイント (point)\fP は現在のカーソルの位置を表し、
\fIマーク (mark)\fP は
\fBset\-mark\fP コマンドによって保存されたカーソル位置を表します。
ポイントとマークの間のテキストは、\fIリージョン (region)\fP で表します。
.SS 移動コマンド
.PP
.PD 0
.TP
.B beginning\-of\-line (C\-a)
現在の行の先頭に移動します。
.TP
.B end\-of\-line (C\-e)
行の末尾に移動します。
.TP
.B forward\-char (C\-f)
1 文字進みます。
.TP
.B backward\-char (C\-b)
1 文字戻ります。
.TP
.B forward\-word (M\-f)
次の単語の最後に進みます。単語は英数字 (文字と数字) からなります。
.TP
.B backward\-word (M\-b)
現在の単語あるいは前の単語の先頭に戻ります。
単語は英数字 (文字と数字) からなります。
.TP
.B clear\-screen (C\-l)
現在の行を画面の一番上の行に残したまま、画面をクリアします。
引き数を付けると、画面をクリアせずに現在の行を再描画します。
.TP
.B redraw\-current\-line
現在の行を再描画します。
.PD
.SS 履歴操作のためのコマンド
.PP
.PD 0
.TP
.B accept\-line (Newline, Return)
カーソルの位置に関わらず、行を入力します。この行が空でなければ、変数
.SM
.B HISTCONTROL
の状態に従って、これが履歴リストに追加されます。
行が履歴リストを変更したものならば、履歴行は元の状態に戻されます。
.TP
.B previous\-history (C\-p)
履歴リストを戻り、履歴リストから前の行を取り出します。
.TP
.B next\-history (C\-n)
履歴リストを進み、履歴リストから次の行を取り出します。
.TP
.B beginning\-of\-history (M\-<)
履歴の最初の行に移動します。
.TP
.B end\-of\-history (M\->)
入力履歴の最後に移動します。つまり、現在入力中の行に移動します。
.TP
.B reverse\-search\-history (C\-r)
現在の行を開始点にして後方に向かって検索を行い、
必要に応じて履歴を「遡って」いきます。これはインクリメンタル検索です。
.TP
.B forward\-search\-history (C\-s)
現在の行を開始点にして前方に向かって検索を行い、
必要に応じて履歴を「下って」いきます。これはインクリメンタル検索です。
.TP
.B non\-incremental\-reverse\-search\-history (M\-p)
現在の行を開始点にして、履歴リストを後方に向かって検索を行います。
この際には、ユーザが入力した文字列を
非インクリメンタルモードで検索します。
.TP
.B non\-incremental\-forward\-search\-history (M\-n)
現在の行を開始点にして、履歴リストを前方に向かって検索を行います。
この際には、ユーザが入力した文字列を
非インクリメンタルモードで検索します。
.TP
.B history\-search\-forward
履歴を前方に向かって検索し、
現在の行の先頭とポイントの間の文字列を探します。
これは非インクリメンタル検索です。
.TP
.B history\-search\-backward
履歴を後方に向かって検索し、
現在の行の先頭およびポイントの間の文字列を探します。
これは非インクリメンタル検索です。
.TP
.B yank\-nth\-arg (M\-C\-y)
前のコマンドに対する最初の引き数 (通常は前の行の 2 番目の単語)
をポイントに挿入します。引き数
.I n
が付いていると、前のコマンドの \fIn\fP 番目の単語
(前のコマンドの単語は 0 から数えます)。
引き数が負ならば、前のコマンドの最後から
\fIn\fP 番目の単語が挿入されます。
.TP
.B
yank\-last\-arg (M\-.\^, M\-_\^)
前のコマンドの最後の引き数
(一つ前の履歴エントリの最後の単語) を挿入します。
引き数があると、\fByank\-nth\-arg\fP と全く同じように動作します。
\fByank\-last\-arg\fP を繰り返して呼び出すと、
履歴リストを遡って参照が行われ、
それぞれの行の最後の引き数が順番に挿入されます。
.TP
.B shell\-expand\-line (M\-C\-e)
シェルのように行を展開します。
エイリアスや履歴の展開など、シェルの行う単語展開を行います。
履歴の展開の説明については、後述の
.SM
.B 履歴の展開
を参照してください。
.TP
.B history\-expand\-line (M\-^)
現在の行で履歴の展開を行います。
履歴の展開の説明については、後述の
.SM
.B 履歴の展開
を参照してください。
.TP
.B magic\-space
現在の行で履歴の展開を行い、空白を挿入します。
履歴の展開の説明については、後述の
.SM
.B 履歴の展開
を参照してください。
.TP
.B alias\-expand\-line
現在の行でエイリアスの展開を行います。
エイリアスの展開の説明については、前述の
.SM
.B エイリアス
を参照してください。
.TP
.B history\-and\-alias\-expand\-line
現在の行で履歴とエイリアスの展開を行います。
.TP
.B insert\-last\-argument (M\-.\^, M\-_\^)
\fByank\-last\-arg\fP と同じものです。
.TP
.B operate\-and\-get\-next (C\-o)
現在の行を実行し、
現在の行の次の行を編集するために履歴から取得します。
引き数は全て無視されます。
.PD
.SS テキスト編集のためのコマンド
.PP
.PD 0
.TP
.B delete\-char (C\-d)
ポイントの文字を削除します。
ポイントが行の先頭であり、その行に文字が無く、
さらに打ち込んだ最後の文字が
\fBdelete\-char\fP に割り当てられていなければ、
.SM
.B EOF
が返されます。
.TP
.B backward\-delete\-char (Rubout)
カーソルの前の文字を削除します。数値の引き数を与えると、
削除したテキストをキルリングに保存します。
.TP
.B forward\-backward\-delete\-char
カーソルが行末になければカーソルがある位置の文字を削除します。
カーソルが行末にある場合には、カーソルの前の文字を削除します。
デフォルトでは、これはキーに割り当てられていません。
.TP
.B quoted\-insert (C\-q, C\-v)
次に打ち込んだ文字をそのまま行に追加します。
これは \fBC\-q\fP 等の文字を挿入するために使います。
.TP
.B tab\-insert (C\-v TAB)
タブ文字を挿入します。
.TP
.B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
打ち込んだ文字を挿入します。
.TP
.B transpose\-chars (C\-t)
ポイントの前にある文字を動かし、
現在ポイントがある文字の後ろに持っていきます。
同時にポイントも前に進みます。ポイントが行の最後にある場合は、
ポイントの前の 2 文字が交換されます。
負の引き数を指定すると、何も起こりません。
.TP
.B transpose\-words (M\-t)
ポイントの前にある単語を動かし、
ポイントの後ろにある単語の後ろに持っていきます。
この際には、ポイントも始めに前にあった単語の後ろまで移動します。
.TP
.B upcase\-word (M\-u)
現在の (または後ろの) 単語を大文字にします。
負の引き数を指定すると、前の単語を大文字にしますが、
ポイントは動きません。
.TP
.B downcase\-word (M\-l)
現在の (または後ろの) 単語を小文字にします。
負の引き数を指定すると、前の単語を小文字にしますが、
ポイントは動きません。
.TP
.B capitalize\-word (M\-c)
現在の (または後ろの) 単語をキャピタライズします
(単語の先頭の文字を大文字にします)。
負の引き数を指定すると前の単語をキャピタライズしますが、
ポイントは動きません。
.PD
.SS キルとヤンク
.PP
.PD 0
.TP
.B kill\-line (C\-k)
ポイントから行末までのテキストをキルします。
.TP
.B backward\-kill\-line (C\-x Rubout)
現在のカーソル位置から行頭までをキルします。
.TP
.B unix\-line\-discard (C\-u)
ポイントから行頭までをキルします。
キルされたテキストはキルリング (kill-ring) に入ります。
.\" このコマンドと backward-kill-line は実際には相違点はありません。
.TP
.B kill\-whole\-line
現在の行の文字を全てキルします。ポイントの位置は関係ありません。
.TP
.B kill\-word  (M\-d)
ポイントから現在の単語の終わりまでをキルします。
ポイントが単語と単語の間であれば、後ろの単語の終わりまでをキルします。
単語の境界は \fBforward\-word\fP で使われているものと同じです。
.TP
.B backward\-kill\-word (M\-Rubout)
ポイントの下にある単語をキルします。
単語の境界は \fBbackward\-word\fP で使われているものと同じです。
.TP
.B unix\-word\-rubout (C\-w)
ポイントの下にある単語をキルします。
その際には空白を単語の境界として用います。
キルされたテキストはキルリングに入ります。
.TP
.B delete\-horizontal\-space (M\-\e)
ポイントの周りの空白とタブを全て削除します。
.TP
.B kill\-region
現在のリージョン中のテキストをキルします。
.TP
.B copy\-region\-as\-kill
リージョン中のテキストをキルバッファにコピーします。
.TP
.B copy\-backward\-word
ポイントの前の単語をキルバッファにコピーします。単語の境界は
\fBbackward\-word\fP と同じです。
.TP
.B copy\-forward\-word
ポイントの後ろの単語をキルバッファにコピーします。単語の境界は
\fBforward\-word\fP と同じです。
.TP
.B yank (C\-y)
キルリングの先頭のテキストをポイントのあるバッファにヤンクします。
.TP
.B yank\-pop (M\-y)
キルリングをローテートし、新たに先頭になったテキストをヤンクします。
.B yank
または
.B yank\-pop
の後にしか使えません。
.PD
.SS 数値の引き数
.PP
.PD 0
.TP
.B digit\-argument (M\-0, M\-1, ..., M\-\-)
既に蓄積中の引き数にこの数字を追加するか、
またはこの数字によって新しい引き数を始めます。
M\-\- を使うと、負の値を指定できます。
.TP
.B universal\-argument
引き数を指定する別法です。
このコマンドの後に 1 つ以上の数字がある場合
(頭にマイナス記号を付けることもできます)、
これらの数字で引き数が定義されます。
コマンドの後に数字を続けた場合、
.B universal\-argument
を再び実行すると数値の引き数を終了しますが、
そうでない場合は無視されます。
特殊なケースとして、
このコマンドの直後に数字でもマイナス記号でもない文字がある場合には、
次のコマンドの引き数カウントは 4 倍にされます。
最初は引き数カウントは 1 なので、
この機能を一度実行すると引き数カウントは 4 になり、
次に実行すると引き数カウントは 16 になります。
それ以降も同様です。
.PD
.SS 補完
.PP
.PD 0
.TP
.B complete (TAB)
ポイントの前のテキストについて補完を試みます。
.B bash
が補完を行う際にはテキストの扱いの種類を順に試しますが、
その順序は、変数 (テキストが \fB$\fP で始まる場合)、
ユーザ名 (テキストが \fB~\fP で始まる場合)、
ホスト名 (テキストが \fB@\fP で始まる場合)、
コマンド (エイリアスや関数も含みます) です。
これらのうちいずれにもマッチしない場合には、
ファイル名補完を試みます。
.TP
.B possible\-completions (M\-?)
ポイントの前のテキストを補完して得られるものの候補を列挙します。
.TP
.B insert\-completions (M\-*)
ポイントの前のテキストを補完して得られるものを全て挿入します。
挿入されるものは、\fBpossible\-completions\fP で列挙されるものと同じです。
.TP
.B menu\-complete
\fBcomplete\fP コマンドに似ていますが、
補完される単語を補完候補リストのうちの 1 つと置換します。
\fBmenu\-complete\fP を繰り返して実行すると、
補完の候補リストが次々と順番に挿入されます。
補完リストの最後まで来るとベルが
(\fBbell\-style\fP の設定に基づいて)
鳴らされ、元のテキストに戻ります。
引き数 \fIn\fP を指定すると、リスト中の位置が \fIn\fP 個進みます。
負の引き数を指定すると、リスト中を逆向きに戻れます。
このコマンドは \fBTAB\fP に割り当てることを意図して用意されたものですが、
デフォルトでは割り当ては行われていません。
.TP
.B delete\-char\-or\-list
カーソルが行頭や行末に無ければ、カーソルの下の文字を削除します
(\fBdelete\-char\fP と同様です)。カーソルが行末にある場合は、
\fBpossible\-completions\fP と同じ動作をします。
このコマンドはデフォルトではキーに割り当てられていません。
.TP
.B complete\-filename (M\-/)
ポイントの前のテキストについて、ファイル名の補完を試みます。
.TP
.B possible\-filename\-completions (C\-x /)
ポイントの前のテキストについて、補完の候補を列挙します。
テキストはファイル名として扱います。
.TP
.B complete\-username (M\-~)
ポイントの前のテキストについて補完を試みます。
テキストはユーザ名として扱います。
.TP
.B possible\-username\-completions (C\-x ~)
ポイントの前のテキストについて補完の候補を列挙します。
テキストはユーザ名として扱います。
.TP
.B complete\-variable (M\-$)
ポイントの前のテキストについて補完を試みます。
テキストはシェル変数として扱います。
.TP
.B possible\-variable\-completions (C\-x $)
ポイントの前のテキストについて補完の候補を列挙します。
テキストはシェル変数として扱います。
.TP
.B complete\-hostname (M\-@)
ポイントの前のテキストについて補完を試みます。
テキストはホスト名として扱います。
.TP
.B possible\-hostname\-completions (C\-x @)
ポイントの前のテキストについて補完の候補を列挙します。
テキストはホスト名として扱います。
.TP
.B complete\-command (M\-!)
ポイントの前のテキストについて補完を試みます。
テキストはコマンド名として扱います。
コマンド補完の際にマッチングを試みる順序は、
エイリアス、予約語、シェル関数、シェルの組み込みコマンド、
実行ファイルです。
.TP
.B possible\-command\-completions (C\-x !)
ポイントの前のテキストについて補完の候補を列挙します。
テキストはコマンド名として扱います。
.TP
.B dynamic\-complete\-history (M\-TAB)
ポイントの前のテキストについて補完を試みます。
テキストの比較が行われるのは、
履歴リスト中の行のうち補完の候補となるものです。
.TP
.B complete\-into\-braces (M\-{)
ファイル名補完を実行し、補完の候補リストを挿入します。
シェルから利用可能なリストとなるように、
返される候補はブレースで括られます (前述の
.B ブレース展開
を参照)。
.PD
.SS キーボードマクロ
.PP
.PD 0
.TP
.B start\-kbd\-macro (C\-x (\^)
現在のキーボードマクロに対して入力される文字列の保存を開始します。
.TP
.B end\-kbd\-macro (C\-x )\^)
現在のキーボードマクロに対して入力された文字列の保存を終了し、
この定義を格納します。
.TP
.B call\-last\-kbd\-macro (C\-x e)
最後に定義されたキーボードマクロを再実行します。
再実行は、
マクロ中の文字列をキーボードでの入力と同様に出力することによって行います。
.PD
.SS その他
.PP
.PD 0
.TP
.B re\-read\-init\-file (C\-x C\-r)
\fIinputrc\fP ファイルの内容を読み込み、
このファイル中の割り当てや変数設定を取り込みます。
.TP
.B abort (C\-g)
現在の編集行を捨て、端末のベルを鳴らします (この動作は
.B bell\-style
の設定に従って行います)。
.TP
.B do\-uppercase\-version (M\-a, M\-b, M\-\fIx\fP, ...)
メタ文字と共に入力された文字 \fIx\fP が小文字であれば、
これに対応する大文字に割り当てられているコマンドを実行します。
.TP
.B prefix\-meta (ESC)
次に入力される文字を、
メタプレフィックスされたことにします。
.SM
.B ESC
.B f
は
.B Meta\-f
と同じ意味です。
.TP
.B undo (C\-_, C\-x C\-u)
インクリメンタルアンドゥを行います。
これは行ごとに別々に記憶されています。
.TP
.B revert\-line (M\-r)
この行に対して行った変更を全て取り消します。
このコマンドは、行が初期状態に戻るまで
.B undo
コマンドを実行するようなものです。
.TP
.B tilde\-expand (M\-&)
現在の単語についてチルダ展開を実行します。
.TP
.B set\-mark (C\-@, M\-<space>)
ポイントにマークを設定します。
数字の引き数が与えられた場合には、
マークにはその位置が設定されます。
.TP
.B exchange\-point\-and\-mark (C\-x C\-x)
ポイントをマークと入れ換えます。
現在のカーソル位置は保存されている位置となり、
古いカーソル位置がマークとして保存されます。
.TP
.B character\-search (C\-])
文字を 1 つ読み込み、
その文字が次に現われる場所にポイントを移動させます。
負のカウントを与えると、その文字が前に現われた場所を探します。
.TP
.B character\-search\-backward (M\-C\-])
文字を 1 つ読み込み、
その文字が前に現われた場所にポイントを移動させます。
負のカウントを与えると、その文字が次に現われる場所を探します。
.TP
.B insert\-comment (M\-#)
まず readline の
.B comment\-begin
変数の値が現在の行の先頭に挿入され、
次に改行が打ち込まれたのと同じように行の入力が行われます。
\fBcomment\-begin\fP のデフォルト値によって、
このコマンドは現在の行をシェルのコメントとします。
.TP
.B glob\-expand\-word (C\-x *)
ポイントの前の単語がパス名展開のパターンとして扱われ、
この単語と置き換えられる形でマッチするファイル名のリストが挿入されます。
.TP
.B glob\-list\-expansions (C\-x g)
.B glob\-expand\-word
で生成されるのと同じ展開結果のリストが表示され、
行が再描画されます。
.TP
.B dump\-functions
機能とそのキー割り当てを全て、
readline の出力ストリームに出力します。
数値の引き数を与えると、
出力は \fIinputrc\fP に書き込める形に整形されます。
.TP
.B dump\-variables
設定可能な readline の変数とその値を全て
readline の出力ストリームに出力します。
数値の引き数を与えると、
出力は \fIinputrc\fP に書き込める形に整形されます。
.TP
.B dump\-macros
マクロとマクロが出力する文字列に割り当てられた
readline のキーシーケンスを全て出力します。
数値の引き数を与えると、
出力は \fIinputrc\fP に書き込める形に整形されます。
.TP
.B display\-shell\-version (C\-x C\-v)
現在実行している
.B bash
のバージョン情報を表示します。
.PD
.SS プログラム補完
.PP
\fBcomplete\fP 組み込みコマンドで
補完仕様 (\fIcompspec\fP) が定義されているコマンドに対して
引き数の単語補完が試みられると、
プログラム可能な補完の機能が呼び出されます
(\fBcomplete\fP 組み込みコマンドについては、後述する
.SM
.B "シェルの組み込みコマンド"
を参照)。
.PP
まず、コマンド名が特定されます。
そのコマンドに対して補完仕様が定義されていれば、
それがその単語の補完候補のリスト作成に使われます。
コマンドの単語がフルパス名であれば、
最初にフルパス名の補完仕様が検索されます。
フルパス名の補完仕様が見つからなかった場合は、
最後のスラッシュ以降の部分に対して該当する補完仕様を見つけようとします。
.PP
補完仕様が見つかると、
それはマッチする単語のリストを作成するために使用されます。
補完仕様が見つからなかった場合は、
前述の \fB補完\fP で説明したようなデフォルトの
\fBbash\fP の補完が行われます。
.PP
まず、補完仕様で指定された動作が用いられます。
補完される単語の前置部分にマッチするものだけが返されます。
ファイル名やディレクトリ名の補完に
.B \-f
や
.B \-d
オプションが使用された場合は、シェル変数
.SM
.B FIGNORE
がマッチのフィルタとして使用されます。
.PP
続いて
\fB\-G\fP オプションによって指定された
ファイル名展開パターンの補完が生成されます。
パターンによって生成された単語は、
補完される単語とマッチする必要はありません。
.SM
.B GLOBIGNORE
シェル変数はマッチのフィルタとしては使われませんが、
.SM
.B FIGNORE
変数は使用されます。
.PP
次に、
\fB\-W\fP オプションで指定された引き数の文字列が考慮されます。
文字列は、最初に
.SM
.B IFS
特殊変数の文字を区切り文字として分割されます。
シェルのクォート処理は考慮されます。
それぞれの単語は、前述の
.SM
.B 展開
で示したように、ブレース展開、チルダ展開、パラメータと変数の展開、
コマンド置換、算術式展開、パス名展開が行われます。
結果は、前述の\fB単語の分割\fPで示した規則によって分割されます。
展開の結果は補完される単語の前置部分とマッチが行われ、
マッチした単語が補完候補となります。
.PP
これらのマッチが生成された後、
シェル関数や \fB\-F\fP や
\fB\-C\fP オプションで指定されたコマンドが呼び出されます。
コマンドや関数が呼び出されるときは、
.SM
.B COMP_LINE
と
.SM
.B COMP_POINT
変数に後述の\fBシェル変数\fPで示すように値が設定されます。
シェル関数が呼び出される場合は、
.SM
.B COMP_WORDS
と
.SM
.B COMP_CWORD
変数も設定されます。
関数やコマンドが呼び出されるときは、
最初の引き数は引き数が補完されるコマンドの名前、
二番目の引き数は補完される単語、
三番目の引き数は現在のコマンドラインで補完中の単語の
前に置かれる単語となります。
補完される単語に対して生成された補完の候補はフィルタリングされません。
関数やコマンドは生成されたマッチとは無関係に補完されます。
.PP
\fB\-F\fP で指定された関数がまず呼び出されます。
関数は、後述する \fBcompgen\fP 組み込みコマンドを含めた、
全てのシェルの機能を使ってマッチを生成します。
補完候補は必ず
.SM
.B COMPREPLY
配列変数に格納されます。
.PP
続いて \fB\-C\fP オプションで指定されたコマンドが呼び出され、
環境変数をコマンド置換します。
このコマンドは、補完候補を 1 行にひとつずつ標準出力に出力します。
必要があれば、バックスラッシュが改行をエスケープするために使用されます。
.PP
全ての補完候補が生成された後で、
\fB\-X\fP オプションで指定されたフィルタが補完候補に作用します。
フィルタは、パス名展開で使用されたようなパターンです。パターン中の
\fB&\fP は補完される単語に置換されます。
文字通りの \fB&\fP はバックスラッシュでエスケープします。
バックスラッシュはマッチを試みる前に削除されます。
パターンにマッチした補完は候補から削除されます。
先行する \fB!\fP はパターンを否定します。
この場合、パターンにマッチしなかった補完が削除されます。
.PP
最後に、\fB\-P\fP と \fB\-S\fP オプションで指定された
前置部分と後置部分が補完候補のそれぞれに加えられます。
そして結果が readline 補完コードに補完候補のリストとして返されます。
.PP
直前に行われた動作が何にもマッチせず、
補完仕様が定義されたときに
.B \-o dirname
オプションが
.B complete
に与えられていれば、
ディレクトリ名への補完が試みられます。
.PP
デフォルトでは、補完仕様が見つかった場合、
それが生成したものがなんであれ、
可能性のある補完すべてのリストとして、補完コードに返されます。
デフォルトの \fBbash\fP 補完は試みられず、
readline のデフォルトのファイル名補完は無効になります。
補完仕様の定義時に
.B \-o default
オプションが
.B complete
に与えられていれば、
補完仕様が何にもマッチしなければ
readline のデフォルトの補完が行われます。
.SH 履歴 (HISTORY)
.B \-o history
オプションを組み込みコマンドの
.B set
で有効にすると、
\fIコマンド履歴 (command history)\fP (以前に入力したコマンドのリスト)
にアクセスできるようになります。
変数 \fBHISTSIZE\fP の値が、
履歴リストに保存するコマンドの数になります。
過去に入力したコマンドのうち、最新
.SM
.B HISTSIZE
個分 (デフォルトは 500 個) のテキストが保存されます。
シェルは各コマンドを、パラメータ展開や変数展開
(前述の
.SM
.B 展開
を参照) を行う前のかたちで履歴リストに格納します。
ただし、履歴展開は実行してから格納します。
履歴展開はシェル変数
.SM
.B HISTIGNORE
と
.SM
.BR HISTCONTROL
の値に従って実行されます。
.PP
起動時に、履歴は
.SM
.B HISTFILE
変数 (デフォルトは \fI~/.bash_history\fP)
が示すファイルの内容で初期化されます。
.SM
.B HISTFILE
で指定されたファイルは、
.SM
.B HISTFILESIZE
で指定された行数を越えないように、必要に応じて切り詰められます。
対話的なシェルが終了する際には、最近の
.SM
.B HISTSIZE
個の行が履歴リストから
.SM
.B HISTFILE
にコピーされます。
シェルオプションの
.B histappend
(
.SM
.B シェルの組み込みコマンド
の項の
.B shopt
の説明を参照) が有効になっていると、
これらの行は履歴ファイルの末尾に追加されます。
このオプションが無効ならば、履歴ファイルは上書きされます。
.SM
.B HISTFILE
が設定されていないか、履歴ファイルが書き込めない状態だと、
履歴は保存されません。
履歴の保存を行った後には、履歴ファイルは行数が
.SM
.B HISTFILESIZE
行を越えないように切り詰められます。
.SM
.B HISTFILESIZE
が設定されていなければ、切り詰めは行われません。
.PP
組み込みコマンド
.B fc
(後述の
.SM
.B シェルの組み込みコマンド
を参照) を用いると、履歴リストの一部をリスト・編集して再実行できます。
組み込みコマンドの
.B history
を用いると、履歴リストを表示・編集したり、
履歴ファイルを操作できます。
コマンドラインを編集する際には、
各編集モードでいろいろな検索コマンドが利用でき、
履歴リストへアクセスできます。
.PP
このシェルでは、どのコマンドが履歴リストに保存されるかを制御できます。
.SM
.B HISTCONTROL
変数と
.SM
.B HISTIGNORE
変数を設定すると、
シェルは入力されたコマンドの一部しか保存しなくなります。
シェルオプションの
.B cmdhist
を有効にすると、シェルは複数行に別れているコマンドの各行を
同じ履歴エントリに保存しようとします。
この際には、文法的な正しさを保つためにセミコロンが必要に応じて追加されます。
シェルオプションの
.B lithist
を有効にすると、このシェルは行の途中に
セミコロンではなく改行文字を置く形でコマンドを保存します。
シェルオプションの設定と設定取り消しについては、後述の
.SM
.B シェルの組み込みコマンド
における説明を参照してください。
.SH 履歴の展開
.PP
このシェルは、
.B csh
の履歴展開と同じような機能をサポートしています。
このセクションでは、履歴展開で使用できる記法・機能を説明します。
この機能は対話的シェルならばデフォルトで有効になっていますが、
組み込みコマンド
.B set
の
.B \+H
オプション (後述の
.SM
.B シェルの組み込みコマンド
を参照) で無効にできます。
非対話的シェルの場合は、デフォルトでは履歴展開は行われません。
.PP
履歴展開は、履歴リスト中の単語を入力ストリームに入れます。
この機能を利用すると、コマンドを繰り返したり、
前のコマンドで指定したオプションを現在の入力行に挿入したり、
前のコマンドの誤りを手早く直したり、
といったことが簡単にできるようになります。
.PP
履歴展開が実行されるのは入力行全体を読み込んだ直後であり、
シェルが行を単語に分割するよりも前です。
履歴展開の動作は 2 段階で行われます。
まず最初に、置換に使う行を履歴リストから選びます。
次に、その行のどの部分を現在の行に書き込むかを選択します。
履歴リストから選ばれた行は\fIイベント (event)\fP と呼ばれ、
この行のうち動作の対象となる部分を\fI単語列 (words)\fPと呼びます。
様々な\fI修飾子 (modifier)\fP が利用でき、
選択された単語列の操作が可能になっています。
行の単語への分割は入力を読み込む時と同じように行われるので、
\fIメタ文字\fPで区切られた複数の単語をクォートで括ったものは
1 つの単語と見なされます。
履歴展開が行われるのは、履歴展開文字が現われた時です。
履歴展開文字はデフォルトでは \^\fB!\fP\^ です。
履歴展開文字をクォートできるのは、
バックスラッシュ (\^\fB\e\fP\^) とシングルクォートだけです。
.PP
組み込みコマンドの
.B shopt
を用いて、何種類かあるシェルオプションを設定すると、
履歴展開の動作を調整できます。
シェルオプションの
.B histverify
が有効で (組み込みコマンド
.B shopt
の説明を参照)、かつ
.B readline
が使われている場合には、
履歴置換を行った結果はすぐにはシェルのパーザに渡されません。
展開された行は
.B readline
の編集バッファに再び読み込まれ、さらに編集が行える状態になります。
.B readline
を使用しており、かつシェルオプションの
.B histreedit
が有効である場合、履歴置換が失敗してもその結果は
.B readline
の編集バッファに再び読み込まれ、訂正できる状態となります。
組み込みコマンド
.B history
の
.B \-p
オプションを使うと、実際に履歴展開を行う前に、
どのように展開されるのかを見ることができます。
組み込みコマンド
.B history
の
.B \-s
オプションを使うと、
コマンドを履歴リストの末尾に (実際の実行はせずに) 追加できます。
追加したコマンドは、後で再呼び出しできます。
.PP
このシェルでは、履歴展開機構で使ういろいろな文字を制御できます
(前述の
.BR シェル変数
の項目における
.B histchars
の説明を参照)。
.SS イベント指示子 (Event Designator)
.PP
イベント指示子は、
履歴リスト中のコマンドラインエントリを参照するものです。
.PP
.PD 0
.TP
.B !
履歴置換を開始します。ただし、\fBブランク文字\fR、
改行文字、=, ( のいずれかが後に続く場合は除きます。
.TP
.B !\fIn\fR
.I n
行目のコマンドラインを参照します。
.TP
.B !\-\fIn\fR
現在から
.I n
行前のコマンドラインを参照します。
.TP
.B !!
1 行前のコマンドラインを参照します。`!\-1' と同義です。
.TP
.B !\fIstring\fR
.I string
で始まるコマンドのうち、一番現在に近いところで実行したものを参照します。
.TP
.B !?\fIstring\fR\fB[?]\fR
.I string
を含むコマンドのうち、一番現在に近いところで実行したものを参照します。
.I string
の直後が改行文字ならば、最後の \fB?\fP は省略しても構いません。
.TP
.B \d\s+2^\s-2\u\fIstring1\fP\d\s+2^\s-2\u\fIstring2\fP\d\s+2^\s-2\u
簡易置換。
.I string1
を
.IR string2
に置換して直前のコマンドを繰り返します。
``!!:s/\fIstring1\fP/\fIstring2\fP/'' と同義です
(後述の\fB修飾子\fPを参照)。
.TP
.B !#
今までのところまでに打ち込んだコマンドライン全体です。
.PD
.SS 単語指示子 (Word Designators)
.PP
単語指示子 (word designator) は、
イベントから欲しい単語を選ぶ時に用いられます。
イベント指定と単語指示子のセパレータには
.B :
を用います。
単語指示子が
.BR ^ ,
.BR $ ,
.BR * ,
.BR \- ,
.B %
のいずれかで始まる場合には、このセパレータは省略できます。
単語には行の先頭から番号が振られます。
先頭の単語が 0 番目になります。
単語は現在の行に、空白 1 つで区切られて挿入されます。
.PP
.PD 0
.TP
.B 0 (ゼロ)
0 番目の単語。このシェルにとっては、これはコマンドを表す単語です。
.TP
.I n
\fIn\fR 番目の単語。
.TP
.B ^
最初の引き数。つまり 1 番目の単語です。
.TP
.B $
最後の引き数。
.TP
.B %
`?\fIstring\fR?' 検索にマッチする、一番現在に近い単語。
.TP
.I x\fB\-\fPy
単語の範囲。`0\-\fIy\fR' の省略形として `\-\fIy\fR' が使えます。
.TP
.B *
0 番目を除く全ての単語。これは `\fI1\-$\fP' の別表現です。
イベント中に 1 つしか単語が現われないときに
.B *
を使ってもエラーにはなりません。
このような場合には空文字列が返されます。
.TP
.B x*
\fIx\-$\fP の省略形です。
.TP
.B x\-
\fBx*\fP と同様に \fIx\-$\fP の省略形ですが、
ただし最後の単語は含みません。
.PD
.PP
イベント指定なしに単語指示子が与えられた場合、
直前のコマンドがイベントとして使われます。
.SS 修飾子 (Modifiers)
.PP
単語指示子 (省略可能) の後には、
以下に示す修飾子を、1 個以上のシーケンスのかたちで置けます。
それぞれの修飾子の前には `:' をつけます。
.PP
.PD 0
.PP
.TP
.B h
パス名から末尾にある部分 (ファイル名) を取り除き、
前の方 (ディレクトリ部) だけを残します。
.TP
.B t
パス名から前の方 (ディレクトリ部) を取り除き、
末尾にある部分 (ファイル名) だけを残します。
.TP
.B r
末尾にある \fI.xxx\fP 形式のサフィックスを取り除き、
ベース名 (basename) だけを残します。
.TP
.B e
末尾のサフィックスだけを残して、全ての部分を取り除きます。
.TP
.B p
新しいコマンドを表示しますが、実行はしません。
.TP
.B q
置換が行われた単語をクォートし、それ以上の置換が行われないようにします。
.TP
.B x
.B q
と同じように置換後の単語をクォートしますが、
.B 空白文字
と改行文字のところで単語に分割します。
.TP
.B s/\fIold\fP/\fInew\fP/
イベント行で最初に現われた
.I old
を
.I new
に置き換えます。/ の代わりに任意の区切り文字を使うこともできます。
最後の区切り文字がイベント行の最後の文字ならば、
これは省略できます。
.I old
と
.I new
の中では、
バックスラッシュ 1 つでクォートすれば区切り文字も使えます。
.I new 
に & が含まれている場合には、これは
.I old
に置き換えられます。
バックスラッシュ 1 つを前に置けば & をクォートできます。
.I old
が空文字列ならば、これには前回に置換された
.I old
が設定されます。
以前に履歴置換が全く行われていない場合には、現在に一番近い
.B !?\fIstring\fR\fB[?]\fR
の検索で使われた
.I string
が設定されます。
.TP
.B &
直前の置換を繰り返します。
.TP
.B g
変更をイベント行全体に適用します。
これは `\fB:s\fP' と組み合わせて使われます
(例:`\fB:gs/\fIold\fP/\fInew\fP/\fR')。
`\fB:s\fP' と一緒に使った場合には、
/ の代わりに任意の区切り文字を使えます。
また最後の区切り文字がイベント行の最後の文字ならば、
これは省略できます。
.PD
.SH シェルの組み込みコマンド
.\" start of bash_builtins
.zZ
.PP
特に断らない限り、このセクションで説明されている組み込みコマンドのうち
.B \-
で始まるオプションを受け付けるものは、オプションの終わりを表す
.B \-\-
も受け付けます。
.sp .5
.PD 0
.TP
\fB:\fP [\fIarguments\fP]
.PD
何もしません。このコマンドは
.I arguments
を展開し、指定されたリダイレクトを実行する以外には何も行いません。
終了コード 0 を返します。
.TP
.PD 0
\fB .\| \fP \fIfilename\fP [\fIarguments\fP]
.TP
\fBsource\fP \fIfilename\fP [\fIarguments\fP]
.PD
.I filename
からコマンドを読み込み、現在のシェル環境のもとで実行します。そして
.I filename
中で最後に実行したコマンドの終了ステータスを返します。
.I filename
にスラッシュが含まれていない場合、
.I filename
は
.SM
.B PATH
に含まれるディレクトリから探されます。
.SM
.B PATH
内で検索されるファイルは、実行可能である必要はありません。
.B bash
が
.I posix モード
で動作していれば、
.SM
.B PATH
中でファイルを見つけられなかった場合には、
カレントディレクトリが検索されます。
組み込みコマンド
.B shopt
に対する
.B sourcepath
オプションが無効にされている場合、
.SM
.B PATH
の検索は行われません。
何らかの \fIarguments\fP が与えられている場合、これらの引き数は
\fIfilename\fP を実行した時の位置パラメータとなります。
そうでない場合は、位置パラメータは変更されません。
返却ステータスはスクリプト内で最後に実行したコマンドのステータスです
(コマンドが全く実行されなければ 0 です)。また
.I filename
が見つからない場合や読み込めない場合には偽となります。
.TP
\fBalias\fP [\fB\-p\fP] [\fIname\fP[=\fIvalue\fP] ...]
\fBalias\fP コマンドを引き数を付けずに (あるいは
.B \-p
オプションを付けて) 実行すると、エイリアスのリストが
「\fBalias\fP \fIname\fP=\fIvalue\fP」の形で標準出力に出力されます。
引き数を与えた場合には、\fIvalue\fP を与えられた
\fIname\fP それぞれに対するエイリアスが定義されます。
\fIvalue\fP の末尾に空白があると、エイリアスが展開された時に、
空白の次の単語についてエイリアス置換があるかどうか調べられます。
引き数リスト中に
\fIvalue\fP が与えられていない \fIname\fP があった場合は、
それぞれに対して名前とエイリアスの値が出力されます。
エイリアスが定義されていない \fIname\fP が与えられなければ、
\fBalias\fP は真を返します。
.TP
\fBbg\fP [\fIjobspec\fP]
サスペンドされているジョブ \fIjobspec\fP を
バックグラウンドで実行再開します。このジョブは、初めから
.B &
を付けて起動されていたかのように動作を続けます。
\fIjobspec\fP が無い場合には、
シェルが記録している\fIカレントジョブ (current job)\fP が使われます。
.B bg
.I jobspec
は通常 0 を返しますが、ジョブ制御が無効であるときに実行した場合や、
ジョブ制御が有効であっても
.I jobspec
が有効なジョブを指定していない場合や
.I jobspec
がジョブ制御無しで実行したジョブを指定している場合は異なる値を返します。
.TP
.PD 0
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] [\fB\-lpsvPSV\fP]
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fB\-x\fP \fIkeyseq\fP:\fIshell\-command\fP
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] [\fB\-q\fP \fIfunction\fP] [\fB\-u\fP \fIfunction\fP] [\fB\-r\fP \fIkeyseq\fP]
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fB\-f\fP \fIfilename\fP
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fIkeyseq\fP:\fIfunction\-name\fP
.PD
.B readline
の現在のキー割り当てと関数割り当てを表示します。
あるいはキーシーケンスを
.B readline
の関数やマクロに割り当てます。受け付ける割り当ての記法は
.I .inputrc
と全く同じですが、
それぞれの割り当ては別々の引き数として渡さなければなりません。
例えば '"\eC\-x\eC\-r": re\-read\-init\-file' のように指定します。
オプションを指定した場合には、以下のような意味を持ちます:
.RS
.PD 0
.TP
.B \-m \fIkeymap\fP
キーマップ
.I keymap
を、以降の割り当てによって変更します。指定できる
.I keymap
名は、\fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi,
vi\-move, vi\-command, vi\-insert\fP です。
\fIvi\fP は \fIvi\-command\fP と同じです。
また \fIemacs\fP は \fIemacs\-standard\fP と同じです。
.TP
.B \-l
\fBreadline\fP 関数の名前を全てリスト表示します。
.TP
.B \-p
\fBreadline\fP の関数の名前と割り当てを表示します。
表示は、再び読み込みできる形式で出力されます。
.TP
.B \-P
\fBreadline\fP の関数の現在の名前と割り当てをリスト表示します。
.TP
.B \-v
\fBreadline\fP の変数名と値を表示します。
表示は、再び読み込みできる形式で出力されます。
.TP
.B \-V
\fBreadline\fP の現在の変数名と値をリスト表示します。
.TP
.B \-s
\fBreadline\fP のマクロに割り当てられたキーシーケンスと、
マクロが出力する文字列を表示します。
表示は、再び読み込みできる形式で出力されます。
.TP
.B \-S
\fBreadline\fP のマクロに割り当てられたキーシーケンスと、
マクロが出力する文字列を表示します。
.TP
.B \-f \fIfilename\fP
キー割り当てを \fIfilename\fP から読み込みます。
.TP
.B \-q \fIfunction\fP
指定された \fIfunction\fP を呼び出すキーを問い合わせます。
.TP
.B \-u \fIfunction\fP
指定された \fIfunction\fP に割り当てられているキーの割り当てを
全て取り消します。
.TP
.B \-r \fIkeyseq\fP
\fIkeyseq\fP に対する現在の割り当てを削除します。
.TP
.B \-x \fIkeyseq\fP:\fIshell\-command\fP
\fIkeyseq\fP が押されるたびごとに、
\fIshell\-command\fP が実行されるようにします。
.PD
.PP
認識できないオプションが与えられた場合やエラーが起きた場合を除けば、
返り値は 0 です。
.RE
.TP
\fBbreak\fP [\fIn\fP]
.BR for ,
.BR while ,
.BR until ,
.B select
のループから抜けます。\fIn\fP が指定されていれば、\fIn\fP レベル分 
break します。
.I n
は 1 以上でなければなりません。
.I n
がループの深さよりも大きい場合には、全てのループから抜けます。
.B break
が実行された時にシェルがループを実行していれば、
返り値は 0 になります。
.TP
\fBbuiltin\fP \fIshell\-builtin\fP [\fIarguments\fP]
指定されたシェル組み込みコマンドを実行します。コマンドには
.I arguments
を引き数として渡し、このコマンドの終了ステータスを返します。
これはシェル組み込みコマンドと同じ名前の関数を定義する時に便利で、
その関数内で組み込みコマンドを使った時に、その機能を損ないません。
組み込みコマンド 
\fBcd\fP は普通、これを使って再定義されます。
.I shell\-builtin
がシェル組み込みコマンドでなければ、終了ステータスは偽となります。
.TP
\fBcd\fP [\fB\-LP\fP] [\fIdir\fP]
カレントディレクトリを \fIdir\fP に変更します。
変数
.SM
.B HOME
の値が
.I dir
のデフォルト値です。変数
.SM
.B CDPATH
は、
.I dir
を含むディレクトリの検索パスを定義します。
.SM
.B CDPATH
内ではディレクトリ名はコロン (:) で区切ります。
.SM
.B CDPATH
中に空のディレクトリ名がある場合、これはカレントディレクトリ
(つまり ``\fB.\fP'') を意味します。
.I dir
がスラッシュ (/) で始まる場合には、
.SM
.B CDPATH
は使われません。
.B \-P
オプションは、シンボリックリンクを辿らないで物理的なディレクトリ構造を
使うように指示します (組み込みコマンド
.B set
の
.B \-P
オプションも参照)。
.B \-L
オプションを指定すると、シンボリックリンクを辿るようになります。
引き数に
.B \-
を指定するのは、
.SM
.B $OLDPWD
を指定するのと同じ意味です。
ディレクトリの変更が成功した場合には返り値は真になります。
そうでない場合には偽になります。
.TP
\fBcommand\fP [\fB\-pVv\fP] \fIcommand\fP [\fIarg\fP ...]
.I command
に引き数
.I args
を付けて実行します。シェル関数の通常の参照は行いません。
組み込みコマンドと
.SM
.B PATH
内で見つかるコマンドだけが実行されます。
.B \-p
オプションが与えられると、
.I command
の検索を行う際に
.B PATH
のデフォルト値が使われます。これにより、
標準ユーティリティを全て確実に見つけられます。
.B \-V
オプションまたは
.B \-v
オプションを与えると、
.I command
の説明が出力されます。
.B \-v
オプションでは、
.I command
を起動する時に使われるコマンドやファイル名を示す単語が表示されます。
.B \-V
ではさらに詳しい説明が表示されます。
.B \-V
オプションや
.B \-v
オプションを与えた場合、終了ステータスは
.I command
が見つかれば 0 となり、見つからなければ 1 となります。
どちらのオプションも与えなかった場合に、エラーが起きたり
.I command
を見つけられなかったりすると、終了ステータスは 127 になります。
それ以外の場合には、組み込みコマンド
.B command
の終了ステータスは、
.I command
の終了ステータスです。
.TP
\fBcompgen\fP [\fIoption\fP] [\fIword\fP]
\fIoption\fP にしたがって、\fIword\fP の補完マッチのリストを生成します。
オプションには \fBcomplete\fP 組み込みコマンドと同じものが指定できますが、
\fB\-p\fP と \fB\-r\fP は指定できません。
マッチのリストは標準出力に出力されます。
\fB\-F\fP や \fB\-C\fP オプションを使用したときは、
プログラム補完機能によって設定されたさまざまなシェル変数は、
利用可能であっても有用な値を持ちません。
.sp 1
マッチは、同じフラグで指定されたプログラム補完コードが
直接補完を生成するのと同じ方法で生成されます。
\fIword\fP が指定されると、\fIword\fP にマッチする補完だけが表示されます。
.sp 1
戻り値は、
無効なオプションが指定された場合やマッチが生成されなかった場合以外は
真になります。
.TP
.PD 0
\fBcomplete\fP [\fB\-abcdefjkvu\fP] [\fB\-o\fP \fIcomp-option\fP] [\fB\-A\fP \fIaction\fP] [\fB\-G\fP \fIglobpat\fP] [\fB\-W\fP \fIwordlist\fP] [\fB\-P\fP \fIprefix\fP] [\fB\-S\fP \fIsuffix\fP]
.br
[\fB\-X\fP \fIfilterpat\fP] [\fB\-F\fP \fIfunction\fP] [\fB\-C\fP \fIcommand\fP] \fIname\fP [\fIname ...\fP]
.TP
\fBcomplete\fP \fB\-pr\fP [\fIname\fP ...]
.PD
\fIname\fP 引き数それぞれを、どのように補完するのかを指定します。
\fB\-p\fP オプションが指定された場合や、
何もオプションが指定されなかった場合は、
既存の補完指定が (入力として再利用できるかたちで) 出力されます。
\fB\-r\fP オプションは、それぞれの \fIname\fP の補完指定を削除します。
\fIname\fP が指定されなかった場合はすべての補完指定を削除します。
.sp 1
単語補完が試みられたときにこれらの補完指定に加えられる処理は、
前述の \fBプログラム補完\fP で示しています。
.sp 1
他のオプションが指定されたときは、以下のような意味を持ちます。
\fB\-G\fP, \fB\-W\fP, \fB\-X\fP オプションの引き数 (必要ならば
\fB\-P\fP と \fB\-S\fP オプションの場合も) はクォートして、
.B complete
組み込みコマンドが呼び出される前に展開されないようにすべきです。
.RS
.PD 0
.TP 8
\fB\-o\fP \fIcomp-option\fP
.I comp\-option
は補完仕様の動作をいくつかの点から制御し、
単純な補完生成以外ができるようにします。
.I comp\-option
には以下のどれかひとつを指定できます。
.RS
.TP 8
.B default
補完仕様がマッチを全く生成しなかった場合に、
readline のデフォルトの補完を用います。
.TP 8
.B dirnames
補完仕様がマッチを全く生成しなかった場合に、
ディレクトリ名を補完しようとします。
.TP 8
.B filenames
補完仕様がファイル名を生成することを readline に伝え、
readline がファイル名特有の処理
(ディレクトリ名にスラッシュを加えたり、末尾の空白を削除したり、など)
を行えるようにします。
シェル関数と共に用いることを想定しています。
.RE
.TP 8
\fB\-A\fP \fIaction\fP
\fIaction\fP は補完対象リストの生成動作で、
以下のどれかひとつを指定します。
.RS
.TP 8
.B alias
エイリアス名。\fB\-a\fP でも指定できます。
.TP 8
.B arrayvar
配列変数名。
.TP 8
.B binding
\fBreadline\fP キー割り当て名。
.TP 8
.B builtin
シェル組み込みコマンド名。\fB\-b\fP でも指定できます。
.TP 8
.B command
コマンド名。\fB\-c\fP でも指定できます。
.TP 8
.B directory
ディレクトリ名。\fB\-d\fP でも指定できます。
.TP 8
.B disabled
無効にされているシェル組み込みコマンドの名前。
.TP 8
.B enabled
有効にされているシェル組み込みコマンドの名前。
.TP 8
.B export
エクスポートされたシェル変数の名前。
\fB\-e\fP でも指定できます。
.TP 8
.B file
ファイル名。\fB\-f\fP でも指定できます。
.TP 8
.B function
シェル関数の名前。
.TP 8
.B helptopic
\fBhelp\fP 組み込みコマンドで許可されたヘルプトピック。
.TP 8
.B hostname
.SM
.B HOSTFILE
シェル変数で指定されたファイルから得られたホスト名。
.TP 8
.B job
ジョブ制御が有効であれば、ジョブ名。\fB\-j\fP でも指定できます。
.TP 8
.B keyword
シェルの予約語。\fB\-k\fP でも指定できます。
.TP 8
.B running
ジョブ制御が有効であれば、実行中のジョブ名。
.TP 8
.B setopt
\fBset\fP 組み込みコマンドの \fB\-o\fP オプションで有効な引き数。
.TP 8
.B shopt
\fBshopt\fP 組み込みコマンドで許可されたシェルオプション名。
.TP 8
.B signal
シグナル名。
.TP 8
.B stopped
ジョブ制御が有効であれば、停止しているジョブ名。
.TP 8
.B user
ユーザ名。\fB\-u\fP でも指定できます。
.TP 8
.B variable
すべてのシェル変数名。\fB\-v\fP でも指定できます。
.RE
.TP 8
\fB\-G\fP \fIglobpat\fP
ファイル名展開パターン \fIglobpat\fP
が展開されて補完対象のリストを生成します。
.TP 8
\fB\-W\fP \fIwordlist\fP
\fIwordlist\fP は
.SM
.B IFS
特殊変数を区切り文字として分割され、
それぞれの分割された単語は展開されます。
補完対象は、展開結果のリストのメンバのうち、
補完中の単語がマッチするものです。
.TP 8
\fB\-C\fP \fIcommand\fP
\fIcommand\fP がサブシェル環境で実行され、
その出力が補完対象として使用されます。
.TP 8
\fB\-F\fP \fIfunction\fP
シェル関数 \fIfunction\fP は現在のシェル環境で実行されます。
関数が終了したときに、補完対象が
.SM
.B COMPREPLY
配列変数から取得されます。
.TP 8
\fB\-X\fP \fIfilterpat\fP
\fIfilterpat\fP はファイル名展開として使用されるパターンです。
先行するオプション・引き数によって生成された補完対象リストに適用され、
\fIfilterpat\fP とマッチするそれぞれの補完がリストから削除されます。
\fIfilterpat\fP の前に \fB!\fP を置くとパターンを否定します。
この場合、\fIfilterpat\fP にマッチしない補完が削除されます。
.TP 8
\fB\-P\fP \fIprefix\fP
他のすべてのオプションが作用したあとに、
\fIprefix\fP がそれぞれの補完対象の先頭に追加されます。
.TP 8
\fB\-S\fP \fIsuffix\fP
他のすべてのオプションが作用したあとに、
\fIprefix\fP がそれぞれの補完対象の末尾に追加されます。
.PD
.PP
不正なオプションが指定された場合、\fB\-p\fP と \fB\-r\fP 以外のオプションで
\fIname\fP が指定されなかった場合、
存在しない \fIname\fP の指定によって補完が削除されようとした場合、
補完の指定の追加に失敗した場合、を除いては、返り値は真になります。
.RE
.TP
\fBcontinue\fP [\fIn\fP]
.BR for ,
.BR while ,
.BR until ,
.B select
ループの次の繰り返し分から実行を継続します。
.I n
を指定すると、深さを \fIn\fP 個分上がったループで実行を継続します。
.I n
は 1 以上でなければなりません。
.I n
がループの深さよりも大きい場合、
最後のループ (「トップレベル」のループ) で実行が継続されます。
.B continue
が実行された時にシェルがループの実行中でなかった場合を除き、
返り値は 0 となります。
.TP
.PD 0
\fBdeclare\fP [\fB\-afFirx\fP] [\fB\-p\fP] [\fIname\fP[=\fIvalue\fP]]
.TP
\fBtypeset\fP [\fB\-afFirx\fP] [\fB\-p\fP] [\fIname\fP[=\fIvalue\fP]]
.PD
変数を宣言したり、変数に属性を与えたりします。
\fIname\fP を指定しなければ、変数の値が表示されます。
.B \-p
オプションを指定すると、
.I name
それぞれの属性と値が表示されます。
.B \-p
を使うと他のオプションは無視されます。
.B \-F
オプションを指定すると、関数定義の表示を止めます。
関数の名前と属性だけが出力されます。
.B \-F
オプションを指定すると、
.B \-f
オプションも指定したことになります。以下のオプションを使うと、
指定した属性を持つ変数の出力を制限したり、
変数に属性を与えたりできます:
.RS
.PD 0
.TP
.B \-a
\fIname\fP はそれぞれ配列変数 (前述の
.B 配列
を参照) です。
.TP
.B \-f
関数名だけを使います。
.TP
.B \-i
変数を整数として扱います。変数に値が代入された時に算術式評価 (
.SM
.B 算術式評価
を参照) が実行されます。
.TP
.B \-r
\fIname\fP を読み込み専用にします。
これ以降、代入文を用いて値を代入したり unset したりできなくなります。
.TP
.B \-x
\fIname\fP に印を付け、
これ以降に実行するコマンドに環境経由でエクスポートします。
.PD
.PP
`\-' ではなく `+' を使うと属性を消します。
ただし例外として、\fB+a\fP を使って配列変数を破棄することはできません。
関数内で使った場合、
.B local
コマンドを使った場合と同様に \fIname\fP はローカルとなります。
返り値は基本的には 0 ですが、不正なオプションに出会った場合、
.if n ``\-f foo=bar''
.if t \f(CW\-f foo=bar\fP
を使って関数を定義しようとした場合、
読み込み専用の変数に代入しようとした場合、
複合代入構文を使わずに配列変数に値を代入しようとした場合 (前述の
.B 配列
を参照)、\fIname\fP のいずれかが正しいシェル変数名でない場合、
読み込み専用変数の読み込み専用属性を無効にしようとした場合、
存在しない関数を \fB\-f\fP オプションで表示しようとした場合は除きます。
.RE
.TP
.B dirs [\fB\-clpv\fP] [+\fIn\fP] [\-\fIn\fP]
オプションが無いときは、
現在記憶しているディレクトリのリストが表示されます。
デフォルトでは、全てのディレクトリ名は空白で区切って
1 行で表示されます。ディレクトリは
.B pushd
コマンドによってリストに追加されます。
.B popd
コマンドはリストからエントリを削除します。
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
オプション無しで
.B dirs
を起動した時に表示されるリストの、
左から数えて \fIn\fP 番目のエントリを表示します。
エントリは 0 から始まります。
.TP
\fB\-\fP\fIn\fP
オプション無しで
.B dirs
を起動した時に表示されるリストの、
右から数えて \fIn\fP 番目のエントリを表示します。
エントリは 0 から始まります。
.TP
.B \-c
全てのエントリを削除し、ディレクトリスタックをクリアします。
.TP
.B \-l
長い形式のリスト表示を行います。
デフォルトのリスト表示フォーマットでは、
チルダを使ってホームディレクトリを表します。
.TP
.B \-p
1 行に 1 エントリの形でディレクトリスタックを出力します。
.TP
.B \-v
1 行に 1 エントリの形でディレクトリスタックを出力します。
各エントリの前にはスタック内での番号が表示されます。
.PD
.PP
不正なオプションが与えられた場合とインデックス
\fIn\fP がディレクトリスタックの終端を越えている場合を除き、
返り値は 0 となります。
.RE
.TP
\fBdisown\fP [\fB\-ar\fP] [\fB\-h\fP] [\fIjobspec\fP ...]
オプション無しの場合には、それぞれの
.I jobspec
がアクティブなジョブのテーブルから削除されます。
\fB\-h\fP オプションが与えられている場合、どの
.I jobspec
もテーブルから削除されず、
シェルが
.SM
.BR SIGHUP
を受け取ってもそのジョブには
.SM
.B SIGHUP
が送られないように印が付けられます。
.I jobspec
がなく、かつ
.B \-a
オプションも
.B \-r
オプションも与えられていない場合には、\fIカレントジョブ\fPが使われます。
.I jobspec
が与えられていない場合、
.B \-a
オプションは全てのジョブを削除するか
全てのジョブに印を付けるという意味
となります。
.I jobspec
引き数なしで
.B \-r
オプションを指定すると、
実行中のジョブだけが操作の対象となります。
.I jobspec
が不正なジョブを指定していなければ、返り値は 0 となります。
.TP
\fBecho\fP [\fB\-neE\fP] [\fIarg\fP ...]
\fIarg\fP を空白で区切って出力し、最後に改行を出力します。
終了ステータスは常に 0 です。
\fB\-n\fP が指定された場合、最後の改行は出力されません。
\fB\-e\fP オプションを指定した場合、
以下に示す、バックスラッシュのエスケープ文字が解釈されるようになります。
.B \-E
オプションを指定すると、
デフォルトでこのようなエスケープ文字が解釈されるシステムであっても、
エスケープ文字が解釈されないようになります。
\fBxpg_echo\fP シェルオプションを用いると、
\fBecho\fP がこれらのエスケープ文字を展開するかどうかの
デフォルト動作を動的に決定できます。
.B echo
は
.B \-\-
をオプションの終わりと解釈しません。
.B echo
は以下のエスケープシーケンスを解釈します:
.RS
.PD 0
.TP
.B \ea
警告(ベル)
.TP
.B \eb
バックスペース
.TP
.B \ec
行末に改行を付けない
.TP
.B \ee
エスケープ文字
.TP
.B \ef
フォームフィード文字
.TP
.B \en
改行
.TP
.B \er
復帰文字
.TP
.B \et
水平タブ
.TP
.B \ev
垂直タブ
.TP
.B \e\e
バックスラッシュ
.TP
.B \e\fInnn\fP
ASCII コードの 8 進値が \fInnn\fP である文字 (1 文字につき数字 3 桁)。
.TP
.B \ex\fInnn\fP
ASCII コードの 16 進値が \fInnn\fP である文字 (1 文字につき数字 3 桁)。
.PD
.RE
.TP
\fBenable\fP [\fB\-adnps\fP] [\fB\-f\fP \fIfilename\fP] [\fIname\fP ...]
組み込みコマンドの有効/無効を設定します。
シェルは通常はディスクコマンドの前に組み込みコマンドを探しますが、
組み込みコマンドを無効にすると、
シェルの組み込みコマンドと同じ名前を持つディスクコマンドを、
完全なパス名を指定しなくても実行できます。
\fB\-n\fP を用いると、それぞれの \fIname\fP は無効となります。
それ以外の場合には、\fIname\fP は有効となります。
例えば、シェル組み込みのものでなく
.SM
.B PATH
上にある
.B test
バイナリを使うには
.if t \f(CWenable -n test\fP.
.if n ``enable -n test''.
を実行します。
.B \-f
オプションは新しい組み込みコマンド
.I name
を共有オブジェクト
.I filename
からロードするという意味です。
これは動的ロードをサポートしているシステムで使えます。
.B \-d
オプションは、以前に
.B \-f
オプションでロードした組み込みコマンドを削除します。
引き数 \fIname\fP が与えられなかった場合や、
.B \-p
オプションが与えられた場合、
シェルの組み込みコマンドのリストが表示されます。
他にオプション引き数が指定されていない場合には、
有効になっているシェル組み込みコマンド全てからなるリストが表示されます。
\fB\-n\fP を与えると、無効にされている組み込みコマンドだけが出力されます。
\fB\-a\fP を与えると、
それぞれ有効かどうかの表示付きで全ての組み込みコマンドが出力されます。
\fB\-s\fP を与えると、出力されるのは
POSIX の\fI特殊\fP組み込みコマンドだけに制限されます。
.I name
がシェル組み込みコマンドでない場合と、
共有オブジェクトからの新しい組み込みコマンドのロードに失敗した場合を除き、
返り値は 0 となります。
.TP
\fBeval\fP [\fIarg\fP ...]
\fIarg\fP を読み込み、結合して 1 つのコマンドにされます。
次にシェルはこのコマンドを読み込んで実行し、
その終了ステータスが
.B eval
の値として返されます。
.I args
が無い場合や空の引き数しかない場合には
.B eval
は 0 を返します。
.TP
\fBexec\fP [\fB\-cl\fP] [\fB\-a\fP \fIname\fP] [\fIcommand\fP [\fIarguments\fP]]
.I command
が指定されていると、シェルはこのコマンドに置き換えられます。
新しいプロセスは生成されません。
.I arguments
は \fIcommand\fP に対する引き数となります。
.B \-l
オプションを与えると、シェルは
.I command
に渡す 0 番目のオプションの先頭にダッシュを設定します。
これは
.IR login (1)
が行う動作です。
.B \-c
オプションを与えると、
.I command
は空の環境で実行されます。
.B \-a
を与えると、シェルは実行するコマンドに 0 番目の引き数として
.I name
を渡します。何らかの理由で
.I command
が実行できない場合には非対話的シェルは終了します。
ただしシェルオプション
.B execfail
が設定されている場合は終了せず、この場合には偽が返されます。
ファイルが実行できない場合には、対話的シェルは偽を返します。
.I command
が指定されていない場合、任意のリダイレクトはカレントシェルで効果を表し、
終了ステータスは 0 となります。
リダイレクトのエラーが起きた場合には、終了ステータスは 1 となります。
.TP
\fBexit\fP [\fIn\fP]
ステータス \fIn\fP でシェルを終了させます。
.I n
を省略すると、
終了ステータスは最後に実行したコマンドの終了ステータスとなります。
シェルが終了する前には、
.SM
.B EXIT
に対するトラップが実行されます。
.TP
.PD 0
\fBexport\fP [\fB\-fn\fP\^] [\fIname\fP[=\fIword\fP]] ...
.TP
.B export \-p
.PD
与えられた
.I name
には印が付けられ、
これ以降に実行するコマンドの環境に
自動的にエクスポートされるようになります。
.B \-f
オプションを与えると、
.I name
は関数を参照します。
.I name
を与えなかった場合や、
.B \-p
オプションを与えた場合には、
このシェル内でエクスポートされている全ての名前のリストが出力されます。
.B \-n
オプションを与えると、指定した変数からエクスポート属性が取り除かれます。
不正なオプションがあった場合、
\fIname\fP のいずれかが不正なシェル変数名であった場合、
関数でない名前に対して
.B \-f
オプションを与えた場合を除き、
.B export
は終了ステータス 0 を返します。
.TP
.PD 0
\fBfc\fP [\fB\-e\fP \fIename\fP] [\fB\-nlr\fP] [\fIfirst\fP] [\fIlast\fP]
.TP
\fBfc\fP \fB\-s\fP [\fIpat\fP=\fIrep\fP] [\fIcmd\fP]
.PD
フィックスコマンド (Fix Command)。
最初の形式では、
.I first
から
.I last
までの範囲のコマンドが履歴リストから選択されます。
.I first
と
.I last
は文字列 (その文字列で始まる最後のコマンド) や
数値 (履歴リスト中でのインデックス。
負の値は現在のコマンド番号からのオフセットとして扱われます)
としても指定できます。
.I last
が指定されていなければ、リスト表示の場合には現在のコマンドが設定され
(したがって
.if n ``fc \-l \-10''
.if t \f(CWfc \-l \-10\fP
で最近のコマンド 10 個が出力されます)、それ以外の場合には
.I first
が設定されます。
.I first
が指定されていなければ、編集の場合には前のコマンドが設定され、
リスト表示の場合には \-16 が設定されます。
.sp 1
.B \-n
オプションを与えるとリストにコマンド番号が付きません。
.B \-r
オプションを与えるとコマンドの順序が逆になります。
.B \-l
オプションを与えると、コマンドは標準出力にリスト表示されます。
それ以外の場合には、これらのコマンドが書かれたファイルに対し、
.I ename
で指定したエディタが起動されます。
.I ename
が与えられていない場合は、変数
.SM
.B FCEDIT
の値が使われ、
.SM
.B FCEDIT
も設定されていない場合には
.SM
.B EDITOR
の値が使われます。
どちらの変数も設定されていなければ、
.FN vi
が使われます。
編集が終了すると、編集されたコマンドがエコー表示され、実行されます。
.sp 1
2 番目の形式では、\fIpat\fP の部分をそれぞれ \fIrep\fP で置き換えた後に
\fIcommand\fP が再実行されます。
これを利用している便利なエイリアスに
.if n ``r=fc -s''
.if t \f(CWr='fc \-s'\fP
があります。
これを用いると
.if n ``r cc''
.if t \f(CWr cc\fP
と入力すれば
.if n ``cc''
.if t \f(CWcc\fP
で始まる最も新しいコマンドを実行でき、
.if n ``r''
.if t \f(CWr\fP
の入力すれば直前のコマンドを再実行できます。
.sp 1
最初の形式を用いた場合、不正なオプションがあるか、
.I first
または
.I last
が履歴行の範囲外を指定していなければ、返り値は 0 となります。
.B \-e
オプションが与えられた場合、
返り値は最後に実行されたコマンドの返り値となるか、
あるいはコマンドの一時ファイルでエラーが起きた場合には偽となります。
2 番目の形式を用いた場合、
終了ステータスは再実行されたコマンドの終了ステータスとなります。
ただし、
.I cmd
が有効な履歴行を指定していない場合は別で、この場合には
.B fc
は偽を返します。
.TP
\fBfg\fP [\fIjobspec\fP]
.I jobspec
の実行をフォアグラウンドで再開し、これをカレントジョブとします。
.I jobspec
が無い場合、シェルが記録している\fIカレントジョブ\fPが使われます。
返り値はフォアグラウンドで再開されたコマンドの返り値ですが、
ジョブ制御が無効であるときに実行した場合や、
ジョブ制御が有効であっても
.I jobspec
が有効なジョブを指定していない場合や
.I jobspec
がジョブ制御無しで実行したジョブを指定している場合には偽となります。
.TP
\fBgetopts\fP \fIoptstring\fP \fIname\fP [\fIargs\fP]
.B getopts
はシェルの手続きが位置パラメータを解釈するために使います。
.I optstring
は識別の対象であるオプション文字列です。
ある文字の後にコロンがある場合、
そのオプションは引き数を取ることが期待されます。
引き数は空白でオプション文字と区切られていなければなりません。
コロンと疑問符はオプション文字として使えません。
呼び出される度に、
.B getopts
は次に見つかったオプションをシェル変数
.I name
に格納し
.RI ( name
が存在しなければ初期化を行います)、
次に処理される引き数のインデックスを変数
.SM
.B OPTIND
に格納します。
.SM
.B OPTIND
はシェルまたはシェルスクリプトが呼び出される度に 1 に初期化されます。
オプションが引き数を必要とする場合には、
.B getopts
はその引き数を変数
.SM
.B OPTARG
に格納します。
シェルが
.SM
.B OPTIND
を自動的に再設定することはありません。
1 つのシェルが呼び出されている間に別のパラメータの組合せを使う場合には、
.B getopts
の呼び出しの間に手動で再設定を行わなければなりません。
.sp 1
オプションの終わりに到達すると、
\fBgetopts\fP は 0 より大きい返り値で終了します。
\fBOPTIND\fP にはオプションでない最初の引き数のインデックスが設定され、
\fBname\fP には ? が設定されます。
.sp 1
.B getopts
は通常位置パラメータを展開しますが、他の引き数が
.I args
に指定されている場合には、
.B getopts
は位置パラメータでなくこれらを展開します。
.sp 1
.B getopts
は 2 通りの方法でエラーを報告できます。
.I optstring
の最初の文字がコロンならば、
.I 静かな (silent)
エラー報告が行われます。
通常の操作では、不正なオプションがある場合や
オプションの引き数が足りない場合に診断メッセージが出力されます。
変数
.SM
.B OPTERR
に 0 が設定されている場合、エラーメッセージは全く出力されません。
これは、
.I optstring
の最初の文字がコロンでなくても同じです。
.sp 1
不正なオプションがあった場合、
.B getopts
は ? を
.I name
に設定します。
さらに、静かなモードでない場合にはエラーメッセージが出力され、
.SM
.B OPTARG
の設定が取り消されます。
.B getopts
が静かなモードであれば、見つかったオプション文字は
.SM
.B OPTARG
に設定され、診断メッセージは出力されません。
.sp 1
必要な引き数が見つからず、かつ
.B getopts
が静かなモードでない場合には、疑問符 (\^\fB?\fP\^) が
.I name
に設定され、
.B OPTARG
の設定が取り消され、診断メッセージが出力されます。
.B getopts
が静かなモードならば、コロン (\^\fB:\fP\^) が
.I name
に設定され、
.SM
.B OPTARG
には見つかったオプション文字が設定されます。
.sp 1
(指定の有無に関係なく) オプションが見つかった場合、
.B getopts
は真を返します。
オプションの最後に到達した場合や、エラーが起きた場合には、
.B getopts
は偽を返します。
.TP
\fBhash\fP [\fB\-r\fP] [\fB\-p\fP \fIfilename\fP] [\fIname\fP]
.I name
それぞれに対して、
.B $PATH
内のディレクトリの検索を行ってコマンドの完全なファイル名を調べ、
その結果を記憶します。
.B \-p
オプションが指定されると、パス検索は実行されず、
.I filename
がそのコマンドの完全なファイル名として使われます。
.B \-r
オプションを与えると、シェルは記憶している位置を全て忘れます。
引き数が与えられていない場合は、
記憶しているコマンドに関する情報が出力されます。
.I name
が見つからない場合と不正なオプションが与えられた場合を除き、
返却ステータスは真となります。
.TP
\fBhelp\fP [\fB\-s\fP] [\fIpattern\fP]
組み込みコマンドのヘルプ情報を表示します。
.I pattern
が指定された場合には、
.B help
はこの
.I pattern
にマッチする全てのコマンドに関する詳しいヘルプを出力します。
それ以外の場合には、
全ての組み込みコマンドと制御構造についての説明が出力されます。
\fB\-s\fP オプションは、表示されるヘルプ情報を短い書式の使用法に限定します。
.I pattern
にマッチするコマンドが全くない場合を除き、返却ステータスは 0 です。
.TP
.PD 0
\fBhistory [\fIn\fP]
.TP
\fBhistory\fP \fB\-c\fP
.TP
\fBhistory \-d\fP \fIoffset\fP
.TP
\fBhistory\fP \fB\-anrw\fP [\fIfilename\fP]
.TP
\fBhistory\fP \fB\-p\fP \fIarg\fP [\fIarg ...\fP]
.TP
\fBhistory\fP \fB\-s\fP \fIarg\fP [\fIarg ...\fP]
.PD
オプションがない場合には、行番号付きでコマンド履歴を表示します。
.B *
付きでリスト表示されている行は変更された行です。
引き数
.I n
を指定すると、最新の
.I n
行だけがリスト表示されます。
\fIfilename\fP が与えられている場合、
これは履歴ファイルの名前として使われます。
これが与えられていない場合には
.SM
.B HISTFILE
の値が使われます。(指定されていれば) オプションは以下の意味を持ちます:
.RS
.PD 0
.TP
.B \-c
履歴リストの全てのエントリを削除し、クリアします。
.TP
\fB\-d\fP \fIoffset\fP
\fIoffset\fP 番目にある履歴エントリを削除します。
.TP
.B \-a
「新しい」履歴行
(\fBbash\fP の現在のセッションの開始以来入力された履歴行)
を履歴ファイルに追加します。
.TP
.B \-n
まだ履歴ファイルから読み込んでいない履歴行を
現在の履歴リストに読み込みます。
これらは、\fBbash\fP の現在のセッションの開始以降に
履歴ファイルに追加された行です。
.TP
.B \-r
履歴ファイルの内容を読み込み、これらを現在の履歴として用います。
.TP
.B \-w
現在の履歴を履歴ファイルに書き込みます。履歴ファイルの内容は上書きされます。
.TP
.B \-p
後に続く \fIargs\fP に対して履歴置換を行い、
その結果を標準出力に表示します。
この結果は履歴リストには格納されません。
通常の履歴展開が行われないようにするため、
\fIarg\fP はそれぞれクォートしなければなりません。
.TP
.B \-s
.I args
を 1 つのエントリとして履歴リストに格納します。
履歴リストの最後のコマンドは、
.I args
が追加される前に削除されます。
.PD
.PP
不正なオプションがある場合、
履歴ファイルの読み書きの間にエラーが起きた場合、
\fB\-d\fP オプションの引き数として不正な \fIoffset\fP の値が与えられた場合、
\fB\-p\fP オプションの引き数として与えられた履歴展開が失敗した場合を除き、
返り値は 0 になります。
.RE
.TP
.PD 0
\fBjobs\fP [\fB\-lnprs\fP] [ \fIjobspec\fP ... ]
.TP
\fBjobs\fP \fB\-x\fP \fIcommand\fP [ \fIargs\fP ... ]
.PD
最初の形式を実行すると、アクティブなジョブがリスト表示されます。
オプションは以下の意味を持ちます:
.RS
.PD 0
.TP
.B \-l
通常の情報に加えて、プロセス ID をリスト表示します。
.TP
.B \-p
そのジョブが属するプロセスグループのリーダーのプロセス ID だけを表示します。
.TP
.B \-n
ユーザがステータスを最後に通知されて以来、
ステータスの変更があったジョブに関する情報だけを表示します。
.TP
.B \-r
実行中のジョブだけを出力します。
.TP
.B \-s
停止中のジョブだけを出力します。
.PD
.PP
.I jobspec
が与えられている場合、
そのジョブに関する情報だけが出力されるます。
不正なオプションがある場合や、不正な
.I jobspec
が与えられた場合を除き、返却ステータスは 0 です。
.PP
.B \-x
オプションが与えられた場合、
.B jobs
は
.I command
や
.I args
中で見つかった
.I jobspec
を全て対応するプロセスグループ ID に置き換え、
.I args
を渡して
.I command
を実行し、その終了ステータスを返します。
.RE
.TP
.PD 0
\fBkill\fP [\fB\-s\fP \fIsigspec\fP | \fB\-n\fP \fIsignum\fP | \fB\-\fP\fIsigspec\fP] [\fIpid\fP | \fIjobspec\fP] ...
.TP
\fBkill\fP \fB\-l\fP [\fIsigspec\fP | \fIexit_status\fP]
.PD
.I sigspec
または
.I signum
で指定されたシグナルを、
.I pid
または
.I jobspec
で指定されたプロセスに送ります。
.I sigspec
は
.SM
.B SIGKILL
のようなシグナル名、またはシグナルの番号です。
.I signum
はシグナルの番号です。
.I sigspec
がシグナル名ならば、その名前には
.SM
.B SIG
プレフィックスはあっても無くても構いません。
.I sigspec
が無い場合には、
.SM
.B SIGTERM
が指定されたものとします。
引き数に
.B \-l
を与えるとシグナル名がリスト表示されます。
.B \-l
と同時に引き数を与えると、
引き数に対応するシグナルの名前がリスト表示され、
返却ステータスは 0 となります。
.B \-l
に対する引き数 \fIexit_status\fP は、
シグナル番号、またはシグナルによって終了させられた
プロセスの終了ステータスを指定する数です。
少なくとも 1 つのシグナルを正常に送れた場合、
.B kill
は真を返します。
エラーが起きた場合や不正なオプションがあった場合には、
.B kill
は偽を返します。
.TP
\fBlet\fP \fIarg\fP [\fIarg\fP ...]
各
.I arg
は評価される算術式です (
.SM
.B 算術式展開
を参照)。
最後の
.I arg
を評価した結果が 0 であれば、
.B let
は 1 を返します。
それ以外の場合には 0 が返されます。
.TP
\fBlocal\fP [\fIoption\fP] [\fIname\fP[=\fIvalue\fP] ...]
それぞれの引き数に対して
.I name 
という名前のローカル変数が生成され、
.I value
が代入されます。
\fIoption\fP には、
\fBdeclare\fP コマンドに使えるオプションがすべて使えます。
関数内で
.B local
を使った場合、この変数
.I name
の可視スコープは、この関数とこの関数の子に制限されます。
オペランドが無い場合、
.B local
はローカル変数の一覧を標準出力に出力します。
関数の内部以外で
.B local
を使うとエラーになります。
.B local
が関数の外部で使われたり、
不正な
.I name
が与えられたり、
\fIname\fP が読み取り専用であったりしなければ、
.B local
の返却ステータスは 0 となります。
.TP
.B logout
ログインシェルを終了します。
.TP
\fBpopd\fP [\-\fBn\fP] [+\fIn\fP] [\-\fIn\fP]
ディレクトリスタックからエントリを削除します。
引き数が無い場合には、スタック先頭のディレクトリが削除され、
新しく先頭となったディレクトリへの
.B cd
が実行されます。
引き数が指定された場合には、これは以下の意味を持ちます:
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
.B dirs
で表示されるリストの左から数えて \fIn\fP 番目のエントリを削除します。
エントリは 0 から数えます。例えば、
.if n ``popd +0''
.if t \f(CWpopd +0\fP
は最初のディレクトリを削除し、
.if n ``popd +1''
.if t \f(CWpopd +1\fP
は 2 番目のディレクトリを削除します。
.TP
\fB\-\fP\fIn\fP
.B dirs
で表示されるリストの右から数えて \fIn\fP 番目のエントリを削除します。
エントリは 0 から数えます。例えば、
.if n ``popd -0''
.if t \f(CWpopd -0\fP
は最後のディレクトリを削除し、
.if n ``popd -1''
.if t \f(CWpopd -1\fP
は最後の 1 つ前のディレクトリを削除します。
.TP
.B \-n
スタックからディレクトリを削除する際に、
通常のディレクトリ変更を行いません。
したがって、スタックだけが操作されます。
.PD
.PP
.B popd
コマンドが成功すれば、
.B dirs
も実行され、返却ステータスは 0 となります。
.B popd
が偽を返すのは、不正なオプションがあった場合・
ディレクトリスタックが空の場合・
ディレクトリスタックの存在しないエントリが指定された場合・
ディレクトリ変更に失敗した場合です。
.RE
.TP
\fBprintf\fP \fIformat\fP [\fIarguments\fP]
\fIarguments\fP を整形して標準出力に書き出します。
フォーマットは \fIformat\fP で制御します。
\fIformat\fP は 3 つのタイプのオブジェクトを含む文字列です。
3 つのオブジェクトとは、(そのまま標準出力にコピーされる) プレーン文字・
(変換されて標準出力にコピーされる) 文字エスケープシーケンス・
(その後に続く引き数 \fIargument\fP それぞれの表示に用いられる)
表示フォーマット指定、です。
\fIprintf\fP(1) 標準のフォーマット以外に、以下のフォーマットが使えます。
%b を用いると、\fBprintf\fP は対応する \fIargument\fP 中の
バックスラッシュのエスケープシーケンスを展開します。
また %q を用いると、\fBprintf\fP は対応する
\fIargument\fP をシェルの入力として再利用できるフォーマットで出力します。
.sp 1
\fIformat\fP は必要に応じて再利用され、
全ての \fIarguments\fP を処理します。
与えられたよりも多くの \fIarguments\fP を
\fIformat\fP が必要とする場合、余分のフォーマット指定は、
0 と空文字列のうち、適切な方が指定されたかのように動作します。
成功した場合の返り値は 0 で、失敗した場合の返り値は 0 以外です。
.TP
.PD 0
\fBpushd\fP [\fB\-n\fP] [\fIdir\fP]
.TP
\fBpushd\fP [\fB\-n\fP] [+\fIn\fP] [\-\fIn\fP]
.PD
ディレクトリをディレクトリのスタックに追加するか、
スタックをローテートさせます。
この時、新しいスタックの最も上にあるものを
カレントの作業ディレクトリにします。
引き数を与えなければ、
一番上の 2 つのディレクトリを交換し、0 を返します。
ただし、ディレクトリスタックが空の場合を除きます。
引き数を与えた場合には、以下の意味を持ちます:
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
スタックをローテートさせ、\fIn\fP 番目のディレクトリを一番上にします。
このとき
.B dirs
が表示するリストは左から数え始め、その左端は 0 となります。
.TP
\fB\-\fP\fIn\fP
スタックをローテートさせ、\fIn\fP 番目のディレクトリを一番上にします。
このとき
.B dirs
が表示するリストは右から数え始め、その右端は 0 となります。
.TP
.B \-n
ディレクトリをスタックに追加した時に、
通常のディレクトリ変更を行いません。
したがって、スタックだけが操作されます。
.TP
.I dir
.I dir
をディレクトリスタックの一番上に追加します。
また、このディレクトリを新しいカレントの作業ディレクトリにします。
.PD
.PP
.B pushd
コマンドが成功すると、
.B dirs
コマンドも実行されます。
最初の形式を使った場合、
.I dir
への cd が失敗しなければ、
.B pushd
は 0 を返します。
2 番目の形式を使った場合にも、
.B pushd
は基本的には 0 を返します。
ただし、ディレクトリスタックが空の場合・
ディレクトリスタックの存在しない要素が指定された場合・
指定された新しいカレントディレクトリへの
ディレクトリ変更が失敗した場合は除きます。
.RE
.TP
\fBpwd\fP [\fB\-LP\fP]
現在の作業ディレクトリの絶対パス名を出力します。
.B \-P
オプションが指定された場合や、組み込みコマンド
.B set
の
.B \-o physical
オプションが有効になっている場合には、
出力されるパス名にはシンボリックリンクは含まれません。
.B \-L
オプションを使うと、
出力されるパス名にはシンボリックリンクが含まれているかもしれません。
カレントディレクトリの名前を読む際にエラーが起きたり、
不正なオプションが与えられなければ、返却ステータスは 0 となります。
.TP
\fBread\fP [\fB\-ers\fP] [\fB\-t\fP \fItimeout\fP] [\fB\-a\fP \fIaname\fP] [\fB\-p\fP \fIprompt\fP] [\fB\-n\fP \fInchars\fP] [\fB\-d\fP \fIdelim\fP] [\fIname\fP ...]
標準入力から 1 行を読み込み、最初の単語を最初の
.I name
に代入し、2 番目の単語を 2 番目の
.I name
に代入します。以降も同様です。
余った単語とそれらの間の区切り文字は、最後の
.I name
に代入されます。
.I name
よりも標準入力から読み込んだ単語の方が少ない場合には、
余っている
.I name
には空文字列が値として代入されます。
.SM
.B IFS
中の文字が、行を単語に分割するために使われます。
バックスラッシュ文字 (\fB\e\fP) を使うと、
次に読み込んだ文字の特殊な意味を消したり、行を連結したりできます。
オプションが与えられていれば、以下の意味を持ちます:
.RS
.PD 0
.TP
.B \-a \fIaname\fP
単語を配列変数
.I aname
にインデックス順に代入します。インデックスは 0 から始まります。
新しい値が代入される前には、
.I aname
の設定は消されます。他の
\fIname\fP
引き数は無視されます。
.TP
.B \-d \fIdelim\fP
改行ではなく、\fIdelim\fP の最初の文字が、入力行を終了するために使われます。
.TP
.B \-e
標準入力を端末から読み込む場合、
.B readline
(前述の
.SM
.B READLINE ライブラリ
のセクションを参照) を使って行を取得します。
.TP
.B \-n \fInchars\fP
組み込みコマンド \fBread\fP は、
入力行全体が読み込まれるのを待たず、
文字 \fInchars\fP を読み込んだ時に戻ります。
.TP
.B \-p \fIprompt\fP
入力を読み込もうとする前に\fIプロンプト\fPを表示します。
末尾に改行は付きません。
プロンプトが表示されるのは、入力を端末から読み込む場合だけです。
.TP
.B \-r
バックスラッシュはエスケープ文字として作用しません。
バックスラッシュは行の一部と見なされます。
特に、バックスラッシュと改行の組合せを使って
複数の行を接続することはできません。
.TP
.B \-s
静かな (silent) モード。端末に入力が行われても、文字はエコーされません。
.TP
.B \-t \fItimeout\fP
入力行全体が \fItimeout\fP 秒以内で読み込まれない場合、
\fBread\fP をタイムアウトさせて、失敗の状態を返します。
このオプションは、
\fBread\fP が入力を端末やパイプから読み込んでいない場合、
何も効果がありません。
.PD
.PP
.I name
が全く与えられていない場合、読み込まれた行は変数
.SM
.B REPLY
に代入されます。ファイル末尾に到達したり
\fBread\fP がタイムアウトしたりしなければ、終了コードは 0 です。
.RE
.TP
\fBreadonly\fP [\fB\-apf\fP] [\fIname\fP ...]
.PD
指定された \fIname\fP に読み込み専用の印を付けます。
それ以降は、このような
.I name
の値を変更することはできません。
.B \-f
オプションを与えた場合、\fIname\fP に対応する関数に同様の印が付きます。
.B \-a
オプション与えると、配列変数だけが対象となります。
.I name
引き数が全く与えられてない場合、または
.B \-p
オプションが与えられた場合、読み込み専用の名前全ての一覧が出力されます。
.B \-p
オプションを使うと、
入力として再利用できるようなフォーマットで出力が行われます。
返却ステータスは基本的に 0 ですが、
不正なオプションがあった場合、
.I name
のいずれかが有効なシェル変数名で無かった場合、
.B \-f
オプションに関数でない
.I name
を与えた場合は除きます。
.TP
\fBreturn\fP [\fIn\fP]
指定した返り値
.I n
で関数を終了させます。
.I n
を省略すると、返却ステータスは
関数内で最後に実行したコマンドの返却ステータスになります。
関数の外側で使われているが、
.B .
(\fBsource\fP) コマンドによるスクリプトの実行中である場合、
シェルはそのスクリプトの実行を止め、
.I n
またはスクリプト内で最後に実行されたコマンドの終了ステータスを
スクリプトの終了ステータスとして返します。
関数の外側で \fB.\fP\^ によるスクリプトの実行中以外に使われた場合、
返却ステータスは偽となります。
.TP
\fBset\fP [\fB\-\-abefhkmnptuvxBCHP\fP] [\fB\-o\fP \fIoption\fP] [\fIarg\fP ...]
オプション無しの場合は、シェル変数全ての名前と値の組が表示されます。
表示は、入力として再利用できるフォーマットで行われます。
出力は現在のロケールに従ってソートされます。
オプションが指定されている場合、
オプションはシェルの属性を設定または解除します。
オプションが処理された後に残っている引き数があれば、
これは位置パラメータの値として扱われ、
.BR $1 ,
.BR $2 ,
.B ...
.B $\fIn\fP
の順に代入されます。
オプションが指定されていれば、以下の意味を持ちます:
.RS
.PD 0
.TP 8
.B \-a
値を変更したり新規に設定したりした変数および関数が、
自動的に (後に実行するコマンドの) 環境として
エクスポートされるようになります。
.TP 8
.B \-b
終了したバックグラウンドジョブのステータス報告を、
次のプライマリプロンプトの前ではなく、即座に行います。
これはジョブ制御が有効な場合に限り有効です。
.TP 8
.B \-e
\fI単純なコマンド\fP (前述の
.SM
.B シェルの文法
セクションを参照) が 0 でないステータスで終了した場合、即座に終了します。
ただし失敗したコマンドが
.I until
または
.I while
ループの一部である、
.I if
文の一部である、
.B &&
または
.B \(bv\(bv
リストの一部である、
コマンドの返り値が
.B !
で反転されている、のいずれかの場合にはシェルは終了しません。
.TP 8
.B \-f
パス名展開を無効にします。
.TP 8 
.B \-h
コマンドの位置を記憶し、実行時にこれを引きます。
これはデフォルトで有効になっています。
.TP 8
.B \-k
代入文の形式を持つ全ての引き数を、コマンドに対する環境に追加します。
環境変数となるのは、コマンド名の前にあるものに限りません。
.TP 8
.B \-m
監視モード。ジョブ制御は有効になります。ジョブ制御 (前述の
.SM
.B ジョブ制御
セクションを参照) をサポートしているシステム上の対話的シェルでは、
このオプションはデフォルトで有効です。
別のプロセスグループで実行されたバックグラウンドプロセスと、
これらの終了ステータスが書かれた行が、プロセスの終了時に表示されます。
.TP 8
.B \-n
コマンドを読み込みますが実行はしません。
これを使うとシェルスクリプトの文法エラーをチェックできます。
このオプションは対話的シェルでは無視されます。
.TP 8
.B \-o \fIoption\-name\fP
\fIoption\-name\fP には、以下のいずれかを指定できます:
.RS
.TP 8
.B allexport
.B \-a
と同じです。
.TP 8
.B braceexpand
.B \-B
と同じです。
.TP 8
.B emacs
emacs 形式のコマンド行編集インタフェースを使います。
これはシェルが対話的な場合には、デフォルトで有効です。
ただし、
.B \-\-noediting
オプション付きでシェルを実行した場合は除きます。
.TP 8
.B errexit
.B \-e
と同じです。
.TP 8
.B hashall
.B \-h
と同じです。
.TP 8
.B histexpand
.B \-H
と同じです。
.TP 8
.B history
コマンド履歴を有効にします。コマンド履歴については
.SM
.B 履歴
セクションで説明しています。
このオプションは、対話的シェルではデフォルトで有効です。
.TP 8
.B ignoreeof
効果は、シェルコマンドの
.if t \f(CWIGNOREEOF=10\fP
.if n ``IGNOREEOF=10''
を実行した場合と同様です
(前述の
.B シェル変数
を参照)。
.TP 8
.B keyword
.B \-k
と同じです。
.TP 8
.B monitor
.B \-m
と同じです。
.TP 8
.B noclobber
.B \-C
と同じです。
.TP 8
.B noexec
.B \-n
と同じです。
.TP 8
.B noglob
.B \-f
と同じです。
.TP 8
.B notify
.B \-b
と同じです。
.TP 8
.B nounset
.B \-u
と同じです。
.TP 8
.B onecmd
.B \-t
と同じです。
.TP 8
.B physical
.B \-P
と同じです。
.TP 8
.B posix
.B bash
の動作を変えます。
デフォルトの操作は POSIX 1003.2 標準と異なりますが、
これを標準に準拠するようにします (\fIposix モード\fP)。
.TP 8
.B privileged
.B \-p
と同じです。
.TP 8
.B verbose
.B \-v
と同じです。
.TP 8
.B vi
vi 形式のコマンド行編集インタフェースを使います。
.TP 8
.B xtrace
.B \-x
と同じです。
.sp .5
.PP
\fIoption\-name\fP 無しで
.B \-o
オプションを与えた場合、現在のオプションが出力されます。
\fIoption\-name\fP 無しで
.B +o
オプションを与えた場合、現在のオプション設定を再生成する
.B set
コマンドの列が標準出力に出力されます。
.RE
.TP 8
.B \-p
.I 特権 (privileged)
モードを有効にします。このモードでは
.SM
.B $ENV
と
.SM
.B $BASH_ENV
ファイルは処理されず、シェル関数は環境から継承されず、
.SM
.B SHELLOPTS
環境変数は定義されていても無視されます。
シェルを起動した時に実効ユーザ (グループ) ID が
実ユーザ (グループ) ID と異なり、
かつ \fB\-p\fP オプションが与えられていない場合、
これらの動作が行われ、実効ユーザ ID には実ユーザ ID が設定されます。
起動時に \fB\-p\fP オプションが与えられた場合、
実効ユーザ ID は再設定されません。
このオプションを無効にすると、
実効ユーザ ID と実効グループ ID には
実ユーザ ID と 実グループ ID が設定されます。
.TP 8
.B \-t
コマンドを 1 つ読み込み、実行してから終了します。
.TP 8
.B \-u
パラメータ展開の実行中に、設定が取り消されている変数をエラーとして扱います。
設定が取り消されている変数を展開しようとした場合、
シェルはエラーメッセージを出力します。
シェルが対話的でなければ、0 でないステータスで終了します。
.TP 8
.B \-v
シェルの入力行を、読み込んだ際に表示します。
.TP 8
.B \-x
\fI単純なコマンド\fPをそれぞれ展開した後、
.SM
.B PS4
を展開した値を表示し、その後にそのコマンドと展開した引き数を表示します。
.TP 8
.B \-B
シェルはブレース展開 (前述の
.B ブレース展開
を参照) を実行します。これはデフォルトで有効です。
.TP 8
.B \-C
設定されている場合、
.B bash
はリダイレクト演算子
.BR > ,
.BR >& ,
.B <>
で既存のファイルを上書きしません。
上書きができるのは、リダイレクト演算子
.B >|
を
.B >
の代わりに使った時です。
.TP 8
.B \-H
.B !
形式の履歴置換を有効にします。
このオプションは、シェルが対話的な時にはデフォルトで有効です。
.TP 8
.B \-P
設定されている場合、
.B cd
のような現在の作業ディレクトリを変更するコマンドを実行する時に、
シェルはシンボリックリンクを辿りません。
代わりに物理的ディレクトリ構造が使われます。
デフォルトでは、
.B bash
がカレントディレクトリを変更するコマンドを実行する際には、
ディレクトリの論理的な接続が辿られます。
.TP 8
.B \-\-
このオプションの後に引き数が続いていない場合には、
位置パラメータの設定が取り消されます。
それ以外の場合には、位置パラメータに \fIarg\fP の残りが設定されます。
これらに
.B \-
で始まるものが含まれていても、
オプションではなく位置パラメータとして扱われます。
.TP 8
.B \-
オプションの終わりを示します。
残りの \fIarg\fP は全て位置パラメータに代入されます。
.B \-x
オプションと
.B \-v
オプションは無効になります。
\fIarg\fP が無い場合には、位置パラメータの内容は変化しません。
.PD
.PP
特に断らない限り、各オプションはデフォルトで無効になっています。
\- の代わりに + を使うと、これらのオプションは無効になります。
オプションはシェルを起動する際の引き数としても指定できます。
現在のオプションの集合は、
.B $\-
で知ることができます。
不正なオプションが無ければ、終了ステータスは必ず真となります。
.RE
.TP
\fBshift\fP [\fIn\fP]
\fIn\fP+1 ... からの位置パラメータの名前を変え、
.B $1
.B ...
とします。
\fB$#\fP から \fB$#\fP\-\fIn\fP+1 までの数字で表される
パラメータは unset されます。
.I n
は 0 以上 \fB$#\fP 以下の数でなければなりません。
.I n
が 0 ならば、どのパラメータも変更されません。
.I n 
が与えられない場合には、1 が指定されたものと見なされます。
.I n
が \fB$#\fP より大きい場合、位置パラメータは変化しません。
.I n
が
.B $#
より大きい場合や 0 より小さい場合には、
返却ステータスは 0 より大きい数になります。
それ以外の場合には 0 になります。
.TP
\fBshopt\fP [\fB\-pqsu\fP] [\fB\-o\fP] [\fIoptname\fP ...]
シェルのオプション動作を制御する変数の値をトグルさせます。
オプションが無い場合や、
.B \-p
オプションが指定されている場合には、
設定可能なオプション全てのリストが表示されます。
表示の際には、それぞれが設定されているかどうかも示されます。
\fB\-p\fP オプションが指定されていると、
オプションの表示は、入力として再利用できるフォーマットで行われます。
その他のオプションは、以下の意味を持っています:
.RS
.PD 0
.TP
.B \-s
\fIoptname\fP をそれぞれ有効にします (設定します)。
.TP
.B \-u
\fIoptname\fP をそれぞれ無効にします (設定解除します)。
.TP
.B \-q
通常の出力を止めます (静かなモード)。
返却ステータスは \fIoptname\fP が設定されているかどうかを示します。
複数の \fIoptname\fP 引き数と
.B \-q 
が指定されている場合には、
全ての \fIoptnames\fP が有効である時に返却ステータスが 0 となります。
それ以外の時には、0 でない値となります。
.TP
.B \-o
\fIoptname\fP の値を、組み込みコマンド
.B set
の
.B \-o
オプションで定義されているものに制限します。
.PD
.PP
引き数 \fIoptname\fP 無しで
.B \-s
オプションまたは
.B \-u
オプションを使った場合、表示されるものは設定されているもの、
または設定されていないものにそれぞれ制限されます。
特に断らない限り、\fBshopt\fP オプションは
デフォルトで無効 (設定解除) になっています。
.PP
オプションをリスト表示した時の返却ステータスは、
全ての \fIoptnames\fP が有効になっている場合は 0 となります。
それ以外の場合には 0 でない値となります。
設定または設定取り消しのオプションの時には、
\fIoptname\fP が不正なシェルオプションでなければ、
返却ステータスは 0 となります。
.PP
\fBshopt\fP オプションのリストを以下に示します:
.if t .sp .5v
.if n .sp 1v
.PD 0
.TP 8
.B cdable_vars
設定されている場合、組み込みコマンド
.B cd
への引き数でディレクトリでないものは変数の名前と見なされ、
その値が変更先のディレクトリとなります。
.TP 8
.B cdspell
設定されている場合、
.B cd
コマンドのディレクトリ要素におけるスペルのちょっとした誤りは修正されます。
チェックされる誤りは、文字の入れ替わり・文字の欠け・
1 文字余分にあることです。
訂正できた場合には、訂正後のファイル名が表示され、
コマンドは続けて実行されます。
このオプションが使われるのは対話的シェルだけです。
.TP 8
.B checkhash
設定されている場合、
\fBbash\fP はハッシュ表で見つけたコマンドを実行する前に
実際に存在するかどうかをチェックします。
ハッシュされているコマンドが既に無くなっている場合、
通常のパス検索が行われます。
.TP 8
.B checkwinsize
設定されている場合、\fBbash\fP
はコマンドの実行後に毎回ウィンドウの大きさをチェックし、
必要に応じて
.SM
.B LINES
と
.SM
.B COLUMNS
の値を更新します。
.TP 8
.B cmdhist
設定されている場合、
.B bash
は複数行に分かれているコマンドの全ての行を、
同じ履歴エントリに保存しようとします。
これを使うと、複数行に分かれているコマンドの再編集が容易になります。
.TP 8
.B dotglob
設定されている場合、
.B bash
は `.' で始まるファイル名をパス名展開の結果に含めます。
.TP 8
.B execfail
設定されている場合、
組み込みコマンド
.B exec
への引き数として指定されたファイルが実行できなくても、
対話的でないシェルが終了しません。
対話的シェルは
.B exec
に失敗しても終了しません。
.TP 8
.B expand_aliases
設定されている場合、エイリアスが前述の
.SM
.B エイリアス
セクションで説明したように展開されます。
このオプションは、対話的なシェルではデフォルトで有効です。
.TP 8
.B extglob
設定されている場合、拡張されたパターンマッチング機能が有効になります。
これについては、前述の\fBパス名展開\fPで説明しています。
.TP 8
.B histappend
設定されている場合、シェルの終了時に履歴リストが変数
.B HISTFILE
の値で指定しているファイルに追加されます。
ファイルへの上書きは行われなくなります。
.TP 8
.B histreedit
この変数が設定されており、かつ
.B readline
が使われている場合、ユーザは失敗した履歴置換を再編集できます。
.TP 8
.B histverify
この変数が設定されており、かつ
.B readline
が使われている場合、履歴置換の結果は即座にはシェルのパーザに渡されません。
その代わり、結果として得られた行は
\fBreadline\fP の編集バッファに読み込まれ、さらに修正できます。
.TP 8
.B hostcomplete
この変数が設定されており、かつ
.B readline
が使われている場合、\fBbash\fP は
\fB@\fP を含む単語を補完する時にホスト名補完を実行しようとします
(前述の
.SM
.B READLINE ライブラリ
のセクションにおける
.B 補完
を参照)。
これはデフォルトで有効になっています。
.TP 8
.B huponexit
設定されている場合、\fBbash\fP は対話的なログインシェルを終了する時に、
全てのジョブに
.SM
.B SIGHUP
を送ります。
.TP 8
.B interactive_comments
設定されている場合、
.B #
で始まる単語について、その単語とその行の残りの文字を
対話的シェルに無視させることができます
(前述の
.SM
.B コメント
セクションを参照)。
このオプションはデフォルトで有効になっています。
.TP 8
.B lithist
設定されており、かつ
.B cmdhist
オプションが有効ならば、
複数行に分かれているコマンドは (セミコロンで区切られるのではなく)
できる限り途中に改行を埋め込むことで履歴に保存されます。
.TP 8
.B mailwarn
設定されており、かつ \fBbash\fP がメールをチェックするファイルが
前回のチェック以降にアクセスされている場合、
メッセージ ``The mail in \fImailfile\fP has been read'' が表示されます。
.TP 8
.B no_empty_cmd_completion
設定されており、かつ
.B readline
が使われている場合、
空行に対してコマンド補完をさせようとしたときに、
.B bash
は補完用の \fBPATH\fP 検索を行いません。
.TP 8
.B nocaseglob
設定されている場合、
.B bash
はパス名展開 (前述の
.B パス名展開
を参照) を行う時に、
ファイル名の大文字と小文字を区別せずにマッチングを行います。
.TP 8
.B nullglob
設定されている場合、
.B bash
はどのファイルにもマッチしないパターン (前述の
.B パス名展開 
を参照) を、その文字列自身ではなく、空文字列に展開します。
.TP 8
.B progcomp
設定されている場合、プログラム補完機能
(前述の\fBプログラム補完\fPを参照) が有効になります。
このオプションはデフォルトで有効になっています。
.TP 8
.B promptvars
設定されている場合、
プロンプト文字列に対して変数展開とパラメータ展開が行われます。
この展開は前述の
.SM
.B プロンプト
セクションで説明した展開が行われた後に行われます。
このオプションはデフォルトで有効になっています。
.TP 8
.B restricted_shell
シェルが制限モードで起動された場合、
このオプションが設定されます (後述の
.SM
.B 制限付きのシェル
セクションを参照)。
この値を変更することはできません。
これは起動ファイルが実行される時にもリセットされないので、
シェルが制限付きかどうかを起動ファイル内部で知ることができます。
.TP 8
.B shift_verbose
設定されている場合、組み込みコマンド
.B shift
においてシフトの回数が位置パラメータの数を超えると、
エラーメッセージが出力されます。
.TP 8
.B sourcepath
設定されている場合、組み込みコマンド \fBsource\fP (\fB.\fP) は
.SM
.B PATH
の値を使って、引き数として与えられたファイルを含むディレクトリを見つけます。
このオプションはデフォルトで有効です。
.TP 8
.B xpg_echo
設定されている場合、
組み込みコマンド \fBecho\fP は
デフォルトでバックスラッシュによるエスケープシーケンスを展開します。
.RE
.TP
\fBsuspend\fP [\fB\-f\fP]
.SM
.B SIGCONT
シグナルを受け取るまで、シェルの実行をサスペンドします。
.B \-f
オプションを与えた場合、シェルがログインシェルであっても警告を出しません。
ただし、どちらにせよサスペンドはします。
シェルがログインシェルかつ
.B \-f
が与えられていない場合と、ジョブ制御が有効でない場合とを除いて、
返却ステータスは 0 です。
.TP
.PD 0
\fBtest\fP \fIexpr\fP
.TP
\fB[\fP \fIexpr\fP \fB]\fP
条件式
.IR expr
を評価した結果に基づいて、ステータス 0 または 1 を返します。
演算子とオペランドそれぞれは別々の引き数でなければなりません。
式は前述の
.SM
.B 条件式
セクションで説明したプライマリで構成されます。
.if t .sp 0.5
.if n .sp 1
式は次に示す演算子を使って結合できます。
優先度の高い順に示します。
.RS
.PD 0
.TP
.B ! \fIexpr\fP
.I expr
が偽ならば真になります。
.TP
.B ( \fIexpr\fP )
\fIexpr\fP の値を返します。
これを使うと、通常の演算子の優先度を変更できます。
.TP
\fIexpr1\fP \-\fBa\fP \fIexpr2\fP
.I expr1
と
.I expr2
が両方とも真ならば真になります。
.TP
\fIexpr1\fP \-\fBo\fP \fIexpr2\fP
.I expr1
と
.I expr2
のいずれかが真ならば真になります。
.PD
.PP
\fBtest\fP および \fB[\fP は、
引き数の数に基づいた規則の集合を用いて条件式を評価します。
.if t .sp 0.5
.if n .sp 1
.PD 0
.TP
引き数が 0 個
この式は偽です。
.TP
引き数が 1 個
引き数が空でない場合に限り真になります。
.TP
引き数が 2 個
最初の引き数が \fB!\fP ならば、
2 番目の引き数が空の場合に限り真になります。
最初の引き数が、既に
.SM
.B 条件式
セクションで説明した単項条件演算子のいずれかであれば、
単項の評価が真の場合に式は真となります。
最初の引き数が正しい単項条件演算子でなければ、式は偽となります。
.TP
引き数が 3 個
2 番目の引き数が、既に
.SM
.B 条件式
セクションで説明した二値条件演算子のいずれかであれば、
最初と 3 番目の引き数をオペランドとして使った
二値評価の結果が式の結果となります。
最初の引き数が \fB!\fP であれば、2 番目と 3 番目の引き数を使った、
引き数 2 つの評価の結果を否定したものが値となります。
最初の引き数が \fB(\fP であり、3 番目の引き数が \fB)\fP ならば、
2 番目の引き数を使って引き数 1 つの評価を行った値が結果となります。
これら以外の場合には、式は偽となります。
この場合においては、\fB\-a\fP と \fB\-o\fP は二値演算子として扱われます。
.TP
引き数が 4 個
最初の引き数が \fB!\fP ならば、
残りの引き数で作った引き数 3 つの式の値を否定したものが結果となります。
それ以外の場合には、先に挙げた規則を使った優先度に従って
式が展開・評価されます。
.TP
引き数が 5 個以上
先に挙げた規則を使った優先度に従って式が展開・評価されます。
.RE
.PD
.TP
.B times
シェルとシェルから実行したプロセスについて、
ユーザ時間とシステム時間を加えたものを出力します。
返却ステータスは 0 です。
.TP
\fBtrap\fP [\fB\-lp\fP] [\fIarg\fP] [\fIsigspec\fP ...]
シェルがシグナル
.IR sigspec
を受け取ると、コマンド
.I arg
が読み込まれて、実行されます。
.I arg
が存在しないか、
.B \-
である場合、
指定されているシグナルは全て最初の値
(シェルの起動時に設定されていた値) にリセットされます。
.I arg
が空文字列である場合、それぞれの
.I sigspec
で指定されているシグナルは、
シェルとシェルが起動したコマンドから無視されます。
.I arg
なしで
.B \-p
オプションが与えられた場合、
各
.I sigspec
に対応する trap コマンドが表示されます。
引き数が全く無いか、
.B \-p
だけが与えられた場合、
.B trap
は各シグナル番号に対応するコマンドのリストを出力します。
それぞれの
.I sigspec
は、<\fIsignal.h\fP> で定義されているシグナル名またはシグナル番号です。
.I sigspec
が
.SM
.B EXIT
(0) であれば、シェルの終了時にコマンド
.I arg
が実行されます。
.I sigspec
が
.SM
.B DEBUG
であれば、\fI単純なコマンド\fP (前述の
.SM
.B シェルの文法
セクションを参照) が終わるたびにコマンド
.I arg
が実行されます。
.B \-l
オプションを与えると、
シェルはシグナル名とこれに対応する番号のリストを出力します。
シェルのエントリで無視されるシグナルは、
トラップもリセットもできません。
トラップされたシグナルはリセットされ、
子プロセスが生成された時の最初の値に戻ります。
.I sigspec
のいずれかが不正であれば、返却ステータスは偽になります。
それ以外の場合には、
.B trap
は真を返します。
.TP
\fBtype\fP [\fB\-atp\fP] \fIname\fP [\fIname\fP ...]
オプション無しの場合には、各
.I name
をコマンド名として使ったときに、それがどのように解釈されるかを示します。
.B \-t
オプションを使うと、
.I name
が、エイリアス・シェルの予約語・関数・
組み込みコマンド・ディスク上のファイルのいずれかの場合、
.B type
はそれぞれに応じて
.IR alias ,
.IR keyword ,
.IR function ,
.IR builtin ,
.I file
という文字列を出力します。
.I name
が見つからない場合は何も出力されず、偽の終了ステータスが返されます。
.B \-p
オプションを使うと、
.B type
は
.I name
をコマンド名として指定した場合に実行されるディスクファイルの名前、
または空文字列を返します。
空文字列が返されるのは、
.if t \f(CWtype -t name\fP
.if n ``type -t name''
が
.I file
を返さない場合です。
コマンドがハッシュされている場合、
.B \-p
はハッシュされている値を表示します。
表示されるのは、必ずしも
.SM
.BR PATH
中で最初に現われるファイルとは限りません。
.B \-a
オプションを使うと、
.B type
は
.IR name
が示す実行ファイルがある場所を全て出力します。
.B \-p
オプションが同時に使われていない場合に限り、
エイリアスや関数も出力されます。
.B \-a
を使う時には、ハッシュされているコマンドの表は参照されません。
.B type
は、引き数のいずれかが見つかれば真を返し、
どれも見つからなければ偽を返します。
.TP
\fBulimit\fP [\fB\-SHacdflmnpstuv\fP [\fIlimit\fP]]
これを使うと、シェルおよびシェルが起動するプロセスが
利用できるリソースを制御できます。
ただし、このような制御ができるシステムの場合に限ります。
.I limit
の値はリソースに対して指定されている単位の数、または
.B unlimited
です。
\fB\-H\fP オプションと \fB\-S\fP オプションは、
それぞれ与えられたリソースに対する
強い (hard) 制限と弱い (soft) 制限を設定します。
強い制限は一度設定すると増やせません。
弱い制限は強い制限の値までは増やせます。
\fB\-H\fP と \fB\-S\fP がどちらも指定されていない場合、
強い制限と弱い制限がどちらも設定されます。
.I limit
を省略すると、リソースの弱い制限の現在値が表示されます。
ただし、\fB\-H\fP が与えられている場合は除きます。
複数のリソースが指定されている時は、制限名と単位が値の前に出力されます。
他のオプションは以下のように解釈されます:
.RS
.PD 0
.TP
.B \-a
現在の制限を全て報告する
.TP
.B \-c
生成されるコアファイル (core) の最大サイズ
.TP
.B \-d
プロセスのデータセグメントの最大サイズ
.TP
.B \-f
シェルが生成できるファイルの最大サイズ
.TP
.B \-l
メモリにロックできる最大サイズ
.TP
.B \-m
常駐セットサイズの最大値
.TP
.B \-n
オープンできるファイル・ディスクリプターの最大数
(ほとんどのシステムでは、この値を設定することはできません)
.TP
.B \-p
512 バイトブロック単位でのパイプのサイズ
(これは設定できないかもしれません)
.TP
.B \-s
最大スタックサイズ
.TP
.B \-t
CPU 時間の最大量 (秒単位)
.TP
.B \-u
1 人のユーザが使用できる最大のプロセス数
.TP
.B \-v
シェルが使用できる最大の仮想メモリ量
.PD
.PP
.I limit
が与えられている場合、これは指定されたリソースの新しい値となります
.RB ( \-a
は表示専用です)。
オプションが全く与えられなかった場合は、
.B \-f
が指定されたものと見なされます。
値は 1024 バイト単位で増えますが、例外として
.B \-t
は秒単位、
.B \-p
512 バイトブロック単位、
.B \-n
および
.B \-u
は単位無しの値です。
返却ステータスは基本的に 0 ですが、
不正なオプションがある場合、
\fBunlimited\fP 以外の数字でない引き数が \fIlimit\fP に指定された場合、
新しい制限を設定する際にエラーが起きた場合は除きます。
.RE
.TP
\fBumask\fP [\fB\-p\fP] [\fB\-S\fP] [\fImode\fP]
ユーザのファイル生成マスクに
.IR mode
を設定します。
.I mode
が数字で始まる場合には、これは 10 進数と解釈されます。
それ以外の場合には、
.IR chmod (1)
に指定するのと同様のシンボリックなモードマスクと解釈されます。
.I mode
が省略されると、現在のマスクの値が出力されます。
.B \-S
オプションを指定すると、マスクはシンボリックな形式で表示されます。
デフルトの出力は 10 進の数値です。
.B \-p
オプションが指定され、かつ
.I mode
が省略された場合、入力として再利用できる形式で出力が行われます。
モードが正常に変更できた場合や、
\fImode\fP 引き数が全く与えられなかった場合には、
返却ステータスは 0 となります。
それ以外の場合には偽となります。
.TP
\fBunalias\fP [\-\fBa\fP] [\fIname\fP ...]
\fIname\fP を定義されているエイリアスのリストから削除します。
.B \-a
が与えられている場合には、エイリアス定義は全て削除されます。
与えられた
.I name
が定義されているエイリアスであれば、返却ステータスは真になります。
.TP
\fBunset\fP [\-\fBfv\fP] [\fIname\fP ...]
.IR name
それぞれについて、対応する変数や関数を削除します。
オプションが全く与えられていない場合や、
.B \-v
オプションが与えられた場合は、各
.I name
はシェル変数を参照します。
読み込み専用の変数の設定を消すことはできません。
.B \-f
が指定されている場合、各
.I name
はシェル関数を参照し、その関数の定義が削除されます。
設定が消された変数や関数は全て、
それ以降のコマンドに渡される環境変数からも削除されます。
.SM
.BR RANDOM ,
.SM
.BR SECONDS ,
.SM
.BR LINENO ,
.SM
.BR HISTCMD ,
.SM
.BR FUNCNAME ,
.SM
.BR GROUPS ,
.SM
.B DIRSTACK
のいずれかの設定を消した場合、これらの特殊な特性も無くなります。
これは後で再設定しても元に戻ることはありません。
.I name
が存在しないか、読み込み専用の場合以外には、
終了ステータスは真となります。
.TP
\fBwait\fP [\fIn\fP]
指定されたプロセスを wait し、その終了ステータスを返します。
.I n
はプロセス ID またはジョブ指定です。
ジョブ指定を与えた場合、そのジョブのパイプラインに含まれる
全てのプロセスを wait します。
.I n
が与えられていない場合には、現在アクティブな全ての子プロセスを wait し、
返却ステータスは 0 となります。
.I n
が存在しないプロセスやジョブを指定している場合、
返却ステータスは 127 になります。
それ以外の場合、返却ステータスは
wait していた最後のプロセスまたはジョブの終了ステータスとなります。
.\" bash_builtins
.if \n(zZ=1 .ig zZ
.SH "制限付きのシェル(RESTRICTED SHELL)"
.zY
.PP
.B bash
を
.BR rbash
という名前で起動した場合や、起動時に
.B \-r
オプションを指定した場合には、シェルは制限された状態になります。
制限付きのシェルは、
標準のシェルよりも細かく制御された環境を設定したいときに用います。
制限付きのシェルは
.B bash
と全く同じように動作しますが、
以下のようなことが許可されなかったり実行されなかったりします:
.IP \(bu
\fBcd\fP を使ってディレクトリを変更すること
.IP \(bu
.BR SHELL ,
.BR PATH ,
.BR ENV ,
.B BASH_ENV
の値の設定や設定取り消しを行なうこと
.IP \(bu
.B /
を含むコマンド名を指定すること
.IP \(bu
組み込みコマンド
.B .
の引き数として
.B /
を含むファイル名を指定すること
.IP \(bu
.\" motoki: -p オプション自体が使用できないはずでは。
組み込みコマンド
.B hash
に対するオプション
.B \-p
の引数として
.B /
を含むファイル名を指定すること
.IP \(bu
起動時にシェル環境から関数定義をインポートすること
.IP \(bu
起動時にシェル環境から \fBSHELLOPTS\fP の値を展開すること
.IP \(bu
リダイレクション演算子 >, >|, <>, >&, &>, >> を使ってリダイレクトを行
なうこと
.IP \(bu
組み込みコマンド
.B exec
を用いて、シェルを別のコマンドに置き換えること
.IP \(bu
組み込みコマンド
.B enable
に対する
.B \-f
オプションと
.B \-d
オプションを使って、組み込みコマンドを追加・削除すること
.IP \(bu
組み込みコマンド
.B command
に
.B \-p
オプションを指定すること
.IP \(bu
\fBset +r\fP や \fBset +o restricted\fP を用いて制限モードを解除すること
.PP
これらの制限は、何らかの起動ファイルを読み込んだ後に適用されます。
.PP
シェルスクリプトであると判明したファイルが実行された時 (前述の
.SM
.B コマンドの実行
を参照) には、
.B rbash
はスクリプト実行用に立ち上げたシェルでは制限を全て無効にします。
.if \n(zY=1 .ig zY
.SH 関連項目
.PD 0
.TP
\fIBash Reference Manual\fP, Brian Fox and Chet Ramey
.TP
\fIThe Gnu Readline Library\fP, Brian Fox and Chet Ramey
.TP
\fIThe Gnu History Library\fP, Brian Fox and Chet Ramey
.TP
\fIPortable Operating System Interface (POSIX) Part 2: Shell and Utilities\fP, IEEE
.TP
\fIsh\fP(1), \fIksh\fP(1), \fIcsh\fP(1)
.TP
\fIemacs\fP(1), \fIvi\fP(1)
.TP
\fIreadline\fP(3)
.PD
.SH ファイル
.PD 0
.TP
.FN /bin/bash
\fBbash\fP の実行ファイル。
.TP
.FN /etc/profile
システム全体用の初期化ファイル。ログインシェルが実行します。
.TP
.FN ~/.bash_profile
個人用の初期化ファイル。ログインシェルが実行します。
.TP
.FN ~/.bashrc
対話シェルごとに実行される、個人用の起動ファイル。
.TP
.FN ~/.bash_logout
個人用のログインシェル後処理ファイル。
ログインシェルの終了時に実行されます。
.TP
.FN ~/.inputrc
個人用の \fIreadline\fP 初期化ファイル。
.PD
.SH 著者
Brian Fox, Free Software Foundation
.br
bfox@gnu.org
.PP
Chet Ramey, Case Western Reserve University
.br
chet@ins.CWRU.Edu
.SH バグ報告
.B bash
のバグを見つけたら必ず報告してください。
ただし報告の前には、それが本当にバグであることと、
バグが最新版の
.B bash
で起こることを確かめてください。
.PP
本当にバグがあると判断した場合には、
.I bashbug
コマンドを使ってバグ報告を行います。
バグを修正してくださった場合には、
ぜひその内容も一緒にメールしてください!
提案や「哲学上の」バグ報告は、\fIbug-bash@gnu.org\fP にメールしたり、
ニュースグループの
.BR gnu.bash.bug
に投稿してくださっても構いません。
.PP
バグ報告には必ず以下のことを書いてください:
.PP
.PD 0
.TP 20
\fBbash\fR のバージョン
.TP
ハードウェアとオペレーティングシステム
.TP
コンパイルに使ったコンパイラ
.TP
バグ動作の説明
.TP
バグを再現できる簡単なシェルスクリプトまたは「レシピ」
.PD
.PP
.I bashbug
コマンドは、バグ報告を送るために用意されているテンプレートに、
最初の 3 項目を自動的に書き込みます。
.PP
このオンラインマニュアルに関するコメントやバグ報告は
.IR chet@ins.CWRU.Edu
宛にお願いします。
.SH バグ
.PP
.B bash
は大きすぎるし、遅すぎます。
.PP
.B bash
と昔ながらのバージョンの
.BR sh
にはちょっとした違いがいくつかあります。この大部分は
.SM
.B POSIX
の仕様のせいで生じたものです。
.PP
使い方によっては、エイリアスは混乱の元になります。
.PP
シェル組み込みコマンドとシェル関数は停止・再実行できません。
.PP
複合コマンドや `a ; b ; c' の形式のコマンド列は、
プロセスのサスペンドを行う際に綺麗に扱うことができません。
プロセスを停止すると、
シェルはコマンド列の次のコマンドを即座に実行するからです。
この問題はコマンド列を括弧の中に置いて
サブシェルに実行させることで解決できます。
こうすれば、ひとまとまりのものとして停止できます。
.PP
\fB$(\fP...\fB)\fP  を使ったコマンド置換の内部にあるコマンドは、
置換が実行される時まで展開されません。
これにより、コマンドを入力してしばらく経つまでエラー出力が遅れます。
.PP
配列変数は (まだ) エクスポートできません。
.zZ
.zY
